C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b13224;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a13224;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c13224
<<<<<<< MINE
=======
private void checkNullSafety(@Nullable JetType receiverType, @NotNull ASTNode operationTokenNode, @Nullable FunctionDescriptor callee) {
            if (receiverType != null && callee != null) {
                boolean namespaceType = receiverType instanceof NamespaceType;
                boolean nullableReceiver = !namespaceType && receiverType.isNullable();
                ReceiverDescriptor calleeReceiver = callee.getReceiver();
                boolean calleeForbidsNullableReceiver = !calleeReceiver.exists() || !calleeReceiver.getType().isNullable();

                IElementType operationSign = operationTokenNode.getElementType();
                if (nullableReceiver && calleeForbidsNullableReceiver && operationSign == JetTokens.DOT) {
//                    trace.getErrorHandler().genericError(operationTokenNode, "Only safe calls (?.) are allowed on a nullable receiver of type " + receiverType);
                    trace.report(UNSAFE_CALL.on(operationTokenNode, receiverType));
                }
                else if ((!nullableReceiver || !calleeForbidsNullableReceiver) && operationSign == JetTokens.SAFE_ACCESS) {
                    if (namespaceType) {
//                        trace.getErrorHandler().genericError(operationTokenNode, "Safe calls are not allowed on namespaces");
                        trace.report(SAFE_CALLS_ARE_NOT_ALLOWED_ON_NAMESPACES.on(operationTokenNode));
                    }
                    else {
//                        trace.getErrorHandler().genericWarning(operationTokenNode, "Unnecessary safe call on a non-null receiver of type  " + receiverType);

                        trace.report(UNNECESSARY_SAFE_CALL.on(operationTokenNode, receiverType));

                    }
                }
            }
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c11836
<<<<<<< MINE
=======
//    private final JetFlowInformationProvider flowInformationProvider;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c11836
<<<<<<< MINE
//        TODO JetElement -> JetWhenConditionCall || JetQualifiedExpression
//        private void checkNullSafety(@Nullable JetType receiverType, @NotNull ASTNode operationTokenNode, @Nullable FunctionDescriptor callee, @NotNull JetElement element) {
//            if (receiverType != null && callee != null) {
//                boolean namespaceType = receiverType instanceof NamespaceType;
//                boolean nullableReceiver = !namespaceType && receiverType.isNullable();
//                ReceiverDescriptor calleeReceiver = callee.getReceiverParameter();
//                boolean calleeForbidsNullableReceiver = !calleeReceiver.exists() || !calleeReceiver.getType().isNullable();
//
//                IElementType operationSign = operationTokenNode.getElementType();
//                if (nullableReceiver && calleeForbidsNullableReceiver && operationSign == JetTokens.DOT) {
////                    trace.getErrorHandler().genericError(operationTokenNode, "Only safe calls (?.) are allowed on a nullable receiver of type " + receiverType);
//                    trace.report(UNSAFE_CALL.on(operationTokenNode, receiverType));
//                }
//                else if ((!nullableReceiver || !calleeForbidsNullableReceiver) && operationSign == JetTokens.SAFE_ACCESS) {
//                    if (namespaceType) {
////                        trace.getErrorHandler().genericError(operationTokenNode, "Safe calls are not allowed on namespaces");
//                        trace.report(SAFE_CALLS_ARE_NOT_ALLOWED_ON_NAMESPACES.on(operationTokenNode));
//                    }
//                    else {
////                        trace.getErrorHandler().genericWarning(operationTokenNode, "Unnecessary safe call on a non-null receiver of type  " + receiverType);
//
//                        trace.report(UNNECESSARY_SAFE_CALL.on(element, operationTokenNode, receiverType));
//
//                    }
//                }
//            }
//        }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c11836
<<<<<<< MINE
private void checkFunctionReturnType(JetScope functionInnerScope, JetDeclarationWithBody function, @NotNull final JetType expectedReturnType, @NotNull DataFlowInfo dataFlowInfo) {
            JetExpression bodyExpression = function.getBodyExpression();
            if (bodyExpression == null) return;
            
            final boolean blockBody = function.hasBlockBody();
            final TypeInferenceContext context =
                    blockBody
                    ? newContext(trace, functionInnerScope, dataFlowInfo, NO_EXPECTED_TYPE, expectedReturnType)
                    : newContext(trace, functionInnerScope, dataFlowInfo, expectedReturnType, FORBIDDEN);

            if (function instanceof JetFunctionLiteralExpression) {
                JetFunctionLiteralExpression functionLiteralExpression = (JetFunctionLiteralExpression) function;
                getBlockReturnedType(functionInnerScope, functionLiteralExpression.getBodyExpression(), CoercionStrategy.COERCION_TO_UNIT, context);
            }
            else {
                typeInferrerVisitor.getType(bodyExpression, context);
            }

            List<JetElement> unreachableElements = Lists.newArrayList();
            flowInformationProvider.collectUnreachableExpressions(function.asElement(), unreachableElements);

            // This is needed in order to highlight only '1 < 2' and not '1', '<' and '2' as well
            final Set<JetElement> rootUnreachableElements = JetPsiUtil.findRootExpressions(unreachableElements);

            // TODO : (return 1) || (return 2) -- only || and right of it is unreachable
            // TODO : try {return 1} finally {return 2}. Currently 'return 1' is reported as unreachable,
            //        though it'd better be reported more specifically

            for (JetElement element : rootUnreachableElements) {
//                trace.getErrorHandler().genericError(element.getNode(), "Unreachable code");
                trace.report(UNREACHABLE_CODE.on(element));
            }

            List<JetExpression> returnedExpressions = Lists.newArrayList();
            flowInformationProvider.collectReturnExpressions(function.asElement(), returnedExpressions);

            boolean nothingReturned = returnedExpressions.isEmpty();

            returnedExpressions.remove(function); // This will be the only "expression" if the body is empty

            if (expectedReturnType != NO_EXPECTED_TYPE && !JetStandardClasses.isUnit(expectedReturnType) && returnedExpressions.isEmpty() && !nothingReturned) {
//                trace.getErrorHandler().genericError(bodyExpression.getNode(), "This function must return a value of type " + expectedReturnType);
                trace.report(RETURN_TYPE_MISMATCH.on(bodyExpression, expectedReturnType));
            }

            for (JetExpression returnedExpression : returnedExpressions) {
                returnedExpression.accept(new JetVisitorVoid() {
                    @Override
                    public void visitReturnExpression(JetReturnExpression expression) {
                        if (!blockBody) {
//                            trace.getErrorHandler().genericError(expression.getNode(), "Returns are not allowed for functions with expression body. Use block body in '{...}'");
                            trace.report(RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY.on(expression));
                        }
                    }

                    @Override
                    public void visitExpression(JetExpression expression) {
                        if (blockBody && !JetStandardClasses.isUnit(expectedReturnType) && !rootUnreachableElements.contains(expression)) {
                            //TODO move to pseudocode
                            JetType type = typeInferrerVisitor.getType(expression, context.replaceExpectedType(NO_EXPECTED_TYPE));
                            if (type == null || !JetStandardClasses.isNothing(type)) {
//                                trace.getErrorHandler().genericError(expression.getNode(), "A 'return' expression required in a function with a block body ('{...}')");
                                trace.report(NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY.on(expression));
                            }
                        }
                    }
                });
            }
        }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c11836
<<<<<<< MINE
//        //TODO
//        private JetType enrichOutType(JetExpression expression, JetType initialType, @NotNull TypeInferenceContext context) {
//            if (expression == null) return initialType;
//            VariableDescriptor variableDescriptor = getVariableDescriptorFromSimpleName(expression, context);
//            if (variableDescriptor != null) {
//                return context.dataFlowInfo.getOutType(variableDescriptor);
//            }
//            return initialType;
//        }

//        @Nullable
//        private JetType checkType(@Nullable JetType expressionType, @NotNull JetExpression expression, @NotNull TypeInferenceContext context) {
//            if (expressionType != null && context.expectedType != null && context.expectedType != NO_EXPECTED_TYPE) {
//                if (!semanticServices.getTypeChecker().isSubtypeOf(expressionType, context.expectedType)) {
//                    context.trace.report(TYPE_MISMATCH.on(expression, context.expectedType, expressionType));
//                }
//            }
//            return expressionType;
//        }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a11836;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c11836
<<<<<<< MINE
//        private void checkAutoCast(JetExpression expression, JetType type, VariableDescriptor variableDescriptor, BindingTrace trace) {
//            if (variableDescriptor.isVar()) {
////                trace.getErrorHandler().genericError(expression.getNode(), "Automatic cast to " + type + " is impossible, because variable " + variableDescriptor.getName() + " is mutable");
//                trace.report(AUTOCAST_IMPOSSIBLE.on(expression, type, variableDescriptor));
//            } else {
//                trace.record(BindingContext.AUTOCAST, expression, type);
//            }
//        }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b07548;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a07548;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c07548
<<<<<<< MINE
DiagnosticFactory1<JetModifierListOwner, CallableMemberDescriptor> NOTHING_TO_OVERRIDE = DiagnosticFactory1.create(ERROR, "{0} overrides nothing", PositioningStrategies.POSITION_OVERRIDE_MODIFIER, DescriptorRenderer.TEXT);
=======
DiagnosticFactory1<JetModifierListOwner, CallableMemberDescriptor> NOTHING_TO_OVERRIDE =
            DiagnosticFactory1.create(ERROR, PositioningStrategies.positionModifier(JetTokens.OVERRIDE_KEYWORD));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b07548;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a07548;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c07548
<<<<<<< MINE
DiagnosticFactory3<PsiNameIdentifierOwner, CallableMemberDescriptor, CallableMemberDescriptor, DeclarationDescriptor> VIRTUAL_MEMBER_HIDDEN =
            DiagnosticFactory3.create(ERROR, "''{0}'' hides ''{1}'' in class {2} and needs 'override' modifier", PositioningStrategies.POSITION_NAME_IDENTIFIER, DescriptorRenderer.TEXT, DescriptorRenderer.TEXT, DescriptorRenderer.TEXT);
=======
DiagnosticFactory3<PsiNameIdentifierOwner, CallableMemberDescriptor, CallableMemberDescriptor, DeclarationDescriptor>
            VIRTUAL_MEMBER_HIDDEN = DiagnosticFactory3.create(ERROR, PositioningStrategies.POSITION_NAME_IDENTIFIER);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b10604;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a10604;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c10604
<<<<<<< MINE
        FileReader reader = new FileReader(inputFile);
        try {
            context.evaluateReader(scope, reader, inputFile, 1, null);
        }
        finally {
            reader.close();
        }
=======
        context.evaluateString(scope, fileToString(inputFile), inputFile, 1, null);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_b10604;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_a10604;C:\Users\Alice Borner\Desktop\projects\kotlin\git\.merge_file_c10604
<<<<<<< MINE
        }
        finally {
=======

        lintIt(context, fileNames.get(fileNames.size() - 1));

>>>>>>> YOURS
