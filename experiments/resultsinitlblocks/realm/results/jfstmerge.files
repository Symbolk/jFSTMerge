20190526_211215,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11336
package io.realm;


import android.annotation.TargetApi;
import android.os.Build;
import android.util.JsonReader;
import android.util.JsonToken;
import io.realm.exceptions.RealmMigrationNeededException;
import io.realm.internal.ColumnInfo;
import io.realm.internal.LinkView;
import io.realm.internal.OsObject;
import io.realm.internal.OsObjectSchemaInfo;
import io.realm.internal.Property;
import io.realm.internal.ProxyUtils;
import io.realm.internal.RealmObjectProxy;
import io.realm.internal.Row;
import io.realm.internal.SharedRealm;
import io.realm.internal.Table;
import io.realm.internal.UncheckedRow;
import io.realm.internal.android.JsonUtils;
import io.realm.log.RealmLog;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

@SuppressWarnings("all")
public class AllTypesRealmProxy extends some.test.AllTypes
    implements RealmObjectProxy, AllTypesRealmProxyInterface {

    static final class AllTypesColumnInfo extends ColumnInfo {
        long columnStringIndex;
        long columnLongIndex;
        long columnFloatIndex;
        long columnDoubleIndex;
        long columnBooleanIndex;
        long columnDateIndex;
        long columnBinaryIndex;
        long columnMutableRealmIntegerIndex;
        long columnObjectIndex;
        long columnRealmListIndex;

        AllTypesColumnInfo(SharedRealm realm, Table table) {
            super(10);
            this.columnStringIndex = addColumnDetails(table, "columnString", RealmFieldType.STRING);
            this.columnLongIndex = addColumnDetails(table, "columnLong", RealmFieldType.INTEGER);
            this.columnFloatIndex = addColumnDetails(table, "columnFloat", RealmFieldType.FLOAT);
            this.columnDoubleIndex = addColumnDetails(table, "columnDouble", RealmFieldType.DOUBLE);
            this.columnBooleanIndex = addColumnDetails(table, "columnBoolean", RealmFieldType.BOOLEAN);
            this.columnDateIndex = addColumnDetails(table, "columnDate", RealmFieldType.DATE);
            this.columnBinaryIndex = addColumnDetails(table, "columnBinary", RealmFieldType.BINARY);
            this.columnMutableRealmIntegerIndex = addColumnDetails(table, "columnMutableRealmInteger", RealmFieldType.INTEGER);
            this.columnObjectIndex = addColumnDetails(table, "columnObject", RealmFieldType.OBJECT);
            this.columnRealmListIndex = addColumnDetails(table, "columnRealmList", RealmFieldType.LIST);
            addBacklinkDetails(realm, "parentObjects", "AllTypes", "columnObject");
        }

        AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
            super(src, mutable);
            copy(src, this);
        }

        @Override
        protected final ColumnInfo copy(boolean mutable) {
            return new AllTypesColumnInfo(this, mutable);
        }

        @Override
        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
            final AllTypesColumnInfo src = (AllTypesColumnInfo) rawSrc;
            final AllTypesColumnInfo dst = (AllTypesColumnInfo) rawDst;
            dst.columnStringIndex = src.columnStringIndex;
            dst.columnLongIndex = src.columnLongIndex;
            dst.columnFloatIndex = src.columnFloatIndex;
            dst.columnDoubleIndex = src.columnDoubleIndex;
            dst.columnBooleanIndex = src.columnBooleanIndex;
            dst.columnDateIndex = src.columnDateIndex;
            dst.columnBinaryIndex = src.columnBinaryIndex;
            dst.columnMutableRealmIntegerIndex = src.columnMutableRealmIntegerIndex;
            dst.columnObjectIndex = src.columnObjectIndex;
            dst.columnRealmListIndex = src.columnRealmListIndex;
        }
    }

    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
    private static final List<String> FIELD_NAMES;
    static {
        List<String> fieldNames = new ArrayList<String>();
        fieldNames.add("columnString");
        fieldNames.add("columnLong");
        fieldNames.add("columnFloat");
        fieldNames.add("columnDouble");
        fieldNames.add("columnBoolean");
        fieldNames.add("columnDate");
        fieldNames.add("columnBinary");
        fieldNames.add("columnMutableRealmInteger");
        fieldNames.add("columnObject");
        fieldNames.add("columnRealmList");
        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
    }

    private AllTypesColumnInfo columnInfo;
    private ProxyState<some.test.AllTypes> proxyState;
    private final MutableRealmInteger.Managed columnMutableRealmIntegerMutableRealmInteger = new MutableRealmInteger.Managed<some.test.AllTypes>() {
                @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
                @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
            };
    private RealmList<some.test.AllTypes> columnRealmListRealmList;
    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;

    AllTypesRealmProxy() {
        proxyState.setConstructionFinished();
    }

    @Override
    public void realm$injectObjectContext() {
        if (this.proxyState != null) {
            return;
        }
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.AllTypes>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }

    @Override
    @SuppressWarnings("cast")
    public String realmGet$columnString() {
        proxyState.getRealm$realm().checkIfValid();
        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
    }

    @Override
    public void realmSet$columnString(String value) {
        if (proxyState.isUnderConstruction()) {
            // default value of the primary key is always ignored.
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        throw new io.realm.exceptions.RealmException("Primary key field 'columnString' cannot be changed after object was created.");
    }

    @Override
    @SuppressWarnings("cast")
    public long realmGet$columnLong() {
        proxyState.getRealm$realm().checkIfValid();
        return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
    }

    @Override
    public void realmSet$columnLong(long value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setLong(columnInfo.columnLongIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public float realmGet$columnFloat() {
        proxyState.getRealm$realm().checkIfValid();
        return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
    }

    @Override
    public void realmSet$columnFloat(float value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setFloat(columnInfo.columnFloatIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public double realmGet$columnDouble() {
        proxyState.getRealm$realm().checkIfValid();
        return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
    }

    @Override
    public void realmSet$columnDouble(double value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setDouble(columnInfo.columnDoubleIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public boolean realmGet$columnBoolean() {
        proxyState.getRealm$realm().checkIfValid();
        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
    }

    @Override
    public void realmSet$columnBoolean(boolean value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setBoolean(columnInfo.columnBooleanIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public Date realmGet$columnDate() {
        proxyState.getRealm$realm().checkIfValid();
        return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
    }

    @Override
    public void realmSet$columnDate(Date value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
            }
            row.getTable().setDate(columnInfo.columnDateIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
        }
        proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public byte[] realmGet$columnBinary() {
        proxyState.getRealm$realm().checkIfValid();
        return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
    }

    @Override
    public void realmSet$columnBinary(byte[] value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
            }
            row.getTable().setBinaryByteArray(columnInfo.columnBinaryIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
        }
        proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
    }

    @Override
    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
        proxyState.getRealm$realm().checkIfValid();
        return this.columnMutableRealmIntegerMutableRealmInteger;
    }

    @Override
    public some.test.AllTypes realmGet$columnObject() {
        proxyState.getRealm$realm().checkIfValid();
        if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
            return null;
        }
        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex), false, Collections.<String>emptyList());
    }

    @Override
    public void realmSet$columnObject(some.test.AllTypes value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            if (proxyState.getExcludeFields$realm().contains("columnObject")) {
                return;
            }
            if (value != null && !RealmObject.isManaged(value)) {
                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                // Table#nullifyLink() does not support default value. Just using Row.
                row.nullifyLink(columnInfo.columnObjectIndex);
                return;
            }
            if (!RealmObject.isValid(value)) {
                throw new IllegalArgumentException("'value' is not a valid managed object.");
            }
            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                throw new IllegalArgumentException("'value' belongs to a different Realm.");
            }
            row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
            return;
        }
        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
            throw new IllegalArgumentException("'value' is not a valid managed object.");
        }
        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
            throw new IllegalArgumentException("'value' belongs to a different Realm.");
        }
        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
    }

    @Override
    public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
        proxyState.getRealm$realm().checkIfValid();
        // use the cached value if available
        if (columnRealmListRealmList != null) {
            return columnRealmListRealmList;
        } else {
            LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, linkView, proxyState.getRealm$realm());
            return columnRealmListRealmList;
        }
    }

    @Override
    public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
                return;
            }
            if (value != null && !value.isManaged()) {
                final Realm realm = (Realm) proxyState.getRealm$realm();
                final RealmList<some.test.AllTypes> original = value;
                value = new RealmList<some.test.AllTypes>();
                for (some.test.AllTypes item : original) {
                    if (item == null || RealmObject.isManaged(item)) {
                        value.add(item);
                    } else {
                        value.add(realm.copyToRealm(item));
                    }
                }
            }
        }

        proxyState.getRealm$realm().checkIfValid();
        LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
        links.clear();
        if (value == null) {
            return;
        }
        for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
                throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
            }
            if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
            }
            links.add(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
        }
    }

    @Override
    public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
        BaseRealm realm = proxyState.getRealm$realm();
        realm.checkIfValid();
        proxyState.getRow$realm().checkIfAttached();
        if (parentObjectsBacklinks == null) {
            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
        }
        return parentObjectsBacklinks;
    }

    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes");
        builder.addPersistedProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
        builder.addPersistedProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addPersistedProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addPersistedProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addPersistedProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addPersistedProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addPersistedProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addPersistedProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
        builder.addPersistedLinkProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
        builder.addPersistedLinkProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
        builder.addComputedLinkProperty("parentObjects", "AllTypes", "columnObject");
        return builder.build();
    }

    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
        return expectedObjectSchemaInfo;
    }

    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
        }
        Table table = sharedRealm.getTable("class_AllTypes");
        final long columnCount = table.getColumnCount();
        if (columnCount != 10) {
            if (columnCount < 10) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 10 but was " + columnCount);
            }
            if (allowExtraColumns) {
                RealmLog.debug("Field count is more than expected - expected 10 but was %1$d", columnCount);
            } else {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 10 but was " + columnCount);
            }
        }
        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
        for (long i = 0; i < columnCount; i++) {
            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
        }

        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm, table);

        if (!table.hasPrimaryKey()) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
        } else {
            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
            }
        }

        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnString", RealmFieldType.STRING, "String");
        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
        }
        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnLong", RealmFieldType.INTEGER, "long");
        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnFloat", RealmFieldType.FLOAT, "float");
        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDouble", RealmFieldType.DOUBLE, "double");
        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBoolean", RealmFieldType.BOOLEAN, "boolean");
        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDate", RealmFieldType.DATE, "Date");
        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBinary", RealmFieldType.BINARY, "byte[]");
        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnMutableRealmInteger", RealmFieldType.INTEGER, "MutableRealmInteger");
        if (!table.isColumnNullable(columnInfo.columnMutableRealmIntegerIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnMutableRealmInteger' is required. Either set @Required to field 'columnMutableRealmInteger' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
        }
        Table table_8 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_8)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_8.getName() + "'");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
        }
        Table table_9 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_9)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_9.getName() + "'");
        }

        long backlinkFieldIndex;
        Table backlinkSourceTable;
        Table backlinkTargetTable;
        RealmFieldType backlinkFieldType;
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
        if (backlinkFieldIndex == Table.NO_MATCH) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
        }
        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
        if (!table.hasSameSchema(backlinkTargetTable)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
        }

        return columnInfo;
    }

    public static String getTableName() {
        return "class_AllTypes";
    }

    public static List<String> getFieldNames() {
        return FIELD_NAMES;
    }

    @SuppressWarnings("cast")
    public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
        throws JSONException {
        final List<String> excludeFields = new ArrayList<String>(2);
        some.test.AllTypes obj = null;
        if (update) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            long rowIndex = Table.NO_MATCH;
            if (json.isNull("columnString")) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
            }
            if (rowIndex != Table.NO_MATCH) {
                final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
                try {
                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                    obj = new io.realm.AllTypesRealmProxy();
                } finally {
                    objectContext.clear();
                }
            }
        }
        if (obj == null) {
            if (json.has("columnObject")) {
                excludeFields.add("columnObject");
            }
            if (json.has("columnRealmList")) {
                excludeFields.add("columnRealmList");
            }
            if (json.has("columnString")) {
                if (json.isNull("columnString")) {
                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
                } else {
                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, json.getString("columnString"), true, excludeFields);
                }
            } else {
                throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
            }
        }

        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
        if (json.has("columnLong")) {
            if (json.isNull("columnLong")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
            } else {
                objProxy.realmSet$columnLong((long) json.getLong("columnLong"));
            }
        }
        if (json.has("columnFloat")) {
            if (json.isNull("columnFloat")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
            } else {
                objProxy.realmSet$columnFloat((float) json.getDouble("columnFloat"));
            }
        }
        if (json.has("columnDouble")) {
            if (json.isNull("columnDouble")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
            } else {
                objProxy.realmSet$columnDouble((double) json.getDouble("columnDouble"));
            }
        }
        if (json.has("columnBoolean")) {
            if (json.isNull("columnBoolean")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
            } else {
                objProxy.realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
            }
        }
        if (json.has("columnDate")) {
            if (json.isNull("columnDate")) {
                objProxy.realmSet$columnDate(null);
            } else {
                Object timestamp = json.get("columnDate");
                if (timestamp instanceof String) {
                    objProxy.realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
                } else {
                    objProxy.realmSet$columnDate(new Date(json.getLong("columnDate")));
                }
            }
        }
        if (json.has("columnBinary")) {
            if (json.isNull("columnBinary")) {
                objProxy.realmSet$columnBinary(null);
            } else {
                objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
            }
        }
        if (json.has("columnMutableRealmInteger")) {
            objProxy.realmGet$columnMutableRealmInteger().set((json.isNull("columnMutableRealmInteger")) ? null : json.getLong("columnMutableRealmInteger"));
        }
        if (json.has("columnObject")) {
            if (json.isNull("columnObject")) {
                objProxy.realmSet$columnObject(null);
            } else {
                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
                objProxy.realmSet$columnObject(columnObjectObj);
            }
        }
        if (json.has("columnRealmList")) {
            if (json.isNull("columnRealmList")) {
                objProxy.realmSet$columnRealmList(null);
            } else {
                objProxy.realmGet$columnRealmList().clear();
                JSONArray array = json.getJSONArray("columnRealmList");
                for (int i = 0; i < array.length(); i++) {
                    some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
                    objProxy.realmGet$columnRealmList().add(item);
                }
            }
        }
        return obj;
    }

    @SuppressWarnings("cast")
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
        throws IOException {
        boolean jsonHasPrimaryKey = false;
        final some.test.AllTypes obj = new some.test.AllTypes();
        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
        reader.beginObject();
        while (reader.hasNext()) {
            String name = reader.nextName();
            if (false) {
            } else if (name.equals("columnString")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnString((String) reader.nextString());
                } else {
                    reader.skipValue();
                    objProxy.realmSet$columnString(null);
                }
                jsonHasPrimaryKey = true;
            } else if (name.equals("columnLong")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnLong((long) reader.nextLong());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
                }
            } else if (name.equals("columnFloat")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnFloat((float) reader.nextDouble());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
                }
            } else if (name.equals("columnDouble")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnDouble((double) reader.nextDouble());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
                }
            } else if (name.equals("columnBoolean")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnBoolean((boolean) reader.nextBoolean());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
                }
            } else if (name.equals("columnDate")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnDate(null);
                } else if (reader.peek() == JsonToken.NUMBER) {
                    long timestamp = reader.nextLong();
                    if (timestamp > -1) {
                        objProxy.realmSet$columnDate(new Date(timestamp));
                    }
                } else {
                    objProxy.realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
                }
            } else if (name.equals("columnBinary")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
                } else {
                    reader.skipValue();
                    objProxy.realmSet$columnBinary(null);
                }
            } else if (name.equals("columnMutableRealmInteger")) {
                Long val = null;
                if (reader.peek() != JsonToken.NULL) {
                    val = reader.nextLong()
                } else {
                    reader.skipValue();
                }
                objProxy.realmGet$columnMutableRealmInteger().set(val);
            } else if (name.equals("columnObject")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnObject(null);
                } else {
                    some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                    objProxy.realmSet$columnObject(columnObjectObj);
                }
            } else if (name.equals("columnRealmList")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnRealmList(null);
                } else {
                    objProxy.realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                    reader.beginArray();
                    while (reader.hasNext()) {
                        some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                        objProxy.realmGet$columnRealmList().add(item);
                    }
                    reader.endArray();
                }
            } else {
                reader.skipValue();
            }
        }
        reader.endObject();
        if (!jsonHasPrimaryKey) {
            throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
        }
        return realm.copyToRealm(obj);
    }

    public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
            if (otherRealm.threadId != realm.threadId) {
                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
            }
            if (otherRealm.getPath().equals(realm.getPath())) {
                return object;
            }
        }
        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (some.test.AllTypes) cachedRealmObject;
        }

        some.test.AllTypes realmObject = null;
        boolean canUpdate = update;
        if (canUpdate) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (value == null) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, value);
            }
            if (rowIndex == Table.NO_MATCH) {
                canUpdate = false;
            } else {
                try {
                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                    realmObject = new io.realm.AllTypesRealmProxy();
                    cache.put(object, (RealmObjectProxy) realmObject);
                } finally {
                    objectContext.clear();
                }
            }
        }

        return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache);
    }

    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (some.test.AllTypes) cachedRealmObject;
        }

        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
        some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
        cache.put(newObject, (RealmObjectProxy) realmObject);

        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
        AllTypesRealmProxyInterface realmObjectCopy = (AllTypesRealmProxyInterface) realmObject;

        realmObjectCopy.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
        realmObjectCopy.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
        realmObjectCopy.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
        realmObjectCopy.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
        realmObjectCopy.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
        realmObjectCopy.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());

        realmObjectCopy.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());

        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
        if (columnObjectObj == null) {
            realmObjectCopy.realmSet$columnObject(null);
        } else {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObjectCopy.realmSet$columnObject(cachecolumnObject);
            } else {
                realmObjectCopy.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
            }
        }

        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
        if (columnRealmListList != null) {
            RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectCopy.realmGet$columnRealmList();
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, update, cache));
                }
            }
        }

        return realmObject;
    }

    public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
        }
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
        long rowIndex = Table.NO_MATCH;
        if (primaryKeyValue == null) {
            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
        } else {
            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
        }
        if (rowIndex == Table.NO_MATCH) {
            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
        } else {
            Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
        }
        cache.put(object, rowIndex);
        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
        if (realmGet$columnDate != null) {
            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
        }
        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
        if (realmGet$columnBinary != null) {
            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
        }
        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
        if (realmGet$columnMutableRealmInteger != null) {
            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
        }

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
        if (columnObjectObj != null) {
            Long cachecolumnObject = cache.get(columnObjectObj);
            if (cachecolumnObject == null) {
                cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
            }
            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
        }

        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                if (cacheItemIndexcolumnRealmList == null) {
                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                }
                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
            }
        }
        return rowIndex;
    }

    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        some.test.AllTypes object = null;
        while (objects.hasNext()) {
            object = (some.test.AllTypes) objects.next();
            if (cache.containsKey(object)) {
                continue;
            }
            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
                continue;
            }
            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (primaryKeyValue == null) {
                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
            } else {
                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
            }
            if (rowIndex == Table.NO_MATCH) {
                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
            } else {
                Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
            }
            cache.put(object, rowIndex);
            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
            if (realmGet$columnDate != null) {
                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
            }
            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
            if (realmGet$columnBinary != null) {
                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
            }
            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
            if (realmGet$columnMutableRealmInteger != null) {
                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
            }

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
            if (columnObjectObj != null) {
                Long cachecolumnObject = cache.get(columnObjectObj);
                if (cachecolumnObject == null) {
                    cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
                }
                table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
            }

            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                    if (cacheItemIndexcolumnRealmList == null) {
                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                    }
                    LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                }
            }
        }
    }

    public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
        }
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
        long rowIndex = Table.NO_MATCH;
        if (primaryKeyValue == null) {
            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
        } else {
            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
        }
        if (rowIndex == Table.NO_MATCH) {
            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
        }
        cache.put(object, rowIndex);
        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
        if (realmGet$columnDate != null) {
            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
        }
        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
        if (realmGet$columnBinary != null) {
            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
        }
        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
        if (realmGet$columnMutableRealmInteger != null) {
            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
        }

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
        if (columnObjectObj != null) {
            Long cachecolumnObject = cache.get(columnObjectObj);
            if (cachecolumnObject == null) {
                cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
            }
            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
        } else {
            Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
        }

        long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
        LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                if (cacheItemIndexcolumnRealmList == null) {
                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                }
                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
            }
        }

        return rowIndex;
    }

    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        some.test.AllTypes object = null;
        while (objects.hasNext()) {
            object = (some.test.AllTypes) objects.next();
            if (cache.containsKey(object)) {
                continue;
            }
            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
                continue;
            }
            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (primaryKeyValue == null) {
                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
            } else {
                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
            }
            if (rowIndex == Table.NO_MATCH) {
                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
            }
            cache.put(object, rowIndex);
            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
            if (realmGet$columnDate != null) {
                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
            }
            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
            if (realmGet$columnBinary != null) {
                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
            }
            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
            if (realmGet$columnMutableRealmInteger != null) {
                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
            }

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
            if (columnObjectObj != null) {
                Long cachecolumnObject = cache.get(columnObjectObj);
                if (cachecolumnObject == null) {
                    cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
                }
                Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
            } else {
                Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
            }

            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
            LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                    if (cacheItemIndexcolumnRealmList == null) {
                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                    }
                    LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                }
            }

        }
    }

    public static some.test.AllTypes createDetachedCopy(some.test.AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
        if (currentDepth > maxDepth || realmObject == null) {
            return null;
        }
        CacheData<RealmModel> cachedObject = cache.get(realmObject);
        some.test.AllTypes unmanagedObject;
        if (cachedObject == null) {
            unmanagedObject = new some.test.AllTypes();
            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
        } else {
            // Reuse cached object or recreate it because it was encountered at a lower depth.
            if (currentDepth >= cachedObject.minDepth) {
                return (some.test.AllTypes) cachedObject.object;
            }
            unmanagedObject = (some.test.AllTypes) cachedObject.object;
            cachedObject.minDepth = currentDepth;
        }
        AllTypesRealmProxyInterface unmanagedCopy = (AllTypesRealmProxyInterface) unmanagedObject;
        AllTypesRealmProxyInterface realmSource = (AllTypesRealmProxyInterface) realmObject;
        unmanagedCopy.realmSet$columnString(realmSource.realmGet$columnString());
        unmanagedCopy.realmSet$columnLong(realmSource.realmGet$columnLong());
        unmanagedCopy.realmSet$columnFloat(realmSource.realmGet$columnFloat());
        unmanagedCopy.realmSet$columnDouble(realmSource.realmGet$columnDouble());
        unmanagedCopy.realmSet$columnBoolean(realmSource.realmGet$columnBoolean());
        unmanagedCopy.realmSet$columnDate(realmSource.realmGet$columnDate());
        unmanagedCopy.realmSet$columnBinary(realmSource.realmGet$columnBinary());
        unmanagedCopy.realmGet$columnMutableRealmInteger().set(realmSource.realmGet$columnMutableRealmInteger().get());

        // Deep copy of columnObject
        unmanagedCopy.realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(realmSource.realmGet$columnObject(), currentDepth + 1, maxDepth, cache));

        // Deep copy of columnRealmList
        if (currentDepth == maxDepth) {
            unmanagedCopy.realmSet$columnRealmList(null);
        } else {
            RealmList<some.test.AllTypes> managedcolumnRealmListList = realmSource.realmGet$columnRealmList();
            RealmList<some.test.AllTypes> unmanagedcolumnRealmListList = new RealmList<some.test.AllTypes>();
            unmanagedCopy.realmSet$columnRealmList(unmanagedcolumnRealmListList);
            int nextDepth = currentDepth + 1;
            int size = managedcolumnRealmListList.size();
            for (int i = 0; i < size; i++) {
                some.test.AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
                unmanagedcolumnRealmListList.add(item);
            }
        }
        return unmanagedObject;
    }

    static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
        AllTypesRealmProxyInterface realmObjectTarget = (AllTypesRealmProxyInterface) realmObject;
        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
        realmObjectTarget.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
        realmObjectTarget.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
        realmObjectTarget.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
        realmObjectTarget.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
        realmObjectTarget.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
        realmObjectTarget.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
        realmObjectTarget.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
        if (columnObjectObj == null) {
            realmObjectTarget.realmSet$columnObject(null);
        } else {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObjectTarget.realmSet$columnObject(cachecolumnObject);
            } else {
                realmObjectTarget.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
            }
        }
        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
        RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectTarget.realmGet$columnRealmList();
        columnRealmListRealmList.clear();
        if (columnRealmListList != null) {
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
                }
            }
        }
        return realmObject;
    }

    @Override
    @SuppressWarnings("ArrayToString")
    public String toString() {
        if (!RealmObject.isValid(this)) {
            return "Invalid object";
        }
        StringBuilder stringBuilder = new StringBuilder("AllTypes = proxy[");
        stringBuilder.append("{columnString:");
        stringBuilder.append(realmGet$columnString() != null ? realmGet$columnString() : "null");
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnLong:");
        stringBuilder.append(realmGet$columnLong());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnFloat:");
        stringBuilder.append(realmGet$columnFloat());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnDouble:");
        stringBuilder.append(realmGet$columnDouble());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnBoolean:");
        stringBuilder.append(realmGet$columnBoolean());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnDate:");
        stringBuilder.append(realmGet$columnDate());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnBinary:");
        stringBuilder.append(realmGet$columnBinary());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnMutableRealmInteger:");
        stringBuilder.append(realmGet$columnMutableRealmInteger().get());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnObject:");
        stringBuilder.append(realmGet$columnObject() != null ? "AllTypes" : "null");
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnRealmList:");
        stringBuilder.append("RealmList<AllTypes>[").append(realmGet$columnRealmList().size()).append("]");
        stringBuilder.append("}");
        stringBuilder.append("]");
        return stringBuilder.toString();
    }

    @Override
    public ProxyState<?> realmGet$proxyState() {
        return proxyState;
    }

    @Override
    public int hashCode() {
        String realmName = proxyState.getRealm$realm().getPath();
        String tableName = proxyState.getRow$realm().getTable().getName();
        long rowIndex = proxyState.getRow$realm().getIndex();

        int result = 17;
        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AllTypesRealmProxy aAllTypes = (AllTypesRealmProxy)o;

        String path = proxyState.getRealm$realm().getPath();
        String otherPath = aAllTypes.proxyState.getRealm$realm().getPath();
        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;

        String tableName = proxyState.getRow$realm().getTable().getName();
        String otherTableName = aAllTypes.proxyState.getRow$realm().getTable().getName();
        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;

        if (proxyState.getRow$realm().getIndex() != aAllTypes.proxyState.getRow$realm().getIndex()) return false;

        return true;
    }
}
!@#$%
20190526_211215,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11336
package io.realm;


import android.annotation.TargetApi;
import android.os.Build;
import android.util.JsonReader;
import android.util.JsonToken;
import io.realm.exceptions.RealmMigrationNeededException;
import io.realm.internal.ColumnInfo;
import io.realm.internal.LinkView;
import io.realm.internal.OsObject;
import io.realm.internal.OsObjectSchemaInfo;
import io.realm.internal.Property;
import io.realm.internal.ProxyUtils;
import io.realm.internal.RealmObjectProxy;
import io.realm.internal.Row;
import io.realm.internal.SharedRealm;
import io.realm.internal.Table;
import io.realm.internal.UncheckedRow;
import io.realm.internal.android.JsonUtils;
import io.realm.log.RealmLog;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

@SuppressWarnings("all")
public class AllTypesRealmProxy extends some.test.AllTypes
    implements RealmObjectProxy, AllTypesRealmProxyInterface {

    static final class AllTypesColumnInfo extends ColumnInfo {
        long columnStringIndex;
        long columnLongIndex;
        long columnFloatIndex;
        long columnDoubleIndex;
        long columnBooleanIndex;
        long columnDateIndex;
        long columnBinaryIndex;
        long columnMutableRealmIntegerIndex;
        long columnObjectIndex;
        long columnRealmListIndex;

        AllTypesColumnInfo(SharedRealm realm, Table table) {
            super(10);
            this.columnStringIndex = addColumnDetails(table, "columnString", RealmFieldType.STRING);
            this.columnLongIndex = addColumnDetails(table, "columnLong", RealmFieldType.INTEGER);
            this.columnFloatIndex = addColumnDetails(table, "columnFloat", RealmFieldType.FLOAT);
            this.columnDoubleIndex = addColumnDetails(table, "columnDouble", RealmFieldType.DOUBLE);
            this.columnBooleanIndex = addColumnDetails(table, "columnBoolean", RealmFieldType.BOOLEAN);
            this.columnDateIndex = addColumnDetails(table, "columnDate", RealmFieldType.DATE);
            this.columnBinaryIndex = addColumnDetails(table, "columnBinary", RealmFieldType.BINARY);
            this.columnMutableRealmIntegerIndex = addColumnDetails(table, "columnMutableRealmInteger", RealmFieldType.INTEGER);
            this.columnObjectIndex = addColumnDetails(table, "columnObject", RealmFieldType.OBJECT);
            this.columnRealmListIndex = addColumnDetails(table, "columnRealmList", RealmFieldType.LIST);
            addBacklinkDetails(realm, "parentObjects", "AllTypes", "columnObject");
        }

        AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
            super(src, mutable);
            copy(src, this);
        }

        @Override
        protected final ColumnInfo copy(boolean mutable) {
            return new AllTypesColumnInfo(this, mutable);
        }

        @Override
        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
            final AllTypesColumnInfo src = (AllTypesColumnInfo) rawSrc;
            final AllTypesColumnInfo dst = (AllTypesColumnInfo) rawDst;
            dst.columnStringIndex = src.columnStringIndex;
            dst.columnLongIndex = src.columnLongIndex;
            dst.columnFloatIndex = src.columnFloatIndex;
            dst.columnDoubleIndex = src.columnDoubleIndex;
            dst.columnBooleanIndex = src.columnBooleanIndex;
            dst.columnDateIndex = src.columnDateIndex;
            dst.columnBinaryIndex = src.columnBinaryIndex;
            dst.columnMutableRealmIntegerIndex = src.columnMutableRealmIntegerIndex;
            dst.columnObjectIndex = src.columnObjectIndex;
            dst.columnRealmListIndex = src.columnRealmListIndex;
        }
    }

    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
    private static final List<String> FIELD_NAMES;
    static {
        List<String> fieldNames = new ArrayList<String>();
        fieldNames.add("columnString");
        fieldNames.add("columnLong");
        fieldNames.add("columnFloat");
        fieldNames.add("columnDouble");
        fieldNames.add("columnBoolean");
        fieldNames.add("columnDate");
        fieldNames.add("columnBinary");
        fieldNames.add("columnMutableRealmInteger");
        fieldNames.add("columnObject");
        fieldNames.add("columnRealmList");
        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
    }

    private AllTypesColumnInfo columnInfo;
    private ProxyState<some.test.AllTypes> proxyState;
    private final MutableRealmInteger.Managed columnMutableRealmIntegerMutableRealmInteger = new MutableRealmInteger.Managed<some.test.AllTypes>() {
                @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
                @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
            };
    private RealmList<some.test.AllTypes> columnRealmListRealmList;
    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;

    AllTypesRealmProxy() {
        proxyState.setConstructionFinished();
    }

    @Override
    public void realm$injectObjectContext() {
        if (this.proxyState != null) {
            return;
        }
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.AllTypes>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }

    @Override
    @SuppressWarnings("cast")
    public String realmGet$columnString() {
        proxyState.getRealm$realm().checkIfValid();
        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
    }

    @Override
    public void realmSet$columnString(String value) {
        if (proxyState.isUnderConstruction()) {
            // default value of the primary key is always ignored.
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        throw new io.realm.exceptions.RealmException("Primary key field 'columnString' cannot be changed after object was created.");
    }

    @Override
    @SuppressWarnings("cast")
    public long realmGet$columnLong() {
        proxyState.getRealm$realm().checkIfValid();
        return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
    }

    @Override
    public void realmSet$columnLong(long value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setLong(columnInfo.columnLongIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public float realmGet$columnFloat() {
        proxyState.getRealm$realm().checkIfValid();
        return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
    }

    @Override
    public void realmSet$columnFloat(float value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setFloat(columnInfo.columnFloatIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public double realmGet$columnDouble() {
        proxyState.getRealm$realm().checkIfValid();
        return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
    }

    @Override
    public void realmSet$columnDouble(double value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setDouble(columnInfo.columnDoubleIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public boolean realmGet$columnBoolean() {
        proxyState.getRealm$realm().checkIfValid();
        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
    }

    @Override
    public void realmSet$columnBoolean(boolean value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setBoolean(columnInfo.columnBooleanIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public Date realmGet$columnDate() {
        proxyState.getRealm$realm().checkIfValid();
        return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
    }

    @Override
    public void realmSet$columnDate(Date value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
            }
            row.getTable().setDate(columnInfo.columnDateIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
        }
        proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public byte[] realmGet$columnBinary() {
        proxyState.getRealm$realm().checkIfValid();
        return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
    }

    @Override
    public void realmSet$columnBinary(byte[] value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
            }
            row.getTable().setBinaryByteArray(columnInfo.columnBinaryIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
        }
        proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
    }

    @Override
    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
        proxyState.getRealm$realm().checkIfValid();
        return this.columnMutableRealmIntegerMutableRealmInteger;
    }

    @Override
    public some.test.AllTypes realmGet$columnObject() {
        proxyState.getRealm$realm().checkIfValid();
        if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
            return null;
        }
        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex), false, Collections.<String>emptyList());
    }

    @Override
    public void realmSet$columnObject(some.test.AllTypes value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            if (proxyState.getExcludeFields$realm().contains("columnObject")) {
                return;
            }
            if (value != null && !RealmObject.isManaged(value)) {
                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                // Table#nullifyLink() does not support default value. Just using Row.
                row.nullifyLink(columnInfo.columnObjectIndex);
                return;
            }
            if (!RealmObject.isValid(value)) {
                throw new IllegalArgumentException("'value' is not a valid managed object.");
            }
            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                throw new IllegalArgumentException("'value' belongs to a different Realm.");
            }
            row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
            return;
        }
        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
            throw new IllegalArgumentException("'value' is not a valid managed object.");
        }
        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
            throw new IllegalArgumentException("'value' belongs to a different Realm.");
        }
        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
    }

    @Override
    public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
        proxyState.getRealm$realm().checkIfValid();
        // use the cached value if available
        if (columnRealmListRealmList != null) {
            return columnRealmListRealmList;
        } else {
            LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, linkView, proxyState.getRealm$realm());
            return columnRealmListRealmList;
        }
    }

    @Override
    public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
                return;
            }
            if (value != null && !value.isManaged()) {
                final Realm realm = (Realm) proxyState.getRealm$realm();
                final RealmList<some.test.AllTypes> original = value;
                value = new RealmList<some.test.AllTypes>();
                for (some.test.AllTypes item : original) {
                    if (item == null || RealmObject.isManaged(item)) {
                        value.add(item);
                    } else {
                        value.add(realm.copyToRealm(item));
                    }
                }
            }
        }

        proxyState.getRealm$realm().checkIfValid();
        LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
        links.clear();
        if (value == null) {
            return;
        }
        for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
                throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
            }
            if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
            }
            links.add(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
        }
    }

    @Override
    public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
        BaseRealm realm = proxyState.getRealm$realm();
        realm.checkIfValid();
        proxyState.getRow$realm().checkIfAttached();
        if (parentObjectsBacklinks == null) {
            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
        }
        return parentObjectsBacklinks;
    }

    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes");
        builder.addProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
        builder.addProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
        builder.addLinkedProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
        builder.addLinkedProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
        return builder.build();
    }

    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
        return expectedObjectSchemaInfo;
    }

    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
        }
        Table table = sharedRealm.getTable("class_AllTypes");
        final long columnCount = table.getColumnCount();
        if (columnCount != 10) {
            if (columnCount < 10) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 10 but was " + columnCount);
            }
            if (allowExtraColumns) {
                RealmLog.debug("Field count is more than expected - expected 10 but was %1$d", columnCount);
            } else {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 10 but was " + columnCount);
            }
        }
        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
        for (long i = 0; i < columnCount; i++) {
            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
        }

        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm, table);

        if (!table.hasPrimaryKey()) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
        } else {
            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
            }
        }

        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnString", RealmFieldType.STRING, "String");
        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
        }
        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnLong", RealmFieldType.INTEGER, "long");
        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnFloat", RealmFieldType.FLOAT, "float");
        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDouble", RealmFieldType.DOUBLE, "double");
        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBoolean", RealmFieldType.BOOLEAN, "boolean");
        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDate", RealmFieldType.DATE, "Date");
        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBinary", RealmFieldType.BINARY, "byte[]");
        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnMutableRealmInteger", RealmFieldType.INTEGER, "MutableRealmInteger");
        if (!table.isColumnNullable(columnInfo.columnMutableRealmIntegerIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnMutableRealmInteger' is required. Either set @Required to field 'columnMutableRealmInteger' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
        }
        Table table_8 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_8)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_8.getName() + "'");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
        }
        Table table_9 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_9)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_9.getName() + "'");
        }

        long backlinkFieldIndex;
        Table backlinkSourceTable;
        Table backlinkTargetTable;
        RealmFieldType backlinkFieldType;
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
        if (backlinkFieldIndex == Table.NO_MATCH) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
        }
        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
        if (!table.hasSameSchema(backlinkTargetTable)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
        }

        return columnInfo;
    }

    public static String getTableName() {
        return "class_AllTypes";
    }

    public static List<String> getFieldNames() {
        return FIELD_NAMES;
    }

    @SuppressWarnings("cast")
    public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
        throws JSONException {
        final List<String> excludeFields = new ArrayList<String>(2);
        some.test.AllTypes obj = null;
        if (update) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            long rowIndex = Table.NO_MATCH;
            if (json.isNull("columnString")) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
            }
            if (rowIndex != Table.NO_MATCH) {
                final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
                try {
                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                    obj = new io.realm.AllTypesRealmProxy();
                } finally {
                    objectContext.clear();
                }
            }
        }
        if (obj == null) {
            if (json.has("columnObject")) {
                excludeFields.add("columnObject");
            }
            if (json.has("columnRealmList")) {
                excludeFields.add("columnRealmList");
            }
            if (json.has("columnString")) {
                if (json.isNull("columnString")) {
                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
                } else {
                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, json.getString("columnString"), true, excludeFields);
                }
            } else {
                throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
            }
        }

        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
        if (json.has("columnLong")) {
            if (json.isNull("columnLong")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
            } else {
                objProxy.realmSet$columnLong((long) json.getLong("columnLong"));
            }
        }
        if (json.has("columnFloat")) {
            if (json.isNull("columnFloat")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
            } else {
                objProxy.realmSet$columnFloat((float) json.getDouble("columnFloat"));
            }
        }
        if (json.has("columnDouble")) {
            if (json.isNull("columnDouble")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
            } else {
                objProxy.realmSet$columnDouble((double) json.getDouble("columnDouble"));
            }
        }
        if (json.has("columnBoolean")) {
            if (json.isNull("columnBoolean")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
            } else {
                objProxy.realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
            }
        }
        if (json.has("columnDate")) {
            if (json.isNull("columnDate")) {
                objProxy.realmSet$columnDate(null);
            } else {
                Object timestamp = json.get("columnDate");
                if (timestamp instanceof String) {
                    objProxy.realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
                } else {
                    objProxy.realmSet$columnDate(new Date(json.getLong("columnDate")));
                }
            }
        }
        if (json.has("columnBinary")) {
            if (json.isNull("columnBinary")) {
                objProxy.realmSet$columnBinary(null);
            } else {
                objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
            }
        }
        if (json.has("columnMutableRealmInteger")) {
            objProxy.realmGet$columnMutableRealmInteger().set((json.isNull("columnMutableRealmInteger")) ? null : json.getLong("columnMutableRealmInteger"));
        }
        if (json.has("columnObject")) {
            if (json.isNull("columnObject")) {
                objProxy.realmSet$columnObject(null);
            } else {
                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
                objProxy.realmSet$columnObject(columnObjectObj);
            }
        }
        if (json.has("columnRealmList")) {
            if (json.isNull("columnRealmList")) {
                objProxy.realmSet$columnRealmList(null);
            } else {
                objProxy.realmGet$columnRealmList().clear();
                JSONArray array = json.getJSONArray("columnRealmList");
                for (int i = 0; i < array.length(); i++) {
                    some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
                    objProxy.realmGet$columnRealmList().add(item);
                }
            }
        }
        return obj;
    }

    @SuppressWarnings("cast")
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
        throws IOException {
        boolean jsonHasPrimaryKey = false;
        final some.test.AllTypes obj = new some.test.AllTypes();
        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
        reader.beginObject();
        while (reader.hasNext()) {
            String name = reader.nextName();
            if (false) {
            } else if (name.equals("columnString")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnString((String) reader.nextString());
                } else {
                    reader.skipValue();
                    objProxy.realmSet$columnString(null);
                }
                jsonHasPrimaryKey = true;
            } else if (name.equals("columnLong")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnLong((long) reader.nextLong());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
                }
            } else if (name.equals("columnFloat")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnFloat((float) reader.nextDouble());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
                }
            } else if (name.equals("columnDouble")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnDouble((double) reader.nextDouble());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
                }
            } else if (name.equals("columnBoolean")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnBoolean((boolean) reader.nextBoolean());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
                }
            } else if (name.equals("columnDate")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnDate(null);
                } else if (reader.peek() == JsonToken.NUMBER) {
                    long timestamp = reader.nextLong();
                    if (timestamp > -1) {
                        objProxy.realmSet$columnDate(new Date(timestamp));
                    }
                } else {
                    objProxy.realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
                }
            } else if (name.equals("columnBinary")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
                } else {
                    reader.skipValue();
                    objProxy.realmSet$columnBinary(null);
                }
            } else if (name.equals("columnMutableRealmInteger")) {
                Long val = null;
                if (reader.peek() != JsonToken.NULL) {
                    val = reader.nextLong()
                } else {
                    reader.skipValue();
                }
                objProxy.realmGet$columnMutableRealmInteger().set(val);
            } else if (name.equals("columnObject")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnObject(null);
                } else {
                    some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                    objProxy.realmSet$columnObject(columnObjectObj);
                }
            } else if (name.equals("columnRealmList")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnRealmList(null);
                } else {
                    objProxy.realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                    reader.beginArray();
                    while (reader.hasNext()) {
                        some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                        objProxy.realmGet$columnRealmList().add(item);
                    }
                    reader.endArray();
                }
            } else {
                reader.skipValue();
            }
        }
        reader.endObject();
        if (!jsonHasPrimaryKey) {
            throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
        }
        return realm.copyToRealm(obj);
    }

    public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
            if (otherRealm.threadId != realm.threadId) {
                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
            }
            if (otherRealm.getPath().equals(realm.getPath())) {
                return object;
            }
        }
        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (some.test.AllTypes) cachedRealmObject;
        }

        some.test.AllTypes realmObject = null;
        boolean canUpdate = update;
        if (canUpdate) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (value == null) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, value);
            }
            if (rowIndex == Table.NO_MATCH) {
                canUpdate = false;
            } else {
                try {
                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                    realmObject = new io.realm.AllTypesRealmProxy();
                    cache.put(object, (RealmObjectProxy) realmObject);
                } finally {
                    objectContext.clear();
                }
            }
        }

        return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache);
    }

    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (some.test.AllTypes) cachedRealmObject;
        }

        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
        some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
        cache.put(newObject, (RealmObjectProxy) realmObject);

        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
        AllTypesRealmProxyInterface realmObjectCopy = (AllTypesRealmProxyInterface) realmObject;

        realmObjectCopy.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
        realmObjectCopy.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
        realmObjectCopy.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
        realmObjectCopy.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
        realmObjectCopy.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
        realmObjectCopy.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());

        realmObjectCopy.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());

        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
        if (columnObjectObj == null) {
            realmObjectCopy.realmSet$columnObject(null);
        } else {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObjectCopy.realmSet$columnObject(cachecolumnObject);
            } else {
                realmObjectCopy.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
            }
        }

        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
        if (columnRealmListList != null) {
            RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectCopy.realmGet$columnRealmList();
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, update, cache));
                }
            }
        }

        return realmObject;
    }

    public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
        }
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
        long rowIndex = Table.NO_MATCH;
        if (primaryKeyValue == null) {
            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
        } else {
            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
        }
        if (rowIndex == Table.NO_MATCH) {
            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
        } else {
            Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
        }
        cache.put(object, rowIndex);
        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
        if (realmGet$columnDate != null) {
            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
        }
        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
        if (realmGet$columnBinary != null) {
            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
        }
        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
        if (realmGet$columnMutableRealmInteger != null) {
            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
        }

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
        if (columnObjectObj != null) {
            Long cachecolumnObject = cache.get(columnObjectObj);
            if (cachecolumnObject == null) {
                cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
            }
            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
        }

        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                if (cacheItemIndexcolumnRealmList == null) {
                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                }
                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
            }
        }
        return rowIndex;
    }

    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        some.test.AllTypes object = null;
        while (objects.hasNext()) {
            object = (some.test.AllTypes) objects.next();
            if (cache.containsKey(object)) {
                continue;
            }
            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
                continue;
            }
            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (primaryKeyValue == null) {
                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
            } else {
                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
            }
            if (rowIndex == Table.NO_MATCH) {
                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
            } else {
                Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
            }
            cache.put(object, rowIndex);
            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
            if (realmGet$columnDate != null) {
                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
            }
            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
            if (realmGet$columnBinary != null) {
                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
            }
            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
            if (realmGet$columnMutableRealmInteger != null) {
                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
            }

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
            if (columnObjectObj != null) {
                Long cachecolumnObject = cache.get(columnObjectObj);
                if (cachecolumnObject == null) {
                    cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
                }
                table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
            }

            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                    if (cacheItemIndexcolumnRealmList == null) {
                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                    }
                    LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                }
            }
        }
    }

    public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
        }
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
        long rowIndex = Table.NO_MATCH;
        if (primaryKeyValue == null) {
            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
        } else {
            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
        }
        if (rowIndex == Table.NO_MATCH) {
            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
        }
        cache.put(object, rowIndex);
        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
        if (realmGet$columnDate != null) {
            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
        }
        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
        if (realmGet$columnBinary != null) {
            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
        }
        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
        if (realmGet$columnMutableRealmInteger != null) {
            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
        }

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
        if (columnObjectObj != null) {
            Long cachecolumnObject = cache.get(columnObjectObj);
            if (cachecolumnObject == null) {
                cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
            }
            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
        } else {
            Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
        }

        long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
        LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                if (cacheItemIndexcolumnRealmList == null) {
                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                }
                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
            }
        }

        return rowIndex;
    }

    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        some.test.AllTypes object = null;
        while (objects.hasNext()) {
            object = (some.test.AllTypes) objects.next();
            if (cache.containsKey(object)) {
                continue;
            }
            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
                continue;
            }
            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (primaryKeyValue == null) {
                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
            } else {
                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
            }
            if (rowIndex == Table.NO_MATCH) {
                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
            }
            cache.put(object, rowIndex);
            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
            if (realmGet$columnDate != null) {
                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
            }
            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
            if (realmGet$columnBinary != null) {
                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
            }
            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
            if (realmGet$columnMutableRealmInteger != null) {
                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
            }

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
            if (columnObjectObj != null) {
                Long cachecolumnObject = cache.get(columnObjectObj);
                if (cachecolumnObject == null) {
                    cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
                }
                Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
            } else {
                Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
            }

            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
            LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                    if (cacheItemIndexcolumnRealmList == null) {
                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                    }
                    LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                }
            }

        }
    }

    public static some.test.AllTypes createDetachedCopy(some.test.AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
        if (currentDepth > maxDepth || realmObject == null) {
            return null;
        }
        CacheData<RealmModel> cachedObject = cache.get(realmObject);
        some.test.AllTypes unmanagedObject;
        if (cachedObject == null) {
            unmanagedObject = new some.test.AllTypes();
            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
        } else {
            // Reuse cached object or recreate it because it was encountered at a lower depth.
            if (currentDepth >= cachedObject.minDepth) {
                return (some.test.AllTypes) cachedObject.object;
            }
            unmanagedObject = (some.test.AllTypes) cachedObject.object;
            cachedObject.minDepth = currentDepth;
        }
        AllTypesRealmProxyInterface unmanagedCopy = (AllTypesRealmProxyInterface) unmanagedObject;
        AllTypesRealmProxyInterface realmSource = (AllTypesRealmProxyInterface) realmObject;
        unmanagedCopy.realmSet$columnString(realmSource.realmGet$columnString());
        unmanagedCopy.realmSet$columnLong(realmSource.realmGet$columnLong());
        unmanagedCopy.realmSet$columnFloat(realmSource.realmGet$columnFloat());
        unmanagedCopy.realmSet$columnDouble(realmSource.realmGet$columnDouble());
        unmanagedCopy.realmSet$columnBoolean(realmSource.realmGet$columnBoolean());
        unmanagedCopy.realmSet$columnDate(realmSource.realmGet$columnDate());
        unmanagedCopy.realmSet$columnBinary(realmSource.realmGet$columnBinary());
        unmanagedCopy.realmGet$columnMutableRealmInteger().set(realmSource.realmGet$columnMutableRealmInteger().get());

        // Deep copy of columnObject
        unmanagedCopy.realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(realmSource.realmGet$columnObject(), currentDepth + 1, maxDepth, cache));

        // Deep copy of columnRealmList
        if (currentDepth == maxDepth) {
            unmanagedCopy.realmSet$columnRealmList(null);
        } else {
            RealmList<some.test.AllTypes> managedcolumnRealmListList = realmSource.realmGet$columnRealmList();
            RealmList<some.test.AllTypes> unmanagedcolumnRealmListList = new RealmList<some.test.AllTypes>();
            unmanagedCopy.realmSet$columnRealmList(unmanagedcolumnRealmListList);
            int nextDepth = currentDepth + 1;
            int size = managedcolumnRealmListList.size();
            for (int i = 0; i < size; i++) {
                some.test.AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
                unmanagedcolumnRealmListList.add(item);
            }
        }
        return unmanagedObject;
    }

    static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
        AllTypesRealmProxyInterface realmObjectTarget = (AllTypesRealmProxyInterface) realmObject;
        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
        realmObjectTarget.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
        realmObjectTarget.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
        realmObjectTarget.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
        realmObjectTarget.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
        realmObjectTarget.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
        realmObjectTarget.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
        realmObjectTarget.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
        if (columnObjectObj == null) {
            realmObjectTarget.realmSet$columnObject(null);
        } else {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObjectTarget.realmSet$columnObject(cachecolumnObject);
            } else {
                realmObjectTarget.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
            }
        }
        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
        RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectTarget.realmGet$columnRealmList();
        columnRealmListRealmList.clear();
        if (columnRealmListList != null) {
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
                }
            }
        }
        return realmObject;
    }

    @Override
    @SuppressWarnings("ArrayToString")
    public String toString() {
        if (!RealmObject.isValid(this)) {
            return "Invalid object";
        }
        StringBuilder stringBuilder = new StringBuilder("AllTypes = proxy[");
        stringBuilder.append("{columnString:");
        stringBuilder.append(realmGet$columnString() != null ? realmGet$columnString() : "null");
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnLong:");
        stringBuilder.append(realmGet$columnLong());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnFloat:");
        stringBuilder.append(realmGet$columnFloat());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnDouble:");
        stringBuilder.append(realmGet$columnDouble());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnBoolean:");
        stringBuilder.append(realmGet$columnBoolean());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnDate:");
        stringBuilder.append(realmGet$columnDate());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnBinary:");
        stringBuilder.append(realmGet$columnBinary());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnMutableRealmInteger:");
        stringBuilder.append(realmGet$columnMutableRealmInteger().get());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnObject:");
        stringBuilder.append(realmGet$columnObject() != null ? "AllTypes" : "null");
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnRealmList:");
        stringBuilder.append("RealmList<AllTypes>[").append(realmGet$columnRealmList().size()).append("]");
        stringBuilder.append("}");
        stringBuilder.append("]");
        return stringBuilder.toString();
    }

    @Override
    public ProxyState<?> realmGet$proxyState() {
        return proxyState;
    }

    @Override
    public int hashCode() {
        String realmName = proxyState.getRealm$realm().getPath();
        String tableName = proxyState.getRow$realm().getTable().getName();
        long rowIndex = proxyState.getRow$realm().getIndex();

        int result = 17;
        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AllTypesRealmProxy aAllTypes = (AllTypesRealmProxy)o;

        String path = proxyState.getRealm$realm().getPath();
        String otherPath = aAllTypes.proxyState.getRealm$realm().getPath();
        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;

        String tableName = proxyState.getRow$realm().getTable().getName();
        String otherTableName = aAllTypes.proxyState.getRow$realm().getTable().getName();
        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;

        if (proxyState.getRow$realm().getIndex() != aAllTypes.proxyState.getRow$realm().getIndex()) return false;

        return true;
    }
}
!@#$%
20190526_211215,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11336
package io.realm;


import android.annotation.TargetApi;
import android.os.Build;
import android.util.JsonReader;
import android.util.JsonToken;
import io.realm.exceptions.RealmMigrationNeededException;
import io.realm.internal.ColumnInfo;
import io.realm.internal.LinkView;
import io.realm.internal.OsObject;
import io.realm.internal.OsObjectSchemaInfo;
import io.realm.internal.Property;
import io.realm.internal.ProxyUtils;
import io.realm.internal.RealmObjectProxy;
import io.realm.internal.Row;
import io.realm.internal.SharedRealm;
import io.realm.internal.Table;
import io.realm.internal.UncheckedRow;
import io.realm.internal.android.JsonUtils;
import io.realm.log.RealmLog;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

@SuppressWarnings("all")
public class AllTypesRealmProxy extends some.test.AllTypes
    implements RealmObjectProxy, AllTypesRealmProxyInterface {

    static final class AllTypesColumnInfo extends ColumnInfo {
        long columnStringIndex;
        long columnLongIndex;
        long columnFloatIndex;
        long columnDoubleIndex;
        long columnBooleanIndex;
        long columnDateIndex;
        long columnBinaryIndex;
        long columnMutableRealmIntegerIndex;
        long columnObjectIndex;
        long columnRealmListIndex;

        AllTypesColumnInfo(SharedRealm realm, Table table) {
            super(10);
            this.columnStringIndex = addColumnDetails(table, "columnString", RealmFieldType.STRING);
            this.columnLongIndex = addColumnDetails(table, "columnLong", RealmFieldType.INTEGER);
            this.columnFloatIndex = addColumnDetails(table, "columnFloat", RealmFieldType.FLOAT);
            this.columnDoubleIndex = addColumnDetails(table, "columnDouble", RealmFieldType.DOUBLE);
            this.columnBooleanIndex = addColumnDetails(table, "columnBoolean", RealmFieldType.BOOLEAN);
            this.columnDateIndex = addColumnDetails(table, "columnDate", RealmFieldType.DATE);
            this.columnBinaryIndex = addColumnDetails(table, "columnBinary", RealmFieldType.BINARY);
            this.columnMutableRealmIntegerIndex = addColumnDetails(table, "columnMutableRealmInteger", RealmFieldType.INTEGER);
            this.columnObjectIndex = addColumnDetails(table, "columnObject", RealmFieldType.OBJECT);
            this.columnRealmListIndex = addColumnDetails(table, "columnRealmList", RealmFieldType.LIST);
            addBacklinkDetails(realm, "parentObjects", "AllTypes", "columnObject");
        }

        AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
            super(src, mutable);
            copy(src, this);
        }

        @Override
        protected final ColumnInfo copy(boolean mutable) {
            return new AllTypesColumnInfo(this, mutable);
        }

        @Override
        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
            final AllTypesColumnInfo src = (AllTypesColumnInfo) rawSrc;
            final AllTypesColumnInfo dst = (AllTypesColumnInfo) rawDst;
            dst.columnStringIndex = src.columnStringIndex;
            dst.columnLongIndex = src.columnLongIndex;
            dst.columnFloatIndex = src.columnFloatIndex;
            dst.columnDoubleIndex = src.columnDoubleIndex;
            dst.columnBooleanIndex = src.columnBooleanIndex;
            dst.columnDateIndex = src.columnDateIndex;
            dst.columnBinaryIndex = src.columnBinaryIndex;
            dst.columnMutableRealmIntegerIndex = src.columnMutableRealmIntegerIndex;
            dst.columnObjectIndex = src.columnObjectIndex;
            dst.columnRealmListIndex = src.columnRealmListIndex;
        }
    }

    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
    private static final List<String> FIELD_NAMES;
    static {
        List<String> fieldNames = new ArrayList<String>();
        fieldNames.add("columnString");
        fieldNames.add("columnLong");
        fieldNames.add("columnFloat");
        fieldNames.add("columnDouble");
        fieldNames.add("columnBoolean");
        fieldNames.add("columnDate");
        fieldNames.add("columnBinary");
        fieldNames.add("columnMutableRealmInteger");
        fieldNames.add("columnObject");
        fieldNames.add("columnRealmList");
        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
    }

    private AllTypesColumnInfo columnInfo;
    private ProxyState<some.test.AllTypes> proxyState;
    private final MutableRealmInteger.Managed columnMutableRealmIntegerMutableRealmInteger = new MutableRealmInteger.Managed<some.test.AllTypes>() {
                @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
                @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
            };
    private RealmList<some.test.AllTypes> columnRealmListRealmList;
    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;

    AllTypesRealmProxy() {
        proxyState.setConstructionFinished();
    }

    @Override
    public void realm$injectObjectContext() {
        if (this.proxyState != null) {
            return;
        }
        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
        this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
        this.proxyState = new ProxyState<some.test.AllTypes>(this);
        proxyState.setRealm$realm(context.getRealm());
        proxyState.setRow$realm(context.getRow());
        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
        proxyState.setExcludeFields$realm(context.getExcludeFields());
    }

    @Override
    @SuppressWarnings("cast")
    public String realmGet$columnString() {
        proxyState.getRealm$realm().checkIfValid();
        return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
    }

    @Override
    public void realmSet$columnString(String value) {
        if (proxyState.isUnderConstruction()) {
            // default value of the primary key is always ignored.
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        throw new io.realm.exceptions.RealmException("Primary key field 'columnString' cannot be changed after object was created.");
    }

    @Override
    @SuppressWarnings("cast")
    public long realmGet$columnLong() {
        proxyState.getRealm$realm().checkIfValid();
        return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
    }

    @Override
    public void realmSet$columnLong(long value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setLong(columnInfo.columnLongIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public float realmGet$columnFloat() {
        proxyState.getRealm$realm().checkIfValid();
        return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
    }

    @Override
    public void realmSet$columnFloat(float value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setFloat(columnInfo.columnFloatIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public double realmGet$columnDouble() {
        proxyState.getRealm$realm().checkIfValid();
        return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
    }

    @Override
    public void realmSet$columnDouble(double value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setDouble(columnInfo.columnDoubleIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public boolean realmGet$columnBoolean() {
        proxyState.getRealm$realm().checkIfValid();
        return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
    }

    @Override
    public void realmSet$columnBoolean(boolean value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            row.getTable().setBoolean(columnInfo.columnBooleanIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public Date realmGet$columnDate() {
        proxyState.getRealm$realm().checkIfValid();
        return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
    }

    @Override
    public void realmSet$columnDate(Date value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
            }
            row.getTable().setDate(columnInfo.columnDateIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
        }
        proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
    }

    @Override
    @SuppressWarnings("cast")
    public byte[] realmGet$columnBinary() {
        proxyState.getRealm$realm().checkIfValid();
        return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
    }

    @Override
    public void realmSet$columnBinary(byte[] value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
            }
            row.getTable().setBinaryByteArray(columnInfo.columnBinaryIndex, row.getIndex(), value, true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
        }
        proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
    }

    @Override
    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
        proxyState.getRealm$realm().checkIfValid();
        return this.columnMutableRealmIntegerMutableRealmInteger;
    }

    @Override
    public some.test.AllTypes realmGet$columnObject() {
        proxyState.getRealm$realm().checkIfValid();
        if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
            return null;
        }
        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex), false, Collections.<String>emptyList());
    }

    @Override
    public void realmSet$columnObject(some.test.AllTypes value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            if (proxyState.getExcludeFields$realm().contains("columnObject")) {
                return;
            }
            if (value != null && !RealmObject.isManaged(value)) {
                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
            }
            final Row row = proxyState.getRow$realm();
            if (value == null) {
                // Table#nullifyLink() does not support default value. Just using Row.
                row.nullifyLink(columnInfo.columnObjectIndex);
                return;
            }
            if (!RealmObject.isValid(value)) {
                throw new IllegalArgumentException("'value' is not a valid managed object.");
            }
            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                throw new IllegalArgumentException("'value' belongs to a different Realm.");
            }
            row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
            return;
        }

        proxyState.getRealm$realm().checkIfValid();
        if (value == null) {
            proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
            return;
        }
        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
            throw new IllegalArgumentException("'value' is not a valid managed object.");
        }
        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
            throw new IllegalArgumentException("'value' belongs to a different Realm.");
        }
        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
    }

    @Override
    public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
        proxyState.getRealm$realm().checkIfValid();
        // use the cached value if available
        if (columnRealmListRealmList != null) {
            return columnRealmListRealmList;
        } else {
            LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, linkView, proxyState.getRealm$realm());
            return columnRealmListRealmList;
        }
    }

    @Override
    public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
        if (proxyState.isUnderConstruction()) {
            if (!proxyState.getAcceptDefaultValue$realm()) {
                return;
            }
            if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
                return;
            }
            if (value != null && !value.isManaged()) {
                final Realm realm = (Realm) proxyState.getRealm$realm();
                final RealmList<some.test.AllTypes> original = value;
                value = new RealmList<some.test.AllTypes>();
                for (some.test.AllTypes item : original) {
                    if (item == null || RealmObject.isManaged(item)) {
                        value.add(item);
                    } else {
                        value.add(realm.copyToRealm(item));
                    }
                }
            }
        }

        proxyState.getRealm$realm().checkIfValid();
        LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
        links.clear();
        if (value == null) {
            return;
        }
        for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
                throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
            }
            if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
            }
            links.add(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
        }
    }

    @Override
    public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
        BaseRealm realm = proxyState.getRealm$realm();
        realm.checkIfValid();
        proxyState.getRow$realm().checkIfAttached();
        if (parentObjectsBacklinks == null) {
            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
        }
        return parentObjectsBacklinks;
    }

    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes");
        builder.addProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
        builder.addProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
        builder.addProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
        builder.addLinkedProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
        builder.addLinkedProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
        return builder.build();
    }

    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
        return expectedObjectSchemaInfo;
    }

    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
        }
        Table table = sharedRealm.getTable("class_AllTypes");
        final long columnCount = table.getColumnCount();
        if (columnCount != 10) {
            if (columnCount < 10) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 10 but was " + columnCount);
            }
            if (allowExtraColumns) {
                RealmLog.debug("Field count is more than expected - expected 10 but was %1$d", columnCount);
            } else {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 10 but was " + columnCount);
            }
        }
        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
        for (long i = 0; i < columnCount; i++) {
            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
        }

        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm, table);

        if (!table.hasPrimaryKey()) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
        } else {
            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
            }
        }

        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnString", RealmFieldType.STRING, "String");
        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
        }
        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnLong", RealmFieldType.INTEGER, "long");
        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnFloat", RealmFieldType.FLOAT, "float");
        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDouble", RealmFieldType.DOUBLE, "double");
        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBoolean", RealmFieldType.BOOLEAN, "boolean");
        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDate", RealmFieldType.DATE, "Date");
        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBinary", RealmFieldType.BINARY, "byte[]");
        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnMutableRealmInteger", RealmFieldType.INTEGER, "MutableRealmInteger");
        if (!table.isColumnNullable(columnInfo.columnMutableRealmIntegerIndex)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnMutableRealmInteger' is required. Either set @Required to field 'columnMutableRealmInteger' or migrate using RealmObjectSchema.setNullable().");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
        }
        Table table_8 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_8)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_8.getName() + "'");
        }
        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
        }
        Table table_9 = sharedRealm.getTable("class_AllTypes");
        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_9)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_9.getName() + "'");
        }

        long backlinkFieldIndex;
        Table backlinkSourceTable;
        Table backlinkTargetTable;
        RealmFieldType backlinkFieldType;
        if (!sharedRealm.hasTable("class_AllTypes")) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
        if (backlinkFieldIndex == Table.NO_MATCH) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
        }
        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
        }
        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
        if (!table.hasSameSchema(backlinkTargetTable)) {
            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
        }

        return columnInfo;
    }

    public static String getTableName() {
        return "class_AllTypes";
    }

    public static List<String> getFieldNames() {
        return FIELD_NAMES;
    }

    @SuppressWarnings("cast")
    public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
        throws JSONException {
        final List<String> excludeFields = new ArrayList<String>(2);
        some.test.AllTypes obj = null;
        if (update) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            long rowIndex = Table.NO_MATCH;
            if (json.isNull("columnString")) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
            }
            if (rowIndex != Table.NO_MATCH) {
                final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
                try {
                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                    obj = new io.realm.AllTypesRealmProxy();
                } finally {
                    objectContext.clear();
                }
            }
        }
        if (obj == null) {
            if (json.has("columnObject")) {
                excludeFields.add("columnObject");
            }
            if (json.has("columnRealmList")) {
                excludeFields.add("columnRealmList");
            }
            if (json.has("columnString")) {
                if (json.isNull("columnString")) {
                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
                } else {
                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, json.getString("columnString"), true, excludeFields);
                }
            } else {
                throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
            }
        }

        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
        if (json.has("columnLong")) {
            if (json.isNull("columnLong")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
            } else {
                objProxy.realmSet$columnLong((long) json.getLong("columnLong"));
            }
        }
        if (json.has("columnFloat")) {
            if (json.isNull("columnFloat")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
            } else {
                objProxy.realmSet$columnFloat((float) json.getDouble("columnFloat"));
            }
        }
        if (json.has("columnDouble")) {
            if (json.isNull("columnDouble")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
            } else {
                objProxy.realmSet$columnDouble((double) json.getDouble("columnDouble"));
            }
        }
        if (json.has("columnBoolean")) {
            if (json.isNull("columnBoolean")) {
                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
            } else {
                objProxy.realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
            }
        }
        if (json.has("columnDate")) {
            if (json.isNull("columnDate")) {
                objProxy.realmSet$columnDate(null);
            } else {
                Object timestamp = json.get("columnDate");
                if (timestamp instanceof String) {
                    objProxy.realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
                } else {
                    objProxy.realmSet$columnDate(new Date(json.getLong("columnDate")));
                }
            }
        }
        if (json.has("columnBinary")) {
            if (json.isNull("columnBinary")) {
                objProxy.realmSet$columnBinary(null);
            } else {
                objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
            }
        }
        if (json.has("columnMutableRealmInteger")) {
            objProxy.realmGet$columnMutableRealmInteger().set((json.isNull("columnMutableRealmInteger")) ? null : json.getLong("columnMutableRealmInteger"));
        }
        if (json.has("columnObject")) {
            if (json.isNull("columnObject")) {
                objProxy.realmSet$columnObject(null);
            } else {
                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
                objProxy.realmSet$columnObject(columnObjectObj);
            }
        }
        if (json.has("columnRealmList")) {
            if (json.isNull("columnRealmList")) {
                objProxy.realmSet$columnRealmList(null);
            } else {
                objProxy.realmGet$columnRealmList().clear();
                JSONArray array = json.getJSONArray("columnRealmList");
                for (int i = 0; i < array.length(); i++) {
                    some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
                    objProxy.realmGet$columnRealmList().add(item);
                }
            }
        }
        return obj;
    }

    @SuppressWarnings("cast")
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
        throws IOException {
        boolean jsonHasPrimaryKey = false;
        final some.test.AllTypes obj = new some.test.AllTypes();
        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
        reader.beginObject();
        while (reader.hasNext()) {
            String name = reader.nextName();
            if (false) {
            } else if (name.equals("columnString")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnString((String) reader.nextString());
                } else {
                    reader.skipValue();
                    objProxy.realmSet$columnString(null);
                }
                jsonHasPrimaryKey = true;
            } else if (name.equals("columnLong")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnLong((long) reader.nextLong());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
                }
            } else if (name.equals("columnFloat")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnFloat((float) reader.nextDouble());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
                }
            } else if (name.equals("columnDouble")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnDouble((double) reader.nextDouble());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
                }
            } else if (name.equals("columnBoolean")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnBoolean((boolean) reader.nextBoolean());
                } else {
                    reader.skipValue();
                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
                }
            } else if (name.equals("columnDate")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnDate(null);
                } else if (reader.peek() == JsonToken.NUMBER) {
                    long timestamp = reader.nextLong();
                    if (timestamp > -1) {
                        objProxy.realmSet$columnDate(new Date(timestamp));
                    }
                } else {
                    objProxy.realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
                }
            } else if (name.equals("columnBinary")) {
                if (reader.peek() != JsonToken.NULL) {
                    objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
                } else {
                    reader.skipValue();
                    objProxy.realmSet$columnBinary(null);
                }
            } else if (name.equals("columnMutableRealmInteger")) {
                Long val = null;
                if (reader.peek() != JsonToken.NULL) {
                    val = reader.nextLong()
                } else {
                    reader.skipValue();
                }
                objProxy.realmGet$columnMutableRealmInteger().set(val);
            } else if (name.equals("columnObject")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnObject(null);
                } else {
                    some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                    objProxy.realmSet$columnObject(columnObjectObj);
                }
            } else if (name.equals("columnRealmList")) {
                if (reader.peek() == JsonToken.NULL) {
                    reader.skipValue();
                    objProxy.realmSet$columnRealmList(null);
                } else {
                    objProxy.realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                    reader.beginArray();
                    while (reader.hasNext()) {
                        some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                        objProxy.realmGet$columnRealmList().add(item);
                    }
                    reader.endArray();
                }
            } else {
                reader.skipValue();
            }
        }
        reader.endObject();
        if (!jsonHasPrimaryKey) {
            throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
        }
        return realm.copyToRealm(obj);
    }

    public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
            if (otherRealm.threadId != realm.threadId) {
                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
            }
            if (otherRealm.getPath().equals(realm.getPath())) {
                return object;
            }
        }
        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
        RealmObjectProxy cachedRealmObject = cache.get(object);
        if (cachedRealmObject != null) {
            return (some.test.AllTypes) cachedRealmObject;
        }

        some.test.AllTypes realmObject = null;
        boolean canUpdate = update;
        if (canUpdate) {
            Table table = realm.getTable(some.test.AllTypes.class);
            long pkColumnIndex = table.getPrimaryKey();
            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (value == null) {
                rowIndex = table.findFirstNull(pkColumnIndex);
            } else {
                rowIndex = table.findFirstString(pkColumnIndex, value);
            }
            if (rowIndex == Table.NO_MATCH) {
                canUpdate = false;
            } else {
                try {
                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                    realmObject = new io.realm.AllTypesRealmProxy();
                    cache.put(object, (RealmObjectProxy) realmObject);
                } finally {
                    objectContext.clear();
                }
            }
        }

        return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache);
    }

    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
        RealmObjectProxy cachedRealmObject = cache.get(newObject);
        if (cachedRealmObject != null) {
            return (some.test.AllTypes) cachedRealmObject;
        }

        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
        some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
        cache.put(newObject, (RealmObjectProxy) realmObject);

        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
        AllTypesRealmProxyInterface realmObjectCopy = (AllTypesRealmProxyInterface) realmObject;

        realmObjectCopy.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
        realmObjectCopy.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
        realmObjectCopy.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
        realmObjectCopy.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
        realmObjectCopy.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
        realmObjectCopy.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());

        realmObjectCopy.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());

        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
        if (columnObjectObj == null) {
            realmObjectCopy.realmSet$columnObject(null);
        } else {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObjectCopy.realmSet$columnObject(cachecolumnObject);
            } else {
                realmObjectCopy.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
            }
        }

        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
        if (columnRealmListList != null) {
            RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectCopy.realmGet$columnRealmList();
            columnRealmListRealmList.clear();
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, update, cache));
                }
            }
        }

        return realmObject;
    }

    public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
        }
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
        long rowIndex = Table.NO_MATCH;
        if (primaryKeyValue == null) {
            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
        } else {
            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
        }
        if (rowIndex == Table.NO_MATCH) {
            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
        } else {
            Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
        }
        cache.put(object, rowIndex);
        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
        if (realmGet$columnDate != null) {
            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
        }
        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
        if (realmGet$columnBinary != null) {
            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
        }
        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
        if (realmGet$columnMutableRealmInteger != null) {
            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
        }

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
        if (columnObjectObj != null) {
            Long cachecolumnObject = cache.get(columnObjectObj);
            if (cachecolumnObject == null) {
                cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
            }
            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
        }

        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                if (cacheItemIndexcolumnRealmList == null) {
                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                }
                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
            }
        }
        return rowIndex;
    }

    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        some.test.AllTypes object = null;
        while (objects.hasNext()) {
            object = (some.test.AllTypes) objects.next();
            if (cache.containsKey(object)) {
                continue;
            }
            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
                continue;
            }
            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (primaryKeyValue == null) {
                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
            } else {
                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
            }
            if (rowIndex == Table.NO_MATCH) {
                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
            } else {
                Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
            }
            cache.put(object, rowIndex);
            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
            if (realmGet$columnDate != null) {
                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
            }
            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
            if (realmGet$columnBinary != null) {
                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
            }
            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
            if (realmGet$columnMutableRealmInteger != null) {
                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
            }

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
            if (columnObjectObj != null) {
                Long cachecolumnObject = cache.get(columnObjectObj);
                if (cachecolumnObject == null) {
                    cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
                }
                table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
            }

            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                    if (cacheItemIndexcolumnRealmList == null) {
                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                    }
                    LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                }
            }
        }
    }

    public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
        }
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
        long rowIndex = Table.NO_MATCH;
        if (primaryKeyValue == null) {
            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
        } else {
            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
        }
        if (rowIndex == Table.NO_MATCH) {
            rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
        }
        cache.put(object, rowIndex);
        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
        if (realmGet$columnDate != null) {
            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
        }
        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
        if (realmGet$columnBinary != null) {
            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
        }
        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
        if (realmGet$columnMutableRealmInteger != null) {
            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
        } else {
            Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
        }

        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
        if (columnObjectObj != null) {
            Long cachecolumnObject = cache.get(columnObjectObj);
            if (cachecolumnObject == null) {
                cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
            }
            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
        } else {
            Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
        }

        long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
        LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
        if (columnRealmListList != null) {
            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                if (cacheItemIndexcolumnRealmList == null) {
                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                }
                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
            }
        }

        return rowIndex;
    }

    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
        Table table = realm.getTable(some.test.AllTypes.class);
        long tableNativePtr = table.getNativePtr();
        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
        long pkColumnIndex = table.getPrimaryKey();
        some.test.AllTypes object = null;
        while (objects.hasNext()) {
            object = (some.test.AllTypes) objects.next();
            if (cache.containsKey(object)) {
                continue;
            }
            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
                continue;
            }
            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
            long rowIndex = Table.NO_MATCH;
            if (primaryKeyValue == null) {
                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
            } else {
                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
            }
            if (rowIndex == Table.NO_MATCH) {
                rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue);
            }
            cache.put(object, rowIndex);
            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
            if (realmGet$columnDate != null) {
                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
            }
            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
            if (realmGet$columnBinary != null) {
                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
            }
            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
            if (realmGet$columnMutableRealmInteger != null) {
                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
            } else {
                Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
            }

            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
            if (columnObjectObj != null) {
                Long cachecolumnObject = cache.get(columnObjectObj);
                if (cachecolumnObject == null) {
                    cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
                }
                Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
            } else {
                Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
            }

            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
            LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
            if (columnRealmListList != null) {
                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                    if (cacheItemIndexcolumnRealmList == null) {
                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                    }
                    LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
                }
            }

        }
    }

    public static some.test.AllTypes createDetachedCopy(some.test.AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
        if (currentDepth > maxDepth || realmObject == null) {
            return null;
        }
        CacheData<RealmModel> cachedObject = cache.get(realmObject);
        some.test.AllTypes unmanagedObject;
        if (cachedObject == null) {
            unmanagedObject = new some.test.AllTypes();
            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
        } else {
            // Reuse cached object or recreate it because it was encountered at a lower depth.
            if (currentDepth >= cachedObject.minDepth) {
                return (some.test.AllTypes) cachedObject.object;
            }
            unmanagedObject = (some.test.AllTypes) cachedObject.object;
            cachedObject.minDepth = currentDepth;
        }
        AllTypesRealmProxyInterface unmanagedCopy = (AllTypesRealmProxyInterface) unmanagedObject;
        AllTypesRealmProxyInterface realmSource = (AllTypesRealmProxyInterface) realmObject;
        unmanagedCopy.realmSet$columnString(realmSource.realmGet$columnString());
        unmanagedCopy.realmSet$columnLong(realmSource.realmGet$columnLong());
        unmanagedCopy.realmSet$columnFloat(realmSource.realmGet$columnFloat());
        unmanagedCopy.realmSet$columnDouble(realmSource.realmGet$columnDouble());
        unmanagedCopy.realmSet$columnBoolean(realmSource.realmGet$columnBoolean());
        unmanagedCopy.realmSet$columnDate(realmSource.realmGet$columnDate());
        unmanagedCopy.realmSet$columnBinary(realmSource.realmGet$columnBinary());
        unmanagedCopy.realmGet$columnMutableRealmInteger().set(realmSource.realmGet$columnMutableRealmInteger().get());

        // Deep copy of columnObject
        unmanagedCopy.realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(realmSource.realmGet$columnObject(), currentDepth + 1, maxDepth, cache));

        // Deep copy of columnRealmList
        if (currentDepth == maxDepth) {
            unmanagedCopy.realmSet$columnRealmList(null);
        } else {
            RealmList<some.test.AllTypes> managedcolumnRealmListList = realmSource.realmGet$columnRealmList();
            RealmList<some.test.AllTypes> unmanagedcolumnRealmListList = new RealmList<some.test.AllTypes>();
            unmanagedCopy.realmSet$columnRealmList(unmanagedcolumnRealmListList);
            int nextDepth = currentDepth + 1;
            int size = managedcolumnRealmListList.size();
            for (int i = 0; i < size; i++) {
                some.test.AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
                unmanagedcolumnRealmListList.add(item);
            }
        }
        return unmanagedObject;
    }

    static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
        AllTypesRealmProxyInterface realmObjectTarget = (AllTypesRealmProxyInterface) realmObject;
        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
        realmObjectTarget.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
        realmObjectTarget.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
        realmObjectTarget.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
        realmObjectTarget.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
        realmObjectTarget.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
        realmObjectTarget.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
        realmObjectTarget.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
        if (columnObjectObj == null) {
            realmObjectTarget.realmSet$columnObject(null);
        } else {
            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
            if (cachecolumnObject != null) {
                realmObjectTarget.realmSet$columnObject(cachecolumnObject);
            } else {
                realmObjectTarget.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
            }
        }
        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
        RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectTarget.realmGet$columnRealmList();
        columnRealmListRealmList.clear();
        if (columnRealmListList != null) {
            for (int i = 0; i < columnRealmListList.size(); i++) {
                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                if (cachecolumnRealmList != null) {
                    columnRealmListRealmList.add(cachecolumnRealmList);
                } else {
                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
                }
            }
        }
        return realmObject;
    }

    @Override
    @SuppressWarnings("ArrayToString")
    public String toString() {
        if (!RealmObject.isValid(this)) {
            return "Invalid object";
        }
        StringBuilder stringBuilder = new StringBuilder("AllTypes = proxy[");
        stringBuilder.append("{columnString:");
        stringBuilder.append(realmGet$columnString() != null ? realmGet$columnString() : "null");
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnLong:");
        stringBuilder.append(realmGet$columnLong());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnFloat:");
        stringBuilder.append(realmGet$columnFloat());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnDouble:");
        stringBuilder.append(realmGet$columnDouble());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnBoolean:");
        stringBuilder.append(realmGet$columnBoolean());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnDate:");
        stringBuilder.append(realmGet$columnDate());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnBinary:");
        stringBuilder.append(realmGet$columnBinary());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnMutableRealmInteger:");
        stringBuilder.append(realmGet$columnMutableRealmInteger().get());
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnObject:");
        stringBuilder.append(realmGet$columnObject() != null ? "AllTypes" : "null");
        stringBuilder.append("}");
        stringBuilder.append(",");
        stringBuilder.append("{columnRealmList:");
        stringBuilder.append("RealmList<AllTypes>[").append(realmGet$columnRealmList().size()).append("]");
        stringBuilder.append("}");
        stringBuilder.append("]");
        return stringBuilder.toString();
    }

    @Override
    public ProxyState<?> realmGet$proxyState() {
        return proxyState;
    }

    @Override
    public int hashCode() {
        String realmName = proxyState.getRealm$realm().getPath();
        String tableName = proxyState.getRow$realm().getTable().getName();
        long rowIndex = proxyState.getRow$realm().getIndex();

        int result = 17;
        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AllTypesRealmProxy aAllTypes = (AllTypesRealmProxy)o;

        String path = proxyState.getRealm$realm().getPath();
        String otherPath = aAllTypes.proxyState.getRealm$realm().getPath();
        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;

        String tableName = proxyState.getRow$realm().getTable().getName();
        String otherTableName = aAllTypes.proxyState.getRow$realm().getTable().getName();
        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;

        if (proxyState.getRow$realm().getIndex() != aAllTypes.proxyState.getRow$realm().getIndex()) return false;

        return true;
    }
}
!@#$%
20190526_211226,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b11336
/*
 * Copyright 2014 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm.processor;

import com.squareup.javawriter.JavaWriter;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;


public class RealmProxyClassGenerator {
    private static final String OPTION_SUPPRESS_WARNINGS = "realm.suppressWarnings";
    private static final String BACKLINKS_FIELD_EXTENSION = "Backlinks";

    private static final List<String> IMPORTS;
    static {
        List<String> l = Arrays.asList(
            "android.annotation.TargetApi",
            "android.os.Build",
            "android.util.JsonReader",
            "android.util.JsonToken",
            "io.realm.exceptions.RealmMigrationNeededException",
            "io.realm.internal.ColumnInfo",
            "io.realm.internal.LinkView",
            "io.realm.internal.OsObject",
            "io.realm.internal.OsObjectSchemaInfo",
            "io.realm.internal.Property",
            "io.realm.internal.ProxyUtils",
            "io.realm.internal.RealmObjectProxy",
            "io.realm.internal.Row",
            "io.realm.internal.SharedRealm",
            "io.realm.internal.Table",
            "io.realm.internal.android.JsonUtils",
            "io.realm.log.RealmLog",
            "java.io.IOException",
            "java.util.ArrayList",
            "java.util.Collections",
            "java.util.List",
            "java.util.Iterator",
            "java.util.Date",
            "java.util.Map",
            "java.util.HashMap",
            "org.json.JSONObject",
            "org.json.JSONException",
            "org.json.JSONArray");
        IMPORTS = Collections.unmodifiableList(l);
    }

    private final ProcessingEnvironment processingEnvironment;
    private final ClassMetaData metadata;
    private final String simpleClassName;
    private final String qualifiedClassName;
    private final String interfaceName;
    private final String qualifiedGeneratedClassName;
    private final boolean suppressWarnings;

    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
        this.processingEnvironment = processingEnvironment;
        this.metadata = metadata;
        this.simpleClassName = metadata.getSimpleClassName();
        this.qualifiedClassName = metadata.getFullyQualifiedClassName();
        this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
        this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));

        // See the configuration for the debug build type,
        //  in the realm-library project, for an example of how to set this flag.
        this.suppressWarnings = !"false".equalsIgnoreCase(processingEnvironment.getOptions().get(OPTION_SUPPRESS_WARNINGS));
    }

    public void generate() throws IOException, UnsupportedOperationException {
        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));

        // Set source code indent
        writer.setIndent(Constants.INDENT);

        writer.emitPackage(Constants.REALM_PACKAGE_NAME)
                .emitEmptyLine();

        List<String> imports = new ArrayList<String>(IMPORTS);
        if (!metadata.getBacklinkFields().isEmpty()) {
            imports.add("io.realm.internal.UncheckedRow");
        }
        writer.emitImports(imports)
                .emitEmptyLine();

        // Begin the class definition
        if (suppressWarnings) {
            writer.emitAnnotation("SuppressWarnings(\"all\")");
        }
        writer
                .beginType(
                qualifiedGeneratedClassName, // full qualified name of the item to generate
                "class",                     // the type of the item
                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
                qualifiedClassName,          // class to extend
                "RealmObjectProxy",          // interfaces to implement
                interfaceName)
                .emitEmptyLine();

        emitColumnInfoClass(writer);

        emitClassFields(writer);

        emitInstanceFields(writer);
        emitConstructor(writer);

        emitInjectContextMethod(writer);
        emitPersistedFieldAccessors(writer);
        emitBacklinkFieldAccessors(writer);
        emitCreateExpectedObjectSchemaInfo(writer);
        emitGetExpectedObjectSchemaInfo(writer);
        emitValidateTableMethod(writer);
        emitGetTableNameMethod(writer);
        emitGetFieldNamesMethod(writer);
        emitCreateOrUpdateUsingJsonObject(writer);
        emitCreateUsingJsonStream(writer);
        emitCopyOrUpdateMethod(writer);
        emitCopyMethod(writer);
        emitInsertMethod(writer);
        emitInsertListMethod(writer);
        emitInsertOrUpdateMethod(writer);
        emitInsertOrUpdateListMethod(writer);
        emitCreateDetachedCopyMethod(writer);
        emitUpdateMethod(writer);
        emitToStringMethod(writer);
        emitRealmObjectProxyImplementation(writer);
        emitHashcodeMethod(writer);
        emitEqualsMethod(writer);

        // End the class definition
        writer.endType();
        writer.close();
    }

    private void emitColumnInfoClass(JavaWriter writer) throws IOException {
        writer.beginType(
                columnInfoClassName(),                       // full qualified name of the item to generate
                "class",                                     // the type of the item
                EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
                "ColumnInfo");                               // base class

        // fields
        for (VariableElement variableElement : metadata.getFields()) {
            writer.emitField("long", columnIndexVarName(variableElement));
        }
        writer.emitEmptyLine();

        // constructor #1
        writer.beginConstructor(
                EnumSet.noneOf(Modifier.class),
                "SharedRealm", "realm", "Table", "table");
        writer.emitStatement("super(%s)", metadata.getFields().size());
        for (VariableElement field : metadata.getFields()) {
            writer.emitStatement(
                    "this.%1$sIndex = addColumnDetails(table, \"%1$s\", %2$s)",
                    field.getSimpleName().toString(), getRealmTypeChecked(field).getRealmType());
        }
        for (Backlink backlink : metadata.getBacklinkFields()) {
            writer.emitStatement(
                    "addBacklinkDetails(realm, \"%s\", \"%s\", \"%s\")",
                    backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
        }
        writer.endConstructor()
                .emitEmptyLine();

        // constructor #2
        writer.beginConstructor(
                EnumSet.noneOf(Modifier.class),
                "ColumnInfo", "src", "boolean", "mutable");
        writer.emitStatement("super(src, mutable)")
                .emitStatement("copy(src, this)");
        writer.endConstructor()
                .emitEmptyLine();

        // no-args copy method
        writer.emitAnnotation("Override")
                .beginMethod(
                        "ColumnInfo",                                   // return type
                        "copy",                                         // method name
                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), // modifiers
                        "boolean", "mutable");     // parameters
        writer.emitStatement("return new %s(this, mutable)", columnInfoClassName());
        writer.endMethod()
                .emitEmptyLine();

        // copy method
        writer.emitAnnotation("Override")
                .beginMethod(
                        "void",                                          // return type
                        "copy",                                          // method name
                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL),  // modifiers
                        "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst"); // parameters
        writer.emitStatement("final %1$s src = (%1$s) rawSrc", columnInfoClassName());
        writer.emitStatement("final %1$s dst = (%1$s) rawDst", columnInfoClassName());
        for (VariableElement variableElement : metadata.getFields()) {
            writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
        }
        writer.endMethod();

        writer.endType();
    }

    //@formatter:off
    private void emitClassFields(JavaWriter writer) throws IOException {
        writer.emitEmptyLine()
                .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");

        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
        writer.beginInitializer(true)
            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
            for (VariableElement field : metadata.getFields()) {
                writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
            }
        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
            .endInitializer();
    }
    //@formatter:on

    //@formatter:off
    private void emitInstanceFields(JavaWriter writer) throws IOException {
        writer.emitEmptyLine()
                .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));

        for (VariableElement variableElement : metadata.getFields()) {
            if (Utils.isMutableRealmInteger(variableElement)) {
                emitMutableRealmIntegerField(writer, variableElement);
            } else if (Utils.isRealmList(variableElement)) {
                String genericType = Utils.getGenericTypeQualifiedName(variableElement);
                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
            }
        }

        for (Backlink backlink : metadata.getBacklinkFields()) {
            writer.emitField(backlink.getTargetFieldType(), backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
                    EnumSet.of(Modifier.PRIVATE));
        }
    }
    //@formatter:on

    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
    // the MutableInteger that it owns, also becomes unreachable.
    //@formatter:off
    private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement variableElement) throws IOException{
        writer.emitField("MutableRealmInteger.Managed",
                mutableRealmIntegerFieldName(variableElement),
                EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
                String.format(
                        "new MutableRealmInteger.Managed<%1$s>() {\n"
                                + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
                                + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
                                + "}",
                        qualifiedClassName, columnIndexVarName(variableElement)));
    }
    //@formatter:on

    //@formatter:off
    private void emitConstructor(JavaWriter writer) throws IOException {
        // FooRealmProxy(ColumnInfo)
        writer.emitEmptyLine()
                .beginConstructor(EnumSet.noneOf(Modifier.class))
                .emitStatement("proxyState.setConstructionFinished()")
                .endConstructor()
                .emitEmptyLine();
    }
    //@formatter:on

    private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOException {
        for (final VariableElement field : metadata.getFields()) {
            final String fieldName = field.getSimpleName().toString();
            final String fieldTypeCanonicalName = field.asType().toString();

            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isMutableRealmInteger(field)) {
                emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isRealmModel(field)) {
                emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isRealmList(field)) {
                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
            } else {
                throw new UnsupportedOperationException(String.format(Locale.US,
                        "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
            }

            writer.emitEmptyLine();
        }
    }

    /**
     * Primitives and boxed types
     */
    private void emitPrimitiveType(
            JavaWriter writer,
            final VariableElement field,
            final String fieldName,
            String fieldTypeCanonicalName) throws IOException {

        final String fieldJavaType = getRealmTypeChecked(field).getJavaType();

        // Getter
        //@formatter:off
        writer.emitAnnotation("Override");
        writer.emitAnnotation("SuppressWarnings", "\"cast\"")
                .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()");

        // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
        if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
            writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
                    .emitStatement("return null")
                    .endControlFlow();
        }
        //@formatter:on

        // For Boxed types, this should be the corresponding primitive types. Others remain the same.
        String castingBackType;
        if (Utils.isBoxedType(fieldTypeCanonicalName)) {
            Types typeUtils = processingEnvironment.getTypeUtils();
            castingBackType = typeUtils.unboxedType(field.asType()).toString();
        } else {
            castingBackType = fieldTypeCanonicalName;
        }
        writer.emitStatement(
                "return (%s) proxyState.getRow$realm().get%s(%s)",
                castingBackType, fieldJavaType, fieldIndexVariableReference(field));
        writer.endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // set value as default value
                writer.emitStatement("final Row row = proxyState.getRow$realm()");

                //@formatter:off
                if (metadata.isNullable(field)) {
                    writer.beginControlFlow("if (value == null)")
                            .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
                                    fieldIndexVariableReference(field))
                            .emitStatement("return")
                            .endControlFlow();
                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                    writer.beginControlFlow("if (value == null)")
                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
                            .endControlFlow();
                }
                //@formatter:on

                writer.emitStatement(
                        "row.getTable().set%s(%s, row.getIndex(), value, true)",
                        fieldJavaType, fieldIndexVariableReference(field));
                writer.emitStatement("return");
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
        // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
        // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
        if (metadata.isPrimaryKey(field)) {
            // Primary key is not allowed to be changed after object created.
            writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
        } else {
            //@formatter:off
            if (metadata.isNullable(field)) {
                writer.beginControlFlow("if (value == null)")
                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
                        .emitStatement("return")
                        .endControlFlow();
            } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                // Same reason, throw IAE earlier.
                writer
                        .beginControlFlow("if (value == null)")
                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
                        .endControlFlow();
            }
            //@formatter:on
            writer.emitStatement(
                    "proxyState.getRow$realm().set%s(%s, value)",
                    fieldJavaType, fieldIndexVariableReference(field));
        }
        writer.endMethod();
    }

    //@formatter:off
    private void emitMutableRealmInteger(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeCanonicalName) throws IOException {
        writer.emitAnnotation("Override")
            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
            .endMethod();
    }
    //@formatter:on

    /**
     * Links
     */
    //@formatter:off
    private void emitRealmModel(
            JavaWriter writer,
            final VariableElement field,
            String fieldName,
            String fieldTypeCanonicalName) throws IOException {

        // Getter
        writer.emitAnnotation("Override");
        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
                .emitStatement("return null")
                .endControlFlow()
                .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
                        fieldTypeCanonicalName, fieldIndexVariableReference(field))
                .endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // check excludeFields
                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
                        field.getSimpleName().toString())
                        .emitStatement("return")
                        .endControlFlow();
                writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
                        .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
                        .endControlFlow();

                // set value as default value
                writer.emitStatement("final Row row = proxyState.getRow$realm()");
                writer.beginControlFlow("if (value == null)")
                        .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
                        .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
                        .emitStatement("return")
                        .endControlFlow();
                writer.beginControlFlow("if (!RealmObject.isValid(value))")
                        .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
                        .endControlFlow();
                writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                        .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                        .endControlFlow();
                writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
                        fieldIndexVariableReference(field));
                writer.emitStatement("return");
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .beginControlFlow("if (value == null)")
                .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
                .emitStatement("return")
                .endControlFlow()
                .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
                .endControlFlow()
                .beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                .endControlFlow()
                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
                .endMethod();
    }
    //@formatter:on

    /**
     * LinkLists
     */
    //@formatter:off
    private void emitRealmList(
            JavaWriter writer,
            final VariableElement field,
            String fieldName,
            String fieldTypeCanonicalName) throws IOException {
        String genericType = Utils.getGenericTypeQualifiedName(field);

        // Getter
        writer.emitAnnotation("Override");
        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitSingleLineComment("use the cached value if available")
                .beginControlFlow("if (" + fieldName + "RealmList != null)")
                .emitStatement("return " + fieldName + "RealmList")
                .nextControlFlow("else")
                .emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
                        genericType, genericType)
                .emitStatement("return " + fieldName + "RealmList")
                .endControlFlow()
                .endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // check excludeFields
                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
                        field.getSimpleName().toString())
                        .emitStatement("return")
                        .endControlFlow();
                final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
                writer.beginControlFlow("if (value != null && !value.isManaged())")
                        .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
                        .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
                        .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
                        .beginControlFlow("for (%1$s item : original)", modelFqcn)
                        .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
                        .emitStatement("value.add(item)")
                        .nextControlFlow("else")
                        .emitStatement("value.add(realm.copyToRealm(item))")
                        .endControlFlow()
                        .endControlFlow()
                        .endControlFlow();

                // LinkView currently does not support default value feature. Just fallback to normal code.
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                .emitStatement("links.clear()")
                .beginControlFlow("if (value == null)")
                .emitStatement("return")
                .endControlFlow()
                .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
                .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
                .endControlFlow()
                .beginControlFlow("if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
                .endControlFlow()
                .emitStatement("links.add(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
                .endControlFlow()
                .endMethod();
    }
    //@formatter:on

    private interface CodeEmitter {
        void emit(JavaWriter writer) throws IOException;
    }

    private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKey,
            CodeEmitter defaultValueCodeEmitter) throws IOException {
        writer.beginControlFlow("if (proxyState.isUnderConstruction())");
        if (isPrimaryKey) {
            writer.emitSingleLineComment("default value of the primary key is always ignored.")
                    .emitStatement("return");
        } else {
            writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
                    .emitStatement("return")
                    .endControlFlow();
            defaultValueCodeEmitter.emit(writer);
        }
        writer.endControlFlow()
                .emitEmptyLine();
    }

    // Note that because of bytecode hackery, this method may run before the constructor!
    // It may even run before fields have been initialized.
    //@formatter:off
    private void emitInjectContextMethod(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override");
        writer.beginMethod(
                "void", // Return type
                "realm$injectObjectContext", // Method name
                EnumSet.of(Modifier.PUBLIC) // Modifiers
        ); // Argument type & argument name

        writer.beginControlFlow("if (this.proxyState != null)")
                .emitStatement("return")
                .endControlFlow()
                .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
                .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
                .emitStatement("proxyState.setRealm$realm(context.getRealm())")
                .emitStatement("proxyState.setRow$realm(context.getRow())")
                .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
        for (Backlink backlink : metadata.getBacklinkFields()) {
            String cacheFieldName = backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION;
            String realmResultsType = "RealmResults<" + backlink.getSourceClass() + ">";

            // Getter, no setter
            writer.emitAnnotation("Override");
            writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
                    .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
                    .emitStatement("realm.checkIfValid()")
                    .emitStatement("proxyState.getRow$realm().checkIfAttached()")
                    .beginControlFlow("if (" + cacheFieldName + " == null)")
                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
                            backlink.getSourceClass(), backlink.getSourceField())
                    .endControlFlow()
                    .emitStatement("return " + cacheFieldName)
                    .endMethod()
                    .emitEmptyLine();
        }
    }
    //@formatter:on

    //@formatter:off
    private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override")
                .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
                .emitStatement("return proxyState")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "createExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers

        writer.emitStatement(
                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\")", this.simpleClassName);

        // For each field generate corresponding table index constant
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();

            Constants.RealmFieldType fieldType = getRealmType(field);
            switch (fieldType) {
                case NOTYPE:
                    // Perhaps this should fail quickly?
                    break;

                case OBJECT:
                    String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
                            fieldName, fieldTypeSimpleName);
                    break;

                case LIST:
                    String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
                            fieldName, genericTypeSimpleName);
                    break;

                default:
                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
                    writer.emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)",
                            fieldName,
                            fieldType.getRealmType(),
                            primaryKeyFlag,
                            indexedFlag,
                            nullableFlag);
            }
        }
        for (Backlink backlink: metadata.getBacklinkFields()) {
            writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
                    backlink.getTargetField(), backlink.getSimpleSourceClass(), backlink.getSourceField());
        }
        writer.emitStatement("return builder.build()");
        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "getExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers

        writer.emitStatement("return expectedObjectSchemaInfo");

        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                columnInfoClassName(),        // Return type
                "validateTable",              // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "SharedRealm", "sharedRealm", // Argument type & argument name
                "boolean", "allowExtraColumns");

        writer.beginControlFlow(
                "if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
        emitMigrationNeededException(writer, "\"The '%s' class is missing from the schema for this Realm.\")",
                metadata.getSimpleClassName());
        writer.endControlFlow();

        writer.emitStatement(
                "Table table = sharedRealm.getTable(\"%s%s\")",
                Constants.TABLE_PREFIX,
                this.simpleClassName);

        // verify number of columns
        writer.emitStatement("final long columnCount = table.getColumnCount()");
        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
        writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
        emitMigrationNeededException(writer, "\"Field count is less than expected - expected %d but was \" + columnCount)",
                metadata.getFields().size());
        writer.endControlFlow();
        writer.beginControlFlow("if (allowExtraColumns)");
        writer.emitStatement(
                "RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
                metadata.getFields().size());
        writer.nextControlFlow("else");
        emitMigrationNeededException(writer, "\"Field count is more than expected - expected %d but was \" + columnCount)",
                metadata.getFields().size());
        writer.endControlFlow();
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)")
                .emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))")
                .endControlFlow()
                .emitEmptyLine();

        // create an instance of ColumnInfo
        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm, table)", columnInfoClassName())
                .emitEmptyLine();

        // verify primary key definition was not altered
        if (metadata.hasPrimaryKey()) {
            // the current model defines a PK, make sure it's defined in the Realm schema
            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
            writer.beginControlFlow("if (!table.hasPrimaryKey())");
            emitMigrationNeededException(writer, "\"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")",
                    metadata.getPrimaryKey().getSimpleName().toString());
            writer.nextControlFlow("else")
                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName);
            emitMigrationNeededException(writer, "\"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")",
                    metadata.getPrimaryKey().getSimpleName().toString());
            writer.endControlFlow()
                    .endControlFlow();
        } else {
            // the current model doesn't define a PK, make sure it's not defined in the Realm schema
            writer.beginControlFlow("if (table.hasPrimaryKey())");
            emitMigrationNeededException(writer, "\"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")");
            writer.endControlFlow();
        }
        writer.emitEmptyLine();

        // For each field verify there is a corresponding
        long fieldIndex = -1;
        for (VariableElement field : metadata.getFields()) {
            fieldIndex++;
            String fieldName = field.getSimpleName().toString();
            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
            } else if (Utils.isMutableRealmInteger(field)) {
                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
            } else if (Utils.isRealmModel(field)) { // Links
                emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
            } else if (Utils.isRealmList(field)) { // Link Lists
                emitValidateRealmListType(writer, field, fieldIndex, fieldName);
            }
        }

        // verify the backlinks
        Set<Backlink> backlinks = metadata.getBacklinkFields();
        if (backlinks.size() > 0) {
            writer.emitEmptyLine()
                    .emitStatement("long backlinkFieldIndex")
                    .emitStatement("Table backlinkSourceTable")
                    .emitStatement("Table backlinkTargetTable")
                    .emitStatement("RealmFieldType backlinkFieldType");
            for (Backlink backlink : metadata.getBacklinkFields()) {
                emitValidateBacklink(writer, backlink);
            }
        }

        writer.emitEmptyLine();
        writer.emitStatement("return %s", "columnInfo");

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
            throws IOException {

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", %s, \"%s\")",
                fieldName, getRealmTypeChecked(field).getRealmType(), Utils.getFieldTypeSimpleName(field));

        // make sure that nullability matches
        if (!metadata.isNullable(field)) {
            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        } else {
            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
            if (metadata.isPrimaryKey(field)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                        fieldName);
                // nullability check for boxed types
            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"Field '%s' does not support null values in the existing Realm file. " +
                                "Either set @Required, use the primitive type for field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' is required. Either set @Required to field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        }

        // Validate @Index
        if (metadata.getIndexedFields().contains(field)) {
            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
            writer.endControlFlow();
        }
    }

    private void emitValidateRealmModelType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
            throws IOException {
        String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.OBJECT, \"%s\")",
                fieldName, Utils.getFieldTypeSimpleName(field));
        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
        writer.endControlFlow();

        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                fieldIndexVariableReference(field), fieldIndex);
        emitMigrationNeededException(writer, "\"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                fieldName, fieldIndexVariableReference(field), fieldIndex);
        writer.endControlFlow();
    }

    private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
            throws IOException {

        String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);

        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.LIST, \"%s\")",
                fieldName, genericTypeSimpleName);

        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
        writer.endControlFlow();

        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                fieldIndexVariableReference(field), fieldIndex);
        emitMigrationNeededException(writer, "\"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                fieldName, fieldIndexVariableReference(field), fieldIndex);
        writer.endControlFlow();
    }

    private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws IOException {
        String targetField = backlink.getTargetField();
        String targetClass = backlink.getTargetClass();

        // Preceding code has already verified that the backlink field is not in the table.
        // If it were, either the column count would be wrong, or some field would be missing.

        // verify that the source class exists
        String sourceClass = backlink.getSimpleSourceClass();
        String fullyQualifiedSourceClass = backlink.getSourceClass();
        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, sourceClass);
        emitMigrationNeededException(writer, "\"Cannot find source class '%s' for @LinkingObjects field '%s.%s'\")",
                fullyQualifiedSourceClass, targetClass, targetField);
        writer.endControlFlow();

        // verify that the source class contains the source field
        String sourceField = backlink.getSourceField();
        writer.emitStatement("backlinkSourceTable = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, sourceClass);
        writer.emitStatement("backlinkFieldIndex = backlinkSourceTable.getColumnIndex(\"%s\")", sourceField);
        writer.beginControlFlow("if (backlinkFieldIndex == Table.NO_MATCH)");
        emitMigrationNeededException(writer, "\"Cannot find source field '%s.%s' for @LinkingObjects field '%s.%s'\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();

        // verify that the source field type is target class
        writer.emitStatement("backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex)");
        writer.beginControlFlow("if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST))");
        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' is not a RealmObject type\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();
        writer.emitStatement("backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex)");
        writer.beginControlFlow("if (!table.hasSameSchema(backlinkTargetTable))");
        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' has wrong type '\" + backlinkTargetTable.getName() + \"'\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();
    }

    //@formatter:off
    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
                .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
                .emitStatement("return FIELD_NAMES")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "copyOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
        );

        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null)")
                    .emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm()")
                    .beginControlFlow("if (otherRealm.threadId != realm.threadId)")
                        .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
                    .endControlFlow()

                    // If object is already in the Realm there is nothing to update
                    .beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
                        .emitStatement("return object")
                    .endControlFlow()
                .endControlFlow();


        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");

        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
                .beginControlFlow("if (cachedRealmObject != null)")
                    .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                .endControlFlow()
                .emitEmptyLine();

        if (!metadata.hasPrimaryKey()) {
            writer.emitStatement("return copy(realm, object, update, cache)");
        } else {
            writer
                    .emitStatement("%s realmObject = null", qualifiedClassName)
                    .emitStatement("boolean canUpdate = update")
                    .beginControlFlow("if (canUpdate)")
                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");

            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
            VariableElement primaryKeyElement = metadata.getPrimaryKey();
            if (metadata.isNullable(primaryKeyElement)) {
                if (Utils.isString(primaryKeyElement)) {
                    writer
                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (value == null)")
                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                            .nextControlFlow("else")
                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
                            .endControlFlow();
                } else {
                    writer
                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (value == null)")
                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                            .nextControlFlow("else")
                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
                            .endControlFlow();
                }
            } else {
                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
                        pkType, interfaceName, primaryKeyGetter);
            }

            writer
                    .beginControlFlow("if (rowIndex == Table.NO_MATCH)")
                        .emitStatement("canUpdate = false")
                    .nextControlFlow("else")
                        .beginControlFlow("try")
                            .emitStatement(
                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
                                qualifiedClassName)
                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                        .nextControlFlow("finally")
                            .emitStatement("objectContext.clear()")
                        .endControlFlow()
                    .endControlFlow();

            writer.endControlFlow();

            writer
                    .emitEmptyLine()
                       .emitStatement("return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache)");
        }

        writer.endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
        if ("long".equals(fieldType)
                || "int".equals(fieldType)
                || "short".equals(fieldType)
                || "byte".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Long".equals(fieldType)
                || "java.lang.Integer".equals(fieldType)
                || "java.lang.Short".equals(fieldType)
                || "java.lang.Byte".equals(fieldType)) {
            writer
                    .emitStatement("Number %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("io.realm.MutableRealmInteger".equals(fieldType)) {
            writer
                    .emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("double".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Double".equals(fieldType)) {
            writer
                    .emitStatement("Double %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("float".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Float".equals(fieldType)) {
            writer
                    .emitStatement("Float %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("boolean".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Boolean".equals(fieldType)) {
            writer
                    .emitStatement("Boolean %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("byte[]".equals(fieldType)) {
            writer
                    .emitStatement("byte[] %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();


        } else if ("java.util.Date".equals(fieldType)) {
            writer
                    .emitStatement("java.util.Date %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("java.lang.String".equals(fieldType)) {
            writer
                    .emitStatement("String %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();
        } else {
            throw new IllegalStateException("Unsupported type " + fieldType);
        }
    }
    //@formatter:on

    private void emitInsertMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "long", // Return type
                "insert", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        // If object is already in the Realm there is nothing to update
        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                .endControlFlow();

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        addPrimaryKeyCheckIfNeeded(metadata, true, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field),
                                fieldName)
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return rowIndex");
        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitInsertListMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "void", // Return type
                "insert", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        writer.emitStatement("%s object = null", qualifiedClassName);

        writer.beginControlFlow("while (objects.hasNext())")
                .emitStatement("object = (%s) objects.next()", qualifiedClassName);
        writer.beginControlFlow("if (cache.containsKey(object))")
                .emitStatement("continue")
                .endControlFlow();

        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                .emitStatement("continue");
        writer.endControlFlow();

        addPrimaryKeyCheckIfNeeded(metadata, true, writer);

        //@formatter:off
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field),
                                fieldName)
                        .endControlFlow()
                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
                }
            }
        }
        //@formatter:on

        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "long", // Return type
                "insertOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        // If object is already in the Realm there is nothing to update
        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                .endControlFlow();

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        addPrimaryKeyCheckIfNeeded(metadata, false, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .nextControlFlow("else")
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return rowIndex");

        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "void", // Return type
                "insertOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        writer.emitStatement("%s object = null", qualifiedClassName);

        writer.beginControlFlow("while (objects.hasNext())");
        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
        writer.beginControlFlow("if (cache.containsKey(object))")
                .emitStatement("continue")
                .endControlFlow();

        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                .emitStatement("continue");
        writer.endControlFlow();
        addPrimaryKeyCheckIfNeeded(metadata, false, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .nextControlFlow("else")
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
                }
            }
            //@formatter:on
        }
        writer.endControlFlow();

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfPrimaryKeyDuplicate, JavaWriter writer) throws IOException {
        if (metadata.hasPrimaryKey()) {
            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
            VariableElement primaryKeyElement = metadata.getPrimaryKey();
            if (metadata.isNullable(primaryKeyElement)) {
                //@formatter:off
                if (Utils.isString(primaryKeyElement)) {
                    writer
                            .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (primaryKeyValue == null)")
                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                            .nextControlFlow("else")
                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
                            .endControlFlow();
                } else {
                    writer
                            .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (primaryKeyValue == null)")
                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                            .nextControlFlow("else")
                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
                            .endControlFlow();
                }
                //@formatter:on
            } else {
                writer.emitStatement("long rowIndex = Table.NO_MATCH");
                writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
                writer.beginControlFlow("if (primaryKeyValue != null)");

                if (Utils.isString(metadata.getPrimaryKey())) {
                    writer.emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)");
                } else {
                    writer.emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
                }
                writer.endControlFlow();
            }

            writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
            if (Utils.isString(metadata.getPrimaryKey())) {
                writer.emitStatement(
                        "rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue)");
            } else {
                writer.emitStatement(
                        "rowIndex = OsObject.createRowWithPrimaryKey(table, ((%s) object).%s())",
                        interfaceName, primaryKeyGetter);
            }

            if (throwIfPrimaryKeyDuplicate) {
                writer.nextControlFlow("else");
                writer.emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)");
            }

            writer.endControlFlow();
            writer.emitStatement("cache.put(object, rowIndex)");
        } else {
            writer.emitStatement("long rowIndex = OsObject.createRow(table)");
            writer.emitStatement("cache.put(object, rowIndex)");
        }
    }

    private void emitCopyMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "copy", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name

        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
        writer.beginControlFlow("if (cachedRealmObject != null)")
                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                .endControlFlow();


        writer.emitEmptyLine()
                .emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
                    qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
        } else {
            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
                    qualifiedClassName, qualifiedClassName);
        }
        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");

        writer.emitEmptyLine()
                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
                .emitStatement("%1$s realmObjectCopy = (%1$s) realmObject", interfaceName);

        writer.emitEmptyLine();
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);

            if (metadata.isPrimaryKey(field)) {
                // PK has been set when creating object.
                continue;
            }

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer.emitEmptyLine()
                        .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
                        .beginControlFlow("if (%sObj == null)", fieldName)
                            .emitStatement("realmObjectCopy.%s(null)", setter)
                        .nextControlFlow("else")
                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                            .beginControlFlow("if (cache%s != null)", fieldName)
                                .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
                            .nextControlFlow("else")
                                .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
                                    setter, Utils.getProxyClassSimpleName(field), fieldName)
                            .endControlFlow()
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer.emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                            .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
                                genericType, fieldName, getter)
                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                                .beginControlFlow("if (cache%s != null)", fieldName)
                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
                                .nextControlFlow("else")
                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, update, cache))",
                                        fieldName, Utils.getProxyClassSimpleName(field))
                                .endControlFlow()
                            .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitEmptyLine()
                        .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
            } else {
                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
            }
            //@formatter:on
        }

        writer.emitStatement("return realmObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    //@formatter:off
    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "createDetachedCopy", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
        writer
                .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                .emitStatement("return null")
                .endControlFlow()
                .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
                .emitStatement("%s unmanagedObject", qualifiedClassName)
                .beginControlFlow("if (cachedObject == null)")
                .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
                .nextControlFlow("else")
                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
                .emitStatement("return (%s) cachedObject.object", qualifiedClassName)
                .endControlFlow()
                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedClassName)
                .emitStatement("cachedObject.minDepth = currentDepth")
                .endControlFlow();

        // may cause an unused variable warning if the object contains only null lists
        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName)
            .emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);

            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitSingleLineComment("Deep copy of %s", fieldName)
                        .emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))",
                                setter, Utils.getProxyClassSimpleName(field), getter);
            } else if (Utils.isRealmList(field)) {
                writer
                        .emitEmptyLine()
                        .emitSingleLineComment("Deep copy of %s", fieldName)
                        .beginControlFlow("if (currentDepth == maxDepth)")
                        .emitStatement("unmanagedCopy.%s(null)", setter)
                        .nextControlFlow("else")
                        .emitStatement("RealmList<%s> managed%sList = realmSource.%s()",
                                Utils.getGenericTypeQualifiedName(field), fieldName, getter)
                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
                        .emitStatement("unmanagedCopy.%s(unmanaged%sList)", setter, fieldName)
                        .emitStatement("int nextDepth = currentDepth + 1")
                        .emitStatement("int size = managed%sList.size()", fieldName)
                        .beginControlFlow("for (int i = 0; i < size; i++)")
                        .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
                                Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
                        .emitStatement("unmanaged%sList.add(item)", fieldName)
                        .endControlFlow()
                        .endControlFlow();
            } else if (Utils.isMutableRealmInteger(field)) {
                // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
                writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
            } else {
                writer.emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter);
            }
        }

        writer.emitStatement("return unmanagedObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }
    //@formatter:on

    private void emitUpdateMethod(JavaWriter writer) throws IOException {
        if (!metadata.hasPrimaryKey()) {
            return;
        }

        writer.beginMethod(
                qualifiedClassName, // Return type
                "update", // Method name
                EnumSet.of(Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name

        writer
                .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);
            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitStatement("%s %sObj = realmObjectSource.%s()",
                                Utils.getFieldTypeQualifiedName(field), fieldName, getter)
                        .beginControlFlow("if (%sObj == null)", fieldName)
                        .emitStatement("realmObjectTarget.%s(null)", setter)
                        .nextControlFlow("else")
                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sObj)",
                                Utils.getFieldTypeQualifiedName(field), fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                        .emitStatement("realmObjectTarget.%s(cache%s)", setter, fieldName)
                        .nextControlFlow("else")
                        .emitStatement("realmObjectTarget.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
                                setter, Utils.getProxyClassSimpleName(field), fieldName)
                        .endControlFlow()
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                        .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()",
                                genericType, fieldName, getter)
                        .emitStatement("%sRealmList.clear()", fieldName)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                        .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                        .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
                        .nextControlFlow("else")
                        .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))",
                                fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .endControlFlow()
                        .endControlFlow();

            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
            } else {
                if (field != metadata.getPrimaryKey()) {
                    writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return realmObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitToStringMethod(JavaWriter writer) throws IOException {
        if (metadata.containsToString()) {
            return;
        }
        writer.emitAnnotation("Override");
        writer.emitAnnotation("SuppressWarnings", "\"ArrayToString\"")
                .beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC))
                .beginControlFlow("if (!RealmObject.isValid(this))")
                .emitStatement("return \"Invalid object\"")
                .endControlFlow();
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleClassName);

        Collection<VariableElement> fields = metadata.getFields();
        int i = fields.size() - 1;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();

            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            if (Utils.isRealmModel(field)) {
                String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                writer.emitStatement(
                        "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
                        metadata.getInternalGetter(fieldName),
                        fieldTypeSimpleName
                );
            } else if (Utils.isRealmList(field)) {
                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                        genericTypeSimpleName,
                        metadata.getInternalGetter(fieldName));
            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName));
            } else {
                if (metadata.isNullable(field)) {
                    writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
                            metadata.getInternalGetter(fieldName),
                            metadata.getInternalGetter(fieldName)
                    );
                } else {
                    writer.emitStatement("stringBuilder.append(%s())", metadata.getInternalGetter(fieldName));
                }
            }
            writer.emitStatement("stringBuilder.append(\"}\")");

            if (i-- > 0) {
                writer.emitStatement("stringBuilder.append(\",\")");
            }
        }

        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod()
                .emitEmptyLine();
    }

    /**
     * Currently, the hash value emitted from this could suddenly change as an object's index might
     * alternate due to Realm Java using {@code Table#moveLastOver()}. Hash codes should therefore not
     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
     */
    //@formatter:off
    private void emitHashcodeMethod(JavaWriter writer) throws IOException {
        if (metadata.containsHashCode()) {
            return;
        }
        writer.emitAnnotation("Override")
                .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
                .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
                .emitEmptyLine()
                .emitStatement("int result = 17")
                .emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)")
                .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
                .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
                .emitStatement("return result")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitEqualsMethod(JavaWriter writer) throws IOException {
        if (metadata.containsEquals()) {
            return;
        }
        String proxyClassName = Utils.getProxyClassName(simpleClassName);
        String otherObjectVarName = "a" + simpleClassName;
        writer.emitAnnotation("Override")
                .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
                .emitStatement("if (this == o) return true")
                .emitStatement("if (o == null || getClass() != o.getClass()) return false")
                .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
                .emitEmptyLine()
                .emitStatement("String path = proxyState.getRealm$realm().getPath()")
                .emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName)
                .emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false")
                .emitEmptyLine()
                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                .emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName)
                .emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false")
                .emitEmptyLine()
                .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
                .emitEmptyLine()
                .emitStatement("return true")
                .endMethod();
    }
    //@formatter:on

    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.beginMethod(
                qualifiedClassName,
                "createOrUpdateUsingJsonObject",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                Collections.singletonList("JSONException"));

        final int modelOrListCount = countModelOrListFields(metadata.getFields());
        if (modelOrListCount == 0) {
            writer.emitStatement("final List<String> excludeFields = Collections.<String> emptyList()");
        } else {
            writer.emitStatement("final List<String> excludeFields = new ArrayList<String>(%1$d)",
                    modelOrListCount);
        }

        //@formatter:off
        if (!metadata.hasPrimaryKey()) {
            buildExcludeFieldsList(writer, metadata.getFields());
            writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
                    qualifiedClassName, qualifiedClassName);
        } else {
            String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
            writer
                .emitStatement("%s obj = null", qualifiedClassName)
                .beginControlFlow("if (update)")
                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                    .emitStatement("long rowIndex = Table.NO_MATCH");
            if (metadata.isNullable(metadata.getPrimaryKey())) {
                writer
                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                        .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                    .nextControlFlow("else")
                        .emitStatement(
                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                    .endControlFlow();
            } else {
                writer
                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                        .emitStatement(
                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                    .endControlFlow();
            }
            writer
                .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
                    .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
                    .beginControlFlow("try")
                        .emitStatement(
                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
                                qualifiedClassName)
                        .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
                    .nextControlFlow("finally")
                        .emitStatement("objectContext.clear()")
                    .endControlFlow()
                .endControlFlow()
            .endControlFlow();

            writer.beginControlFlow("if (obj == null)");
            buildExcludeFieldsList(writer, metadata.getFields());
            String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
            String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
                    qualifiedClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
            writer.endControlFlow();
        }
        //@formatter:on

        writer
                .emitEmptyLine()
                .emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            if (metadata.isPrimaryKey(field)) {
                // Primary key has already been set when adding new row or finding the existing row.
                continue;
            }
            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer);

            } else {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.emitStatement("return obj");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void buildExcludeFieldsList(JavaWriter writer, Collection<VariableElement> fields) throws IOException {
        for (VariableElement field : fields) {
            if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
                final String fieldName = field.getSimpleName().toString();
                writer.beginControlFlow("if (json.has(\"%1$s\"))", fieldName)
                        .emitStatement("excludeFields.add(\"%1$s\")", fieldName)
                        .endControlFlow();
            }
        }
    }

    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
    // instead of createObject() to avoid parsing the stream twice.
    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
        writer.beginMethod(
                qualifiedClassName,
                "createUsingJsonStream",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                Collections.singletonList("IOException"));

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("boolean jsonHasPrimaryKey = false");
        }
        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        writer.emitStatement("reader.beginObject()");
        writer.beginControlFlow("while (reader.hasNext())");
        writer.emitStatement("String name = reader.nextName()");
        writer.beginControlFlow("if (false)");
        Collection<VariableElement> fields = metadata.getFields();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);

            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListFromStream(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            } else {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.nextControlFlow("else");
        writer.emitStatement("reader.skipValue()");
        writer.endControlFlow();

        writer.endControlFlow();
        writer.emitStatement("reader.endObject()");

        if (metadata.hasPrimaryKey()) {
            writer.beginControlFlow("if (!jsonHasPrimaryKey)")
                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey())
                    .endControlFlow();
        }

        writer.emitStatement("return realm.copyToRealm(obj)");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitMigrationNeededException(JavaWriter writer, String message, Object... args) throws IOException {
        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), " + message, args);
    }

    private String columnInfoClassName() {
        return simpleClassName + "ColumnInfo";
    }

    private String columnIndexVarName(VariableElement variableElement) {
        return variableElement.getSimpleName().toString() + "Index";
    }

    private String mutableRealmIntegerFieldName(VariableElement variableElement) {
        return variableElement.getSimpleName().toString() + "MutableRealmInteger";
    }

    private String fieldIndexVariableReference(VariableElement variableElement) {
        return "columnInfo." + columnIndexVarName(variableElement);
    }

    private static int countModelOrListFields(Collection<VariableElement> fields) {
        int count = 0;
        for (VariableElement f : fields) {
            if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
                count++;
            }
        }
        return count;
    }

    private Constants.RealmFieldType getRealmType(VariableElement field) {
        String fieldTypeCanonicalName = field.asType().toString();
        Constants.RealmFieldType type = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
        if (type != null) {
            return type;
        }
        if (Utils.isMutableRealmInteger(field)) {
            return Constants.RealmFieldType.REALM_INTEGER;
        }
        if (Utils.isRealmModel(field)) {
            return Constants.RealmFieldType.OBJECT;
        }
        if (Utils.isRealmList(field)) {
            return Constants.RealmFieldType.LIST;
        }
        return Constants.RealmFieldType.NOTYPE;
    }

    private Constants.RealmFieldType getRealmTypeChecked(VariableElement field) {
        Constants.RealmFieldType type = getRealmType(field);
        if (type == Constants.RealmFieldType.NOTYPE) {
            throw new IllegalStateException("Unsupported type " + field.asType().toString());
        }
        return type;
    }
}
!@#$%
20190526_211226,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a11336
/*
 * Copyright 2014 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm.processor;

import com.squareup.javawriter.JavaWriter;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;


public class RealmProxyClassGenerator {
    private static final String OPTION_SUPPRESS_WARNINGS = "realm.suppressWarnings";
    private static final String BACKLINKS_FIELD_EXTENSION = "Backlinks";

    private static final List<String> IMPORTS;
    static {
        List<String> l = Arrays.asList(
            "android.annotation.TargetApi",
            "android.os.Build",
            "android.util.JsonReader",
            "android.util.JsonToken",
            "io.realm.exceptions.RealmMigrationNeededException",
            "io.realm.internal.ColumnInfo",
            "io.realm.internal.LinkView",
            "io.realm.internal.OsObject",
            "io.realm.internal.OsObjectSchemaInfo",
            "io.realm.internal.Property",
            "io.realm.internal.ProxyUtils",
            "io.realm.internal.RealmObjectProxy",
            "io.realm.internal.Row",
            "io.realm.internal.SharedRealm",
            "io.realm.internal.Table",
            "io.realm.internal.android.JsonUtils",
            "io.realm.log.RealmLog",
            "java.io.IOException",
            "java.util.ArrayList",
            "java.util.Collections",
            "java.util.List",
            "java.util.Iterator",
            "java.util.Date",
            "java.util.Map",
            "java.util.HashMap",
            "org.json.JSONObject",
            "org.json.JSONException",
            "org.json.JSONArray");
        IMPORTS = Collections.unmodifiableList(l);
    }

    private final ProcessingEnvironment processingEnvironment;
    private final ClassMetaData metadata;
    private final String simpleClassName;
    private final String qualifiedClassName;
    private final String interfaceName;
    private final String qualifiedGeneratedClassName;
    private final boolean suppressWarnings;

    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
        this.processingEnvironment = processingEnvironment;
        this.metadata = metadata;
        this.simpleClassName = metadata.getSimpleClassName();
        this.qualifiedClassName = metadata.getFullyQualifiedClassName();
        this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
        this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));

        // See the configuration for the debug build type,
        //  in the realm-library project, for an example of how to set this flag.
        this.suppressWarnings = !"false".equalsIgnoreCase(processingEnvironment.getOptions().get(OPTION_SUPPRESS_WARNINGS));
    }

    public void generate() throws IOException, UnsupportedOperationException {
        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));

        // Set source code indent
        writer.setIndent(Constants.INDENT);

        writer.emitPackage(Constants.REALM_PACKAGE_NAME)
                .emitEmptyLine();

        List<String> imports = new ArrayList<String>(IMPORTS);
        if (!metadata.getBacklinkFields().isEmpty()) {
            imports.add("io.realm.internal.UncheckedRow");
        }
        writer.emitImports(imports)
                .emitEmptyLine();

        // Begin the class definition
        if (suppressWarnings) {
            writer.emitAnnotation("SuppressWarnings(\"all\")");
        }
        writer
                .beginType(
                qualifiedGeneratedClassName, // full qualified name of the item to generate
                "class",                     // the type of the item
                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
                qualifiedClassName,          // class to extend
                "RealmObjectProxy",          // interfaces to implement
                interfaceName)
                .emitEmptyLine();

        emitColumnInfoClass(writer);

        emitClassFields(writer);

        emitInstanceFields(writer);
        emitConstructor(writer);

        emitInjectContextMethod(writer);
        emitPersistedFieldAccessors(writer);
        emitBacklinkFieldAccessors(writer);
        emitCreateExpectedObjectSchemaInfo(writer);
        emitGetExpectedObjectSchemaInfo(writer);
        emitValidateTableMethod(writer);
        emitGetTableNameMethod(writer);
        emitGetFieldNamesMethod(writer);
        emitCreateOrUpdateUsingJsonObject(writer);
        emitCreateUsingJsonStream(writer);
        emitCopyOrUpdateMethod(writer);
        emitCopyMethod(writer);
        emitInsertMethod(writer);
        emitInsertListMethod(writer);
        emitInsertOrUpdateMethod(writer);
        emitInsertOrUpdateListMethod(writer);
        emitCreateDetachedCopyMethod(writer);
        emitUpdateMethod(writer);
        emitToStringMethod(writer);
        emitRealmObjectProxyImplementation(writer);
        emitHashcodeMethod(writer);
        emitEqualsMethod(writer);

        // End the class definition
        writer.endType();
        writer.close();
    }

    private void emitColumnInfoClass(JavaWriter writer) throws IOException {
        writer.beginType(
                columnInfoClassName(),                       // full qualified name of the item to generate
                "class",                                     // the type of the item
                EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
                "ColumnInfo");                               // base class

        // fields
        for (VariableElement variableElement : metadata.getFields()) {
            writer.emitField("long", columnIndexVarName(variableElement));
        }
        writer.emitEmptyLine();

        // constructor #1
        writer.beginConstructor(
                EnumSet.noneOf(Modifier.class),
                "SharedRealm", "realm", "Table", "table");
        writer.emitStatement("super(%s)", metadata.getFields().size());
        for (VariableElement field : metadata.getFields()) {
            writer.emitStatement(
                    "this.%1$sIndex = addColumnDetails(table, \"%1$s\", %2$s)",
                    field.getSimpleName().toString(), getRealmTypeChecked(field).getRealmType());
        }
        for (Backlink backlink : metadata.getBacklinkFields()) {
            writer.emitStatement(
                    "addBacklinkDetails(realm, \"%s\", \"%s\", \"%s\")",
                    backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
        }
        writer.endConstructor()
                .emitEmptyLine();

        // constructor #2
        writer.beginConstructor(
                EnumSet.noneOf(Modifier.class),
                "ColumnInfo", "src", "boolean", "mutable");
        writer.emitStatement("super(src, mutable)")
                .emitStatement("copy(src, this)");
        writer.endConstructor()
                .emitEmptyLine();

        // no-args copy method
        writer.emitAnnotation("Override")
                .beginMethod(
                        "ColumnInfo",                                   // return type
                        "copy",                                         // method name
                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), // modifiers
                        "boolean", "mutable");     // parameters
        writer.emitStatement("return new %s(this, mutable)", columnInfoClassName());
        writer.endMethod()
                .emitEmptyLine();

        // copy method
        writer.emitAnnotation("Override")
                .beginMethod(
                        "void",                                          // return type
                        "copy",                                          // method name
                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL),  // modifiers
                        "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst"); // parameters
        writer.emitStatement("final %1$s src = (%1$s) rawSrc", columnInfoClassName());
        writer.emitStatement("final %1$s dst = (%1$s) rawDst", columnInfoClassName());
        for (VariableElement variableElement : metadata.getFields()) {
            writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
        }
        writer.endMethod();

        writer.endType();
    }

    //@formatter:off
    private void emitClassFields(JavaWriter writer) throws IOException {
        writer.emitEmptyLine()
                .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");

        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
        writer.beginInitializer(true)
            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
            for (VariableElement field : metadata.getFields()) {
                writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
            }
        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
            .endInitializer();
    }
    //@formatter:on

    //@formatter:off
    private void emitInstanceFields(JavaWriter writer) throws IOException {
        writer.emitEmptyLine()
                .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));

        for (VariableElement variableElement : metadata.getFields()) {
            if (Utils.isMutableRealmInteger(variableElement)) {
                emitMutableRealmIntegerField(writer, variableElement);
            } else if (Utils.isRealmList(variableElement)) {
                String genericType = Utils.getGenericTypeQualifiedName(variableElement);
                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
            }
        }

        for (Backlink backlink : metadata.getBacklinkFields()) {
            writer.emitField(backlink.getTargetFieldType(), backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
                    EnumSet.of(Modifier.PRIVATE));
        }
    }
    //@formatter:on

    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
    // the MutableInteger that it owns, also becomes unreachable.
    //@formatter:off
    private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement variableElement) throws IOException{
        writer.emitField("MutableRealmInteger.Managed",
                mutableRealmIntegerFieldName(variableElement),
                EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
                String.format(
                        "new MutableRealmInteger.Managed<%1$s>() {\n"
                                + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
                                + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
                                + "}",
                        qualifiedClassName, columnIndexVarName(variableElement)));
    }
    //@formatter:on

    //@formatter:off
    private void emitConstructor(JavaWriter writer) throws IOException {
        // FooRealmProxy(ColumnInfo)
        writer.emitEmptyLine()
                .beginConstructor(EnumSet.noneOf(Modifier.class))
                .emitStatement("proxyState.setConstructionFinished()")
                .endConstructor()
                .emitEmptyLine();
    }
    //@formatter:on

    private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOException {
        for (final VariableElement field : metadata.getFields()) {
            final String fieldName = field.getSimpleName().toString();
            final String fieldTypeCanonicalName = field.asType().toString();

            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isMutableRealmInteger(field)) {
                emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isRealmModel(field)) {
                emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isRealmList(field)) {
                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
            } else {
                throw new UnsupportedOperationException(String.format(Locale.US,
                        "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
            }

            writer.emitEmptyLine();
        }
    }

    /**
     * Primitives and boxed types
     */
    private void emitPrimitiveType(
            JavaWriter writer,
            final VariableElement field,
            final String fieldName,
            String fieldTypeCanonicalName) throws IOException {

        final String fieldJavaType = getRealmTypeChecked(field).getJavaType();

        // Getter
        //@formatter:off
        writer.emitAnnotation("Override");
        writer.emitAnnotation("SuppressWarnings", "\"cast\"")
                .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()");

        // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
        if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
            writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
                    .emitStatement("return null")
                    .endControlFlow();
        }
        //@formatter:on

        // For Boxed types, this should be the corresponding primitive types. Others remain the same.
        String castingBackType;
        if (Utils.isBoxedType(fieldTypeCanonicalName)) {
            Types typeUtils = processingEnvironment.getTypeUtils();
            castingBackType = typeUtils.unboxedType(field.asType()).toString();
        } else {
            castingBackType = fieldTypeCanonicalName;
        }
        writer.emitStatement(
                "return (%s) proxyState.getRow$realm().get%s(%s)",
                castingBackType, fieldJavaType, fieldIndexVariableReference(field));
        writer.endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // set value as default value
                writer.emitStatement("final Row row = proxyState.getRow$realm()");

                //@formatter:off
                if (metadata.isNullable(field)) {
                    writer.beginControlFlow("if (value == null)")
                            .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
                                    fieldIndexVariableReference(field))
                            .emitStatement("return")
                            .endControlFlow();
                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                    writer.beginControlFlow("if (value == null)")
                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
                            .endControlFlow();
                }
                //@formatter:on

                writer.emitStatement(
                        "row.getTable().set%s(%s, row.getIndex(), value, true)",
                        fieldJavaType, fieldIndexVariableReference(field));
                writer.emitStatement("return");
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
        // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
        // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
        if (metadata.isPrimaryKey(field)) {
            // Primary key is not allowed to be changed after object created.
            writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
        } else {
            //@formatter:off
            if (metadata.isNullable(field)) {
                writer.beginControlFlow("if (value == null)")
                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
                        .emitStatement("return")
                        .endControlFlow();
            } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                // Same reason, throw IAE earlier.
                writer
                        .beginControlFlow("if (value == null)")
                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
                        .endControlFlow();
            }
            //@formatter:on
            writer.emitStatement(
                    "proxyState.getRow$realm().set%s(%s, value)",
                    fieldJavaType, fieldIndexVariableReference(field));
        }
        writer.endMethod();
    }

    //@formatter:off
    private void emitMutableRealmInteger(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeCanonicalName) throws IOException {
        writer.emitAnnotation("Override")
            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
            .endMethod();
    }
    //@formatter:on

    /**
     * Links
     */
    //@formatter:off
    private void emitRealmModel(
            JavaWriter writer,
            final VariableElement field,
            String fieldName,
            String fieldTypeCanonicalName) throws IOException {

        // Getter
        writer.emitAnnotation("Override");
        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
                .emitStatement("return null")
                .endControlFlow()
                .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
                        fieldTypeCanonicalName, fieldIndexVariableReference(field))
                .endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // check excludeFields
                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
                        field.getSimpleName().toString())
                        .emitStatement("return")
                        .endControlFlow();
                writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
                        .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
                        .endControlFlow();

                // set value as default value
                writer.emitStatement("final Row row = proxyState.getRow$realm()");
                writer.beginControlFlow("if (value == null)")
                        .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
                        .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
                        .emitStatement("return")
                        .endControlFlow();
                writer.beginControlFlow("if (!RealmObject.isValid(value))")
                        .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
                        .endControlFlow();
                writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                        .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                        .endControlFlow();
                writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
                        fieldIndexVariableReference(field));
                writer.emitStatement("return");
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .beginControlFlow("if (value == null)")
                .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
                .emitStatement("return")
                .endControlFlow()
                .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
                .endControlFlow()
                .beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                .endControlFlow()
                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
                .endMethod();
    }
    //@formatter:on

    /**
     * LinkLists
     */
    //@formatter:off
    private void emitRealmList(
            JavaWriter writer,
            final VariableElement field,
            String fieldName,
            String fieldTypeCanonicalName) throws IOException {
        String genericType = Utils.getGenericTypeQualifiedName(field);

        // Getter
        writer.emitAnnotation("Override");
        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitSingleLineComment("use the cached value if available")
                .beginControlFlow("if (" + fieldName + "RealmList != null)")
                .emitStatement("return " + fieldName + "RealmList")
                .nextControlFlow("else")
                .emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
                        genericType, genericType)
                .emitStatement("return " + fieldName + "RealmList")
                .endControlFlow()
                .endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // check excludeFields
                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
                        field.getSimpleName().toString())
                        .emitStatement("return")
                        .endControlFlow();
                final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
                writer.beginControlFlow("if (value != null && !value.isManaged())")
                        .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
                        .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
                        .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
                        .beginControlFlow("for (%1$s item : original)", modelFqcn)
                        .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
                        .emitStatement("value.add(item)")
                        .nextControlFlow("else")
                        .emitStatement("value.add(realm.copyToRealm(item))")
                        .endControlFlow()
                        .endControlFlow()
                        .endControlFlow();

                // LinkView currently does not support default value feature. Just fallback to normal code.
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                .emitStatement("links.clear()")
                .beginControlFlow("if (value == null)")
                .emitStatement("return")
                .endControlFlow()
                .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
                .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
                .endControlFlow()
                .beginControlFlow("if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
                .endControlFlow()
                .emitStatement("links.add(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
                .endControlFlow()
                .endMethod();
    }
    //@formatter:on

    private interface CodeEmitter {
        void emit(JavaWriter writer) throws IOException;
    }

    private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKey,
            CodeEmitter defaultValueCodeEmitter) throws IOException {
        writer.beginControlFlow("if (proxyState.isUnderConstruction())");
        if (isPrimaryKey) {
            writer.emitSingleLineComment("default value of the primary key is always ignored.")
                    .emitStatement("return");
        } else {
            writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
                    .emitStatement("return")
                    .endControlFlow();
            defaultValueCodeEmitter.emit(writer);
        }
        writer.endControlFlow()
                .emitEmptyLine();
    }

    // Note that because of bytecode hackery, this method may run before the constructor!
    // It may even run before fields have been initialized.
    //@formatter:off
    private void emitInjectContextMethod(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override");
        writer.beginMethod(
                "void", // Return type
                "realm$injectObjectContext", // Method name
                EnumSet.of(Modifier.PUBLIC) // Modifiers
        ); // Argument type & argument name

        writer.beginControlFlow("if (this.proxyState != null)")
                .emitStatement("return")
                .endControlFlow()
                .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
                .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
                .emitStatement("proxyState.setRealm$realm(context.getRealm())")
                .emitStatement("proxyState.setRow$realm(context.getRow())")
                .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
        for (Backlink backlink : metadata.getBacklinkFields()) {
            String cacheFieldName = backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION;
            String realmResultsType = "RealmResults<" + backlink.getSourceClass() + ">";

            // Getter, no setter
            writer.emitAnnotation("Override");
            writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
                    .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
                    .emitStatement("realm.checkIfValid()")
                    .emitStatement("proxyState.getRow$realm().checkIfAttached()")
                    .beginControlFlow("if (" + cacheFieldName + " == null)")
                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
                            backlink.getSourceClass(), backlink.getSourceField())
                    .endControlFlow()
                    .emitStatement("return " + cacheFieldName)
                    .endMethod()
                    .emitEmptyLine();
        }
    }
    //@formatter:on

    //@formatter:off
    private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override")
                .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
                .emitStatement("return proxyState")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "createExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers

        writer.emitStatement(
                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\")", this.simpleClassName);

        // For each field generate corresponding table index constant
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();

            Constants.RealmFieldType fieldType = getRealmType(field);
            switch (fieldType) {
                case NOTYPE:
                    // Perhaps this should fail quickly?
                    break;

                case OBJECT:
                    String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
                            fieldName, fieldTypeSimpleName);
                    break;

                case LIST:
                    String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
                            fieldName, genericTypeSimpleName);
                    break;

                default:
                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
                    writer.emitStatement("builder.addProperty(\"%s\", %s, %s, %s, %s)",
                            fieldName,
                            fieldType.getRealmType(),
                            primaryKeyFlag,
                            indexedFlag,
                            nullableFlag);
            }
        }
        writer.emitStatement("return builder.build()");
        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "getExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers

        writer.emitStatement("return expectedObjectSchemaInfo");

        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                columnInfoClassName(),        // Return type
                "validateTable",              // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "SharedRealm", "sharedRealm", // Argument type & argument name
                "boolean", "allowExtraColumns");

        writer.beginControlFlow(
                "if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
        emitMigrationNeededException(writer, "\"The '%s' class is missing from the schema for this Realm.\")",
                metadata.getSimpleClassName());
        writer.endControlFlow();

        writer.emitStatement(
                "Table table = sharedRealm.getTable(\"%s%s\")",
                Constants.TABLE_PREFIX,
                this.simpleClassName);

        // verify number of columns
        writer.emitStatement("final long columnCount = table.getColumnCount()");
        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
        writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
        emitMigrationNeededException(writer, "\"Field count is less than expected - expected %d but was \" + columnCount)",
                metadata.getFields().size());
        writer.endControlFlow();
        writer.beginControlFlow("if (allowExtraColumns)");
        writer.emitStatement(
                "RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
                metadata.getFields().size());
        writer.nextControlFlow("else");
        emitMigrationNeededException(writer, "\"Field count is more than expected - expected %d but was \" + columnCount)",
                metadata.getFields().size());
        writer.endControlFlow();
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)")
                .emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))")
                .endControlFlow()
                .emitEmptyLine();

        // create an instance of ColumnInfo
        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm, table)", columnInfoClassName())
                .emitEmptyLine();

        // verify primary key definition was not altered
        if (metadata.hasPrimaryKey()) {
            // the current model defines a PK, make sure it's defined in the Realm schema
            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
            writer.beginControlFlow("if (!table.hasPrimaryKey())");
            emitMigrationNeededException(writer, "\"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")",
                    metadata.getPrimaryKey().getSimpleName().toString());
            writer.nextControlFlow("else")
                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName);
            emitMigrationNeededException(writer, "\"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")",
                    metadata.getPrimaryKey().getSimpleName().toString());
            writer.endControlFlow()
                    .endControlFlow();
        } else {
            // the current model doesn't define a PK, make sure it's not defined in the Realm schema
            writer.beginControlFlow("if (table.hasPrimaryKey())");
            emitMigrationNeededException(writer, "\"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")");
            writer.endControlFlow();
        }
        writer.emitEmptyLine();

        // For each field verify there is a corresponding
        long fieldIndex = -1;
        for (VariableElement field : metadata.getFields()) {
            fieldIndex++;
            String fieldName = field.getSimpleName().toString();
            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
            } else if (Utils.isMutableRealmInteger(field)) {
                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
            } else if (Utils.isRealmModel(field)) { // Links
                emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
            } else if (Utils.isRealmList(field)) { // Link Lists
                emitValidateRealmListType(writer, field, fieldIndex, fieldName);
            }
        }

        // verify the backlinks
        Set<Backlink> backlinks = metadata.getBacklinkFields();
        if (backlinks.size() > 0) {
            writer.emitEmptyLine()
                    .emitStatement("long backlinkFieldIndex")
                    .emitStatement("Table backlinkSourceTable")
                    .emitStatement("Table backlinkTargetTable")
                    .emitStatement("RealmFieldType backlinkFieldType");
            for (Backlink backlink : metadata.getBacklinkFields()) {
                emitValidateBacklink(writer, backlink);
            }
        }

        writer.emitEmptyLine();
        writer.emitStatement("return %s", "columnInfo");

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
            throws IOException {

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", %s, \"%s\")",
                fieldName, getRealmTypeChecked(field).getRealmType(), Utils.getFieldTypeSimpleName(field));

        // make sure that nullability matches
        if (!metadata.isNullable(field)) {
            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        } else {
            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
            if (metadata.isPrimaryKey(field)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                        fieldName);
                // nullability check for boxed types
            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"Field '%s' does not support null values in the existing Realm file. " +
                                "Either set @Required, use the primitive type for field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' is required. Either set @Required to field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        }

        // Validate @Index
        if (metadata.getIndexedFields().contains(field)) {
            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
            writer.endControlFlow();
        }
    }

    private void emitValidateRealmModelType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
            throws IOException {
        String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.OBJECT, \"%s\")",
                fieldName, Utils.getFieldTypeSimpleName(field));
        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
        writer.endControlFlow();

        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                fieldIndexVariableReference(field), fieldIndex);
        emitMigrationNeededException(writer, "\"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                fieldName, fieldIndexVariableReference(field), fieldIndex);
        writer.endControlFlow();
    }

    private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
            throws IOException {

        String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);

        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.LIST, \"%s\")",
                fieldName, genericTypeSimpleName);

        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
        writer.endControlFlow();

        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                fieldIndexVariableReference(field), fieldIndex);
        emitMigrationNeededException(writer, "\"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                fieldName, fieldIndexVariableReference(field), fieldIndex);
        writer.endControlFlow();
    }

    private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws IOException {
        String targetField = backlink.getTargetField();
        String targetClass = backlink.getTargetClass();

        // Preceding code has already verified that the backlink field is not in the table.
        // If it were, either the column count would be wrong, or some field would be missing.

        // verify that the source class exists
        String sourceClass = backlink.getSimpleSourceClass();
        String fullyQualifiedSourceClass = backlink.getSourceClass();
        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, sourceClass);
        emitMigrationNeededException(writer, "\"Cannot find source class '%s' for @LinkingObjects field '%s.%s'\")",
                fullyQualifiedSourceClass, targetClass, targetField);
        writer.endControlFlow();

        // verify that the source class contains the source field
        String sourceField = backlink.getSourceField();
        writer.emitStatement("backlinkSourceTable = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, sourceClass);
        writer.emitStatement("backlinkFieldIndex = backlinkSourceTable.getColumnIndex(\"%s\")", sourceField);
        writer.beginControlFlow("if (backlinkFieldIndex == Table.NO_MATCH)");
        emitMigrationNeededException(writer, "\"Cannot find source field '%s.%s' for @LinkingObjects field '%s.%s'\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();

        // verify that the source field type is target class
        writer.emitStatement("backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex)");
        writer.beginControlFlow("if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST))");
        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' is not a RealmObject type\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();
        writer.emitStatement("backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex)");
        writer.beginControlFlow("if (!table.hasSameSchema(backlinkTargetTable))");
        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' has wrong type '\" + backlinkTargetTable.getName() + \"'\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();
    }

    //@formatter:off
    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
                .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
                .emitStatement("return FIELD_NAMES")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "copyOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
        );

        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null)")
                    .emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm()")
                    .beginControlFlow("if (otherRealm.threadId != realm.threadId)")
                        .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
                    .endControlFlow()

                    // If object is already in the Realm there is nothing to update
                    .beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
                        .emitStatement("return object")
                    .endControlFlow()
                .endControlFlow();


        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");

        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
                .beginControlFlow("if (cachedRealmObject != null)")
                    .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                .endControlFlow()
                .emitEmptyLine();

        if (!metadata.hasPrimaryKey()) {
            writer.emitStatement("return copy(realm, object, update, cache)");
        } else {
            writer
                    .emitStatement("%s realmObject = null", qualifiedClassName)
                    .emitStatement("boolean canUpdate = update")
                    .beginControlFlow("if (canUpdate)")
                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");

            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
            VariableElement primaryKeyElement = metadata.getPrimaryKey();
            if (metadata.isNullable(primaryKeyElement)) {
                if (Utils.isString(primaryKeyElement)) {
                    writer
                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (value == null)")
                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                            .nextControlFlow("else")
                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
                            .endControlFlow();
                } else {
                    writer
                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (value == null)")
                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                            .nextControlFlow("else")
                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
                            .endControlFlow();
                }
            } else {
                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
                        pkType, interfaceName, primaryKeyGetter);
            }

            writer
                    .beginControlFlow("if (rowIndex == Table.NO_MATCH)")
                        .emitStatement("canUpdate = false")
                    .nextControlFlow("else")
                        .beginControlFlow("try")
                            .emitStatement(
                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
                                qualifiedClassName)
                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                        .nextControlFlow("finally")
                            .emitStatement("objectContext.clear()")
                        .endControlFlow()
                    .endControlFlow();

            writer.endControlFlow();

            writer
                    .emitEmptyLine()
                       .emitStatement("return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache)");
        }

        writer.endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
        if ("long".equals(fieldType)
                || "int".equals(fieldType)
                || "short".equals(fieldType)
                || "byte".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Long".equals(fieldType)
                || "java.lang.Integer".equals(fieldType)
                || "java.lang.Short".equals(fieldType)
                || "java.lang.Byte".equals(fieldType)) {
            writer
                    .emitStatement("Number %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("io.realm.MutableRealmInteger".equals(fieldType)) {
            writer
                    .emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("double".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Double".equals(fieldType)) {
            writer
                    .emitStatement("Double %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("float".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Float".equals(fieldType)) {
            writer
                    .emitStatement("Float %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("boolean".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Boolean".equals(fieldType)) {
            writer
                    .emitStatement("Boolean %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("byte[]".equals(fieldType)) {
            writer
                    .emitStatement("byte[] %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();


        } else if ("java.util.Date".equals(fieldType)) {
            writer
                    .emitStatement("java.util.Date %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("java.lang.String".equals(fieldType)) {
            writer
                    .emitStatement("String %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();
        } else {
            throw new IllegalStateException("Unsupported type " + fieldType);
        }
    }
    //@formatter:on

    private void emitInsertMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "long", // Return type
                "insert", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        // If object is already in the Realm there is nothing to update
        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                .endControlFlow();

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        addPrimaryKeyCheckIfNeeded(metadata, true, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field),
                                fieldName)
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return rowIndex");
        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitInsertListMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "void", // Return type
                "insert", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        writer.emitStatement("%s object = null", qualifiedClassName);

        writer.beginControlFlow("while (objects.hasNext())")
                .emitStatement("object = (%s) objects.next()", qualifiedClassName);
        writer.beginControlFlow("if (cache.containsKey(object))")
                .emitStatement("continue")
                .endControlFlow();

        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                .emitStatement("continue");
        writer.endControlFlow();

        addPrimaryKeyCheckIfNeeded(metadata, true, writer);

        //@formatter:off
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field),
                                fieldName)
                        .endControlFlow()
                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
                }
            }
        }
        //@formatter:on

        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "long", // Return type
                "insertOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        // If object is already in the Realm there is nothing to update
        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                .endControlFlow();

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        addPrimaryKeyCheckIfNeeded(metadata, false, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .nextControlFlow("else")
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return rowIndex");

        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "void", // Return type
                "insertOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        writer.emitStatement("%s object = null", qualifiedClassName);

        writer.beginControlFlow("while (objects.hasNext())");
        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
        writer.beginControlFlow("if (cache.containsKey(object))")
                .emitStatement("continue")
                .endControlFlow();

        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                .emitStatement("continue");
        writer.endControlFlow();
        addPrimaryKeyCheckIfNeeded(metadata, false, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .nextControlFlow("else")
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
                }
            }
            //@formatter:on
        }
        writer.endControlFlow();

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfPrimaryKeyDuplicate, JavaWriter writer) throws IOException {
        if (metadata.hasPrimaryKey()) {
            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
            VariableElement primaryKeyElement = metadata.getPrimaryKey();
            if (metadata.isNullable(primaryKeyElement)) {
                //@formatter:off
                if (Utils.isString(primaryKeyElement)) {
                    writer
                            .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (primaryKeyValue == null)")
                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                            .nextControlFlow("else")
                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
                            .endControlFlow();
                } else {
                    writer
                            .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (primaryKeyValue == null)")
                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                            .nextControlFlow("else")
                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
                            .endControlFlow();
                }
                //@formatter:on
            } else {
                writer.emitStatement("long rowIndex = Table.NO_MATCH");
                writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
                writer.beginControlFlow("if (primaryKeyValue != null)");

                if (Utils.isString(metadata.getPrimaryKey())) {
                    writer.emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)");
                } else {
                    writer.emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
                }
                writer.endControlFlow();
            }

            writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
            if (Utils.isString(metadata.getPrimaryKey())) {
                writer.emitStatement(
                        "rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue)");
            } else {
                writer.emitStatement(
                        "rowIndex = OsObject.createRowWithPrimaryKey(table, ((%s) object).%s())",
                        interfaceName, primaryKeyGetter);
            }

            if (throwIfPrimaryKeyDuplicate) {
                writer.nextControlFlow("else");
                writer.emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)");
            }

            writer.endControlFlow();
            writer.emitStatement("cache.put(object, rowIndex)");
        } else {
            writer.emitStatement("long rowIndex = OsObject.createRow(table)");
            writer.emitStatement("cache.put(object, rowIndex)");
        }
    }

    private void emitCopyMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "copy", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name

        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
        writer.beginControlFlow("if (cachedRealmObject != null)")
                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                .endControlFlow();


        writer.emitEmptyLine()
                .emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
                    qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
        } else {
            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
                    qualifiedClassName, qualifiedClassName);
        }
        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");

        writer.emitEmptyLine()
                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
                .emitStatement("%1$s realmObjectCopy = (%1$s) realmObject", interfaceName);

        writer.emitEmptyLine();
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);

            if (metadata.isPrimaryKey(field)) {
                // PK has been set when creating object.
                continue;
            }

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer.emitEmptyLine()
                        .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
                        .beginControlFlow("if (%sObj == null)", fieldName)
                            .emitStatement("realmObjectCopy.%s(null)", setter)
                        .nextControlFlow("else")
                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                            .beginControlFlow("if (cache%s != null)", fieldName)
                                .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
                            .nextControlFlow("else")
                                .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
                                    setter, Utils.getProxyClassSimpleName(field), fieldName)
                            .endControlFlow()
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer.emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                            .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
                                genericType, fieldName, getter)
                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                                .beginControlFlow("if (cache%s != null)", fieldName)
                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
                                .nextControlFlow("else")
                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, update, cache))",
                                        fieldName, Utils.getProxyClassSimpleName(field))
                                .endControlFlow()
                            .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitEmptyLine()
                        .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
            } else {
                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
            }
            //@formatter:on
        }

        writer.emitStatement("return realmObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    //@formatter:off
    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "createDetachedCopy", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
        writer
                .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                .emitStatement("return null")
                .endControlFlow()
                .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
                .emitStatement("%s unmanagedObject", qualifiedClassName)
                .beginControlFlow("if (cachedObject == null)")
                .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
                .nextControlFlow("else")
                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
                .emitStatement("return (%s) cachedObject.object", qualifiedClassName)
                .endControlFlow()
                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedClassName)
                .emitStatement("cachedObject.minDepth = currentDepth")
                .endControlFlow();

        // may cause an unused variable warning if the object contains only null lists
        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName)
            .emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);

            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitSingleLineComment("Deep copy of %s", fieldName)
                        .emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))",
                                setter, Utils.getProxyClassSimpleName(field), getter);
            } else if (Utils.isRealmList(field)) {
                writer
                        .emitEmptyLine()
                        .emitSingleLineComment("Deep copy of %s", fieldName)
                        .beginControlFlow("if (currentDepth == maxDepth)")
                        .emitStatement("unmanagedCopy.%s(null)", setter)
                        .nextControlFlow("else")
                        .emitStatement("RealmList<%s> managed%sList = realmSource.%s()",
                                Utils.getGenericTypeQualifiedName(field), fieldName, getter)
                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
                        .emitStatement("unmanagedCopy.%s(unmanaged%sList)", setter, fieldName)
                        .emitStatement("int nextDepth = currentDepth + 1")
                        .emitStatement("int size = managed%sList.size()", fieldName)
                        .beginControlFlow("for (int i = 0; i < size; i++)")
                        .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
                                Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
                        .emitStatement("unmanaged%sList.add(item)", fieldName)
                        .endControlFlow()
                        .endControlFlow();
            } else if (Utils.isMutableRealmInteger(field)) {
                // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
                writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
            } else {
                writer.emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter);
            }
        }

        writer.emitStatement("return unmanagedObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }
    //@formatter:on

    private void emitUpdateMethod(JavaWriter writer) throws IOException {
        if (!metadata.hasPrimaryKey()) {
            return;
        }

        writer.beginMethod(
                qualifiedClassName, // Return type
                "update", // Method name
                EnumSet.of(Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name

        writer
                .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);
            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitStatement("%s %sObj = realmObjectSource.%s()",
                                Utils.getFieldTypeQualifiedName(field), fieldName, getter)
                        .beginControlFlow("if (%sObj == null)", fieldName)
                        .emitStatement("realmObjectTarget.%s(null)", setter)
                        .nextControlFlow("else")
                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sObj)",
                                Utils.getFieldTypeQualifiedName(field), fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                        .emitStatement("realmObjectTarget.%s(cache%s)", setter, fieldName)
                        .nextControlFlow("else")
                        .emitStatement("realmObjectTarget.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
                                setter, Utils.getProxyClassSimpleName(field), fieldName)
                        .endControlFlow()
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                        .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()",
                                genericType, fieldName, getter)
                        .emitStatement("%sRealmList.clear()", fieldName)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                        .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                        .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
                        .nextControlFlow("else")
                        .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))",
                                fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .endControlFlow()
                        .endControlFlow();

            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
            } else {
                if (field != metadata.getPrimaryKey()) {
                    writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return realmObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitToStringMethod(JavaWriter writer) throws IOException {
        if (metadata.containsToString()) {
            return;
        }
        writer.emitAnnotation("Override");
        writer.emitAnnotation("SuppressWarnings", "\"ArrayToString\"")
                .beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC))
                .beginControlFlow("if (!RealmObject.isValid(this))")
                .emitStatement("return \"Invalid object\"")
                .endControlFlow();
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleClassName);

        Collection<VariableElement> fields = metadata.getFields();
        int i = fields.size() - 1;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();

            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            if (Utils.isRealmModel(field)) {
                String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                writer.emitStatement(
                        "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
                        metadata.getInternalGetter(fieldName),
                        fieldTypeSimpleName
                );
            } else if (Utils.isRealmList(field)) {
                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                        genericTypeSimpleName,
                        metadata.getInternalGetter(fieldName));
            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName));
            } else {
                if (metadata.isNullable(field)) {
                    writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
                            metadata.getInternalGetter(fieldName),
                            metadata.getInternalGetter(fieldName)
                    );
                } else {
                    writer.emitStatement("stringBuilder.append(%s())", metadata.getInternalGetter(fieldName));
                }
            }
            writer.emitStatement("stringBuilder.append(\"}\")");

            if (i-- > 0) {
                writer.emitStatement("stringBuilder.append(\",\")");
            }
        }

        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod()
                .emitEmptyLine();
    }

    /**
     * Currently, the hash value emitted from this could suddenly change as an object's index might
     * alternate due to Realm Java using {@code Table#moveLastOver()}. Hash codes should therefore not
     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
     */
    //@formatter:off
    private void emitHashcodeMethod(JavaWriter writer) throws IOException {
        if (metadata.containsHashCode()) {
            return;
        }
        writer.emitAnnotation("Override")
                .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
                .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
                .emitEmptyLine()
                .emitStatement("int result = 17")
                .emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)")
                .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
                .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
                .emitStatement("return result")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitEqualsMethod(JavaWriter writer) throws IOException {
        if (metadata.containsEquals()) {
            return;
        }
        String proxyClassName = Utils.getProxyClassName(simpleClassName);
        String otherObjectVarName = "a" + simpleClassName;
        writer.emitAnnotation("Override")
                .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
                .emitStatement("if (this == o) return true")
                .emitStatement("if (o == null || getClass() != o.getClass()) return false")
                .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
                .emitEmptyLine()
                .emitStatement("String path = proxyState.getRealm$realm().getPath()")
                .emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName)
                .emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false")
                .emitEmptyLine()
                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                .emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName)
                .emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false")
                .emitEmptyLine()
                .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
                .emitEmptyLine()
                .emitStatement("return true")
                .endMethod();
    }
    //@formatter:on

    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.beginMethod(
                qualifiedClassName,
                "createOrUpdateUsingJsonObject",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                Collections.singletonList("JSONException"));

        final int modelOrListCount = countModelOrListFields(metadata.getFields());
        if (modelOrListCount == 0) {
            writer.emitStatement("final List<String> excludeFields = Collections.<String> emptyList()");
        } else {
            writer.emitStatement("final List<String> excludeFields = new ArrayList<String>(%1$d)",
                    modelOrListCount);
        }

        //@formatter:off
        if (!metadata.hasPrimaryKey()) {
            buildExcludeFieldsList(writer, metadata.getFields());
            writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
                    qualifiedClassName, qualifiedClassName);
        } else {
            String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
            writer
                .emitStatement("%s obj = null", qualifiedClassName)
                .beginControlFlow("if (update)")
                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                    .emitStatement("long rowIndex = Table.NO_MATCH");
            if (metadata.isNullable(metadata.getPrimaryKey())) {
                writer
                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                        .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                    .nextControlFlow("else")
                        .emitStatement(
                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                    .endControlFlow();
            } else {
                writer
                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                        .emitStatement(
                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                    .endControlFlow();
            }
            writer
                .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
                    .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
                    .beginControlFlow("try")
                        .emitStatement(
                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
                                qualifiedClassName)
                        .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
                    .nextControlFlow("finally")
                        .emitStatement("objectContext.clear()")
                    .endControlFlow()
                .endControlFlow()
            .endControlFlow();

            writer.beginControlFlow("if (obj == null)");
            buildExcludeFieldsList(writer, metadata.getFields());
            String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
            String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
                    qualifiedClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
            writer.endControlFlow();
        }
        //@formatter:on

        writer
                .emitEmptyLine()
                .emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            if (metadata.isPrimaryKey(field)) {
                // Primary key has already been set when adding new row or finding the existing row.
                continue;
            }
            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer);

            } else {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.emitStatement("return obj");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void buildExcludeFieldsList(JavaWriter writer, Collection<VariableElement> fields) throws IOException {
        for (VariableElement field : fields) {
            if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
                final String fieldName = field.getSimpleName().toString();
                writer.beginControlFlow("if (json.has(\"%1$s\"))", fieldName)
                        .emitStatement("excludeFields.add(\"%1$s\")", fieldName)
                        .endControlFlow();
            }
        }
    }

    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
    // instead of createObject() to avoid parsing the stream twice.
    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
        writer.beginMethod(
                qualifiedClassName,
                "createUsingJsonStream",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                Collections.singletonList("IOException"));

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("boolean jsonHasPrimaryKey = false");
        }
        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        writer.emitStatement("reader.beginObject()");
        writer.beginControlFlow("while (reader.hasNext())");
        writer.emitStatement("String name = reader.nextName()");
        writer.beginControlFlow("if (false)");
        Collection<VariableElement> fields = metadata.getFields();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);

            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListFromStream(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            } else {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.nextControlFlow("else");
        writer.emitStatement("reader.skipValue()");
        writer.endControlFlow();

        writer.endControlFlow();
        writer.emitStatement("reader.endObject()");

        if (metadata.hasPrimaryKey()) {
            writer.beginControlFlow("if (!jsonHasPrimaryKey)")
                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey())
                    .endControlFlow();
        }

        writer.emitStatement("return realm.copyToRealm(obj)");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitMigrationNeededException(JavaWriter writer, String message, Object... args) throws IOException {
        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), " + message, args);
    }

    private String columnInfoClassName() {
        return simpleClassName + "ColumnInfo";
    }

    private String columnIndexVarName(VariableElement variableElement) {
        return variableElement.getSimpleName().toString() + "Index";
    }

    private String mutableRealmIntegerFieldName(VariableElement variableElement) {
        return variableElement.getSimpleName().toString() + "MutableRealmInteger";
    }

    private String fieldIndexVariableReference(VariableElement variableElement) {
        return "columnInfo." + columnIndexVarName(variableElement);
    }

    private static int countModelOrListFields(Collection<VariableElement> fields) {
        int count = 0;
        for (VariableElement f : fields) {
            if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
                count++;
            }
        }
        return count;
    }

    private Constants.RealmFieldType getRealmType(VariableElement field) {
        String fieldTypeCanonicalName = field.asType().toString();
        Constants.RealmFieldType type = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
        if (type != null) {
            return type;
        }
        if (Utils.isMutableRealmInteger(field)) {
            return Constants.RealmFieldType.REALM_INTEGER;
        }
        if (Utils.isRealmModel(field)) {
            return Constants.RealmFieldType.OBJECT;
        }
        if (Utils.isRealmList(field)) {
            return Constants.RealmFieldType.LIST;
        }
        return Constants.RealmFieldType.NOTYPE;
    }

    private Constants.RealmFieldType getRealmTypeChecked(VariableElement field) {
        Constants.RealmFieldType type = getRealmType(field);
        if (type == Constants.RealmFieldType.NOTYPE) {
            throw new IllegalStateException("Unsupported type " + field.asType().toString());
        }
        return type;
    }
}
!@#$%
20190526_211226,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c11336
/*
 * Copyright 2014 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm.processor;

import com.squareup.javawriter.JavaWriter;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.util.Types;
import javax.tools.JavaFileObject;


public class RealmProxyClassGenerator {
    private static final String OPTION_SUPPRESS_WARNINGS = "realm.suppressWarnings";
    private static final String BACKLINKS_FIELD_EXTENSION = "Backlinks";

    private static final List<String> IMPORTS;
    static {
        List<String> l = Arrays.asList(
            "android.annotation.TargetApi",
            "android.os.Build",
            "android.util.JsonReader",
            "android.util.JsonToken",
            "io.realm.exceptions.RealmMigrationNeededException",
            "io.realm.internal.ColumnInfo",
            "io.realm.internal.LinkView",
            "io.realm.internal.OsObject",
            "io.realm.internal.OsObjectSchemaInfo",
            "io.realm.internal.Property",
            "io.realm.internal.ProxyUtils",
            "io.realm.internal.RealmObjectProxy",
            "io.realm.internal.Row",
            "io.realm.internal.SharedRealm",
            "io.realm.internal.Table",
            "io.realm.internal.android.JsonUtils",
            "io.realm.log.RealmLog",
            "java.io.IOException",
            "java.util.ArrayList",
            "java.util.Collections",
            "java.util.List",
            "java.util.Iterator",
            "java.util.Date",
            "java.util.Map",
            "java.util.HashMap",
            "org.json.JSONObject",
            "org.json.JSONException",
            "org.json.JSONArray");
        IMPORTS = Collections.unmodifiableList(l);
    }

    private final ProcessingEnvironment processingEnvironment;
    private final ClassMetaData metadata;
    private final String simpleClassName;
    private final String qualifiedClassName;
    private final String interfaceName;
    private final String qualifiedGeneratedClassName;
    private final boolean suppressWarnings;

    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
        this.processingEnvironment = processingEnvironment;
        this.metadata = metadata;
        this.simpleClassName = metadata.getSimpleClassName();
        this.qualifiedClassName = metadata.getFullyQualifiedClassName();
        this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
        this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));

        // See the configuration for the debug build type,
        //  in the realm-library project, for an example of how to set this flag.
        this.suppressWarnings = !"false".equalsIgnoreCase(processingEnvironment.getOptions().get(OPTION_SUPPRESS_WARNINGS));
    }

    public void generate() throws IOException, UnsupportedOperationException {
        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));

        // Set source code indent
        writer.setIndent(Constants.INDENT);

        writer.emitPackage(Constants.REALM_PACKAGE_NAME)
                .emitEmptyLine();

        List<String> imports = new ArrayList<String>(IMPORTS);
        if (!metadata.getBacklinkFields().isEmpty()) {
            imports.add("io.realm.internal.UncheckedRow");
        }
        writer.emitImports(imports)
                .emitEmptyLine();

        // Begin the class definition
        if (suppressWarnings) {
            writer.emitAnnotation("SuppressWarnings(\"all\")");
        }
        writer
                .beginType(
                qualifiedGeneratedClassName, // full qualified name of the item to generate
                "class",                     // the type of the item
                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
                qualifiedClassName,          // class to extend
                "RealmObjectProxy",          // interfaces to implement
                interfaceName)
                .emitEmptyLine();

        emitColumnInfoClass(writer);

        emitClassFields(writer);

        emitInstanceFields(writer);
        emitConstructor(writer);

        emitInjectContextMethod(writer);
        emitPersistedFieldAccessors(writer);
        emitBacklinkFieldAccessors(writer);
        emitCreateExpectedObjectSchemaInfo(writer);
        emitGetExpectedObjectSchemaInfo(writer);
        emitValidateTableMethod(writer);
        emitGetTableNameMethod(writer);
        emitGetFieldNamesMethod(writer);
        emitCreateOrUpdateUsingJsonObject(writer);
        emitCreateUsingJsonStream(writer);
        emitCopyOrUpdateMethod(writer);
        emitCopyMethod(writer);
        emitInsertMethod(writer);
        emitInsertListMethod(writer);
        emitInsertOrUpdateMethod(writer);
        emitInsertOrUpdateListMethod(writer);
        emitCreateDetachedCopyMethod(writer);
        emitUpdateMethod(writer);
        emitToStringMethod(writer);
        emitRealmObjectProxyImplementation(writer);
        emitHashcodeMethod(writer);
        emitEqualsMethod(writer);

        // End the class definition
        writer.endType();
        writer.close();
    }

    private void emitColumnInfoClass(JavaWriter writer) throws IOException {
        writer.beginType(
                columnInfoClassName(),                       // full qualified name of the item to generate
                "class",                                     // the type of the item
                EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
                "ColumnInfo");                               // base class

        // fields
        for (VariableElement variableElement : metadata.getFields()) {
            writer.emitField("long", columnIndexVarName(variableElement));
        }
        writer.emitEmptyLine();

        // constructor #1
        writer.beginConstructor(
                EnumSet.noneOf(Modifier.class),
                "SharedRealm", "realm", "Table", "table");
        writer.emitStatement("super(%s)", metadata.getFields().size());
        for (VariableElement field : metadata.getFields()) {
            writer.emitStatement(
                    "this.%1$sIndex = addColumnDetails(table, \"%1$s\", %2$s)",
                    field.getSimpleName().toString(), getRealmTypeChecked(field).getRealmType());
        }
        for (Backlink backlink : metadata.getBacklinkFields()) {
            writer.emitStatement(
                    "addBacklinkDetails(realm, \"%s\", \"%s\", \"%s\")",
                    backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
        }
        writer.endConstructor()
                .emitEmptyLine();

        // constructor #2
        writer.beginConstructor(
                EnumSet.noneOf(Modifier.class),
                "ColumnInfo", "src", "boolean", "mutable");
        writer.emitStatement("super(src, mutable)")
                .emitStatement("copy(src, this)");
        writer.endConstructor()
                .emitEmptyLine();

        // no-args copy method
        writer.emitAnnotation("Override")
                .beginMethod(
                        "ColumnInfo",                                   // return type
                        "copy",                                         // method name
                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), // modifiers
                        "boolean", "mutable");     // parameters
        writer.emitStatement("return new %s(this, mutable)", columnInfoClassName());
        writer.endMethod()
                .emitEmptyLine();

        // copy method
        writer.emitAnnotation("Override")
                .beginMethod(
                        "void",                                          // return type
                        "copy",                                          // method name
                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL),  // modifiers
                        "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst"); // parameters
        writer.emitStatement("final %1$s src = (%1$s) rawSrc", columnInfoClassName());
        writer.emitStatement("final %1$s dst = (%1$s) rawDst", columnInfoClassName());
        for (VariableElement variableElement : metadata.getFields()) {
            writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
        }
        writer.endMethod();

        writer.endType();
    }

    //@formatter:off
    private void emitClassFields(JavaWriter writer) throws IOException {
        writer.emitEmptyLine()
                .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");

        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
        writer.beginInitializer(true)
            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
            for (VariableElement field : metadata.getFields()) {
                writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
            }
        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
            .endInitializer();
    }
    //@formatter:on

    //@formatter:off
    private void emitInstanceFields(JavaWriter writer) throws IOException {
        writer.emitEmptyLine()
                .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));

        for (VariableElement variableElement : metadata.getFields()) {
            if (Utils.isMutableRealmInteger(variableElement)) {
                emitMutableRealmIntegerField(writer, variableElement);
            } else if (Utils.isRealmList(variableElement)) {
                String genericType = Utils.getGenericTypeQualifiedName(variableElement);
                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
            }
        }

        for (Backlink backlink : metadata.getBacklinkFields()) {
            writer.emitField(backlink.getTargetFieldType(), backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
                    EnumSet.of(Modifier.PRIVATE));
        }
    }
    //@formatter:on

    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
    // the MutableInteger that it owns, also becomes unreachable.
    //@formatter:off
    private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement variableElement) throws IOException{
        writer.emitField("MutableRealmInteger.Managed",
                mutableRealmIntegerFieldName(variableElement),
                EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
                String.format(
                        "new MutableRealmInteger.Managed<%1$s>() {\n"
                                + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
                                + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
                                + "}",
                        qualifiedClassName, columnIndexVarName(variableElement)));
    }
    //@formatter:on

    //@formatter:off
    private void emitConstructor(JavaWriter writer) throws IOException {
        // FooRealmProxy(ColumnInfo)
        writer.emitEmptyLine()
                .beginConstructor(EnumSet.noneOf(Modifier.class))
                .emitStatement("proxyState.setConstructionFinished()")
                .endConstructor()
                .emitEmptyLine();
    }
    //@formatter:on

    private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOException {
        for (final VariableElement field : metadata.getFields()) {
            final String fieldName = field.getSimpleName().toString();
            final String fieldTypeCanonicalName = field.asType().toString();

            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isMutableRealmInteger(field)) {
                emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isRealmModel(field)) {
                emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
            } else if (Utils.isRealmList(field)) {
                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
            } else {
                throw new UnsupportedOperationException(String.format(Locale.US,
                        "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
            }

            writer.emitEmptyLine();
        }
    }

    /**
     * Primitives and boxed types
     */
    private void emitPrimitiveType(
            JavaWriter writer,
            final VariableElement field,
            final String fieldName,
            String fieldTypeCanonicalName) throws IOException {

        final String fieldJavaType = getRealmTypeChecked(field).getJavaType();

        // Getter
        //@formatter:off
        writer.emitAnnotation("Override");
        writer.emitAnnotation("SuppressWarnings", "\"cast\"")
                .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()");

        // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
        if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
            writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
                    .emitStatement("return null")
                    .endControlFlow();
        }
        //@formatter:on

        // For Boxed types, this should be the corresponding primitive types. Others remain the same.
        String castingBackType;
        if (Utils.isBoxedType(fieldTypeCanonicalName)) {
            Types typeUtils = processingEnvironment.getTypeUtils();
            castingBackType = typeUtils.unboxedType(field.asType()).toString();
        } else {
            castingBackType = fieldTypeCanonicalName;
        }
        writer.emitStatement(
                "return (%s) proxyState.getRow$realm().get%s(%s)",
                castingBackType, fieldJavaType, fieldIndexVariableReference(field));
        writer.endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // set value as default value
                writer.emitStatement("final Row row = proxyState.getRow$realm()");

                //@formatter:off
                if (metadata.isNullable(field)) {
                    writer.beginControlFlow("if (value == null)")
                            .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
                                    fieldIndexVariableReference(field))
                            .emitStatement("return")
                            .endControlFlow();
                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                    writer.beginControlFlow("if (value == null)")
                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
                            .endControlFlow();
                }
                //@formatter:on

                writer.emitStatement(
                        "row.getTable().set%s(%s, row.getIndex(), value, true)",
                        fieldJavaType, fieldIndexVariableReference(field));
                writer.emitStatement("return");
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
        // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
        // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
        if (metadata.isPrimaryKey(field)) {
            // Primary key is not allowed to be changed after object created.
            writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
        } else {
            //@formatter:off
            if (metadata.isNullable(field)) {
                writer.beginControlFlow("if (value == null)")
                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
                        .emitStatement("return")
                        .endControlFlow();
            } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                // Same reason, throw IAE earlier.
                writer
                        .beginControlFlow("if (value == null)")
                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
                        .endControlFlow();
            }
            //@formatter:on
            writer.emitStatement(
                    "proxyState.getRow$realm().set%s(%s, value)",
                    fieldJavaType, fieldIndexVariableReference(field));
        }
        writer.endMethod();
    }

    //@formatter:off
    private void emitMutableRealmInteger(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeCanonicalName) throws IOException {
        writer.emitAnnotation("Override")
            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
            .endMethod();
    }
    //@formatter:on

    /**
     * Links
     */
    //@formatter:off
    private void emitRealmModel(
            JavaWriter writer,
            final VariableElement field,
            String fieldName,
            String fieldTypeCanonicalName) throws IOException {

        // Getter
        writer.emitAnnotation("Override");
        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
                .emitStatement("return null")
                .endControlFlow()
                .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
                        fieldTypeCanonicalName, fieldIndexVariableReference(field))
                .endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // check excludeFields
                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
                        field.getSimpleName().toString())
                        .emitStatement("return")
                        .endControlFlow();
                writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
                        .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
                        .endControlFlow();

                // set value as default value
                writer.emitStatement("final Row row = proxyState.getRow$realm()");
                writer.beginControlFlow("if (value == null)")
                        .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
                        .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
                        .emitStatement("return")
                        .endControlFlow();
                writer.beginControlFlow("if (!RealmObject.isValid(value))")
                        .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
                        .endControlFlow();
                writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                        .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                        .endControlFlow();
                writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
                        fieldIndexVariableReference(field));
                writer.emitStatement("return");
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .beginControlFlow("if (value == null)")
                .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
                .emitStatement("return")
                .endControlFlow()
                .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
                .endControlFlow()
                .beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
                .endControlFlow()
                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
                .endMethod();
    }
    //@formatter:on

    /**
     * LinkLists
     */
    //@formatter:off
    private void emitRealmList(
            JavaWriter writer,
            final VariableElement field,
            String fieldName,
            String fieldTypeCanonicalName) throws IOException {
        String genericType = Utils.getGenericTypeQualifiedName(field);

        // Getter
        writer.emitAnnotation("Override");
        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitSingleLineComment("use the cached value if available")
                .beginControlFlow("if (" + fieldName + "RealmList != null)")
                .emitStatement("return " + fieldName + "RealmList")
                .nextControlFlow("else")
                .emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
                        genericType, genericType)
                .emitStatement("return " + fieldName + "RealmList")
                .endControlFlow()
                .endMethod()
                .emitEmptyLine();

        // Setter
        writer.emitAnnotation("Override");
        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
            @Override
            public void emit(JavaWriter writer) throws IOException {
                // check excludeFields
                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
                        field.getSimpleName().toString())
                        .emitStatement("return")
                        .endControlFlow();
                final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
                writer.beginControlFlow("if (value != null && !value.isManaged())")
                        .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
                        .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
                        .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
                        .beginControlFlow("for (%1$s item : original)", modelFqcn)
                        .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
                        .emitStatement("value.add(item)")
                        .nextControlFlow("else")
                        .emitStatement("value.add(realm.copyToRealm(item))")
                        .endControlFlow()
                        .endControlFlow()
                        .endControlFlow();

                // LinkView currently does not support default value feature. Just fallback to normal code.
            }
        });
        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
                .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
                .emitStatement("links.clear()")
                .beginControlFlow("if (value == null)")
                .emitStatement("return")
                .endControlFlow()
                .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
                .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
                .endControlFlow()
                .beginControlFlow("if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
                .endControlFlow()
                .emitStatement("links.add(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
                .endControlFlow()
                .endMethod();
    }
    //@formatter:on

    private interface CodeEmitter {
        void emit(JavaWriter writer) throws IOException;
    }

    private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKey,
            CodeEmitter defaultValueCodeEmitter) throws IOException {
        writer.beginControlFlow("if (proxyState.isUnderConstruction())");
        if (isPrimaryKey) {
            writer.emitSingleLineComment("default value of the primary key is always ignored.")
                    .emitStatement("return");
        } else {
            writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
                    .emitStatement("return")
                    .endControlFlow();
            defaultValueCodeEmitter.emit(writer);
        }
        writer.endControlFlow()
                .emitEmptyLine();
    }

    // Note that because of bytecode hackery, this method may run before the constructor!
    // It may even run before fields have been initialized.
    //@formatter:off
    private void emitInjectContextMethod(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override");
        writer.beginMethod(
                "void", // Return type
                "realm$injectObjectContext", // Method name
                EnumSet.of(Modifier.PUBLIC) // Modifiers
        ); // Argument type & argument name

        writer.beginControlFlow("if (this.proxyState != null)")
                .emitStatement("return")
                .endControlFlow()
                .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
                .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
                .emitStatement("proxyState.setRealm$realm(context.getRealm())")
                .emitStatement("proxyState.setRow$realm(context.getRow())")
                .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
        for (Backlink backlink : metadata.getBacklinkFields()) {
            String cacheFieldName = backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION;
            String realmResultsType = "RealmResults<" + backlink.getSourceClass() + ">";

            // Getter, no setter
            writer.emitAnnotation("Override");
            writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
                    .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
                    .emitStatement("realm.checkIfValid()")
                    .emitStatement("proxyState.getRow$realm().checkIfAttached()")
                    .beginControlFlow("if (" + cacheFieldName + " == null)")
                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
                            backlink.getSourceClass(), backlink.getSourceField())
                    .endControlFlow()
                    .emitStatement("return " + cacheFieldName)
                    .endMethod()
                    .emitEmptyLine();
        }
    }
    //@formatter:on

    //@formatter:off
    private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
        writer.emitAnnotation("Override")
                .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
                .emitStatement("return proxyState")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "createExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers

        writer.emitStatement(
                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\")", this.simpleClassName);

        // For each field generate corresponding table index constant
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();

            Constants.RealmFieldType fieldType = getRealmType(field);
            switch (fieldType) {
                case NOTYPE:
                    // Perhaps this should fail quickly?
                    break;

                case OBJECT:
                    String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
                            fieldName, fieldTypeSimpleName);
                    break;

                case LIST:
                    String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                    writer.emitStatement("builder.addLinkedProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
                            fieldName, genericTypeSimpleName);
                    break;

                default:
                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
                    writer.emitStatement("builder.addProperty(\"%s\", %s, %s, %s, %s)",
                            fieldName,
                            fieldType.getRealmType(),
                            primaryKeyFlag,
                            indexedFlag,
                            nullableFlag);
            }
        }
        writer.emitStatement("return builder.build()");
        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "OsObjectSchemaInfo", // Return type
                "getExpectedObjectSchemaInfo", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers

        writer.emitStatement("return expectedObjectSchemaInfo");

        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                columnInfoClassName(),        // Return type
                "validateTable",              // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "SharedRealm", "sharedRealm", // Argument type & argument name
                "boolean", "allowExtraColumns");

        writer.beginControlFlow(
                "if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
        emitMigrationNeededException(writer, "\"The '%s' class is missing from the schema for this Realm.\")",
                metadata.getSimpleClassName());
        writer.endControlFlow();

        writer.emitStatement(
                "Table table = sharedRealm.getTable(\"%s%s\")",
                Constants.TABLE_PREFIX,
                this.simpleClassName);

        // verify number of columns
        writer.emitStatement("final long columnCount = table.getColumnCount()");
        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
        writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
        emitMigrationNeededException(writer, "\"Field count is less than expected - expected %d but was \" + columnCount)",
                metadata.getFields().size());
        writer.endControlFlow();
        writer.beginControlFlow("if (allowExtraColumns)");
        writer.emitStatement(
                "RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
                metadata.getFields().size());
        writer.nextControlFlow("else");
        emitMigrationNeededException(writer, "\"Field count is more than expected - expected %d but was \" + columnCount)",
                metadata.getFields().size());
        writer.endControlFlow();
        writer.endControlFlow();

        // create type dictionary for lookup
        writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)")
                .emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))")
                .endControlFlow()
                .emitEmptyLine();

        // create an instance of ColumnInfo
        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm, table)", columnInfoClassName())
                .emitEmptyLine();

        // verify primary key definition was not altered
        if (metadata.hasPrimaryKey()) {
            // the current model defines a PK, make sure it's defined in the Realm schema
            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
            writer.beginControlFlow("if (!table.hasPrimaryKey())");
            emitMigrationNeededException(writer, "\"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")",
                    metadata.getPrimaryKey().getSimpleName().toString());
            writer.nextControlFlow("else")
                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName);
            emitMigrationNeededException(writer, "\"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")",
                    metadata.getPrimaryKey().getSimpleName().toString());
            writer.endControlFlow()
                    .endControlFlow();
        } else {
            // the current model doesn't define a PK, make sure it's not defined in the Realm schema
            writer.beginControlFlow("if (table.hasPrimaryKey())");
            emitMigrationNeededException(writer, "\"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")");
            writer.endControlFlow();
        }
        writer.emitEmptyLine();

        // For each field verify there is a corresponding
        long fieldIndex = -1;
        for (VariableElement field : metadata.getFields()) {
            fieldIndex++;
            String fieldName = field.getSimpleName().toString();
            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
            } else if (Utils.isMutableRealmInteger(field)) {
                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
            } else if (Utils.isRealmModel(field)) { // Links
                emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
            } else if (Utils.isRealmList(field)) { // Link Lists
                emitValidateRealmListType(writer, field, fieldIndex, fieldName);
            }
        }

        // verify the backlinks
        Set<Backlink> backlinks = metadata.getBacklinkFields();
        if (backlinks.size() > 0) {
            writer.emitEmptyLine()
                    .emitStatement("long backlinkFieldIndex")
                    .emitStatement("Table backlinkSourceTable")
                    .emitStatement("Table backlinkTargetTable")
                    .emitStatement("RealmFieldType backlinkFieldType");
            for (Backlink backlink : metadata.getBacklinkFields()) {
                emitValidateBacklink(writer, backlink);
            }
        }

        writer.emitEmptyLine();
        writer.emitStatement("return %s", "columnInfo");

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
            throws IOException {

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", %s, \"%s\")",
                fieldName, getRealmTypeChecked(field).getRealmType(), Utils.getFieldTypeSimpleName(field));

        // make sure that nullability matches
        if (!metadata.isNullable(field)) {
            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' does support null values in the existing Realm file. " +
                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        } else {
            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
            if (metadata.isPrimaryKey(field)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                        fieldName);
                // nullability check for boxed types
            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                "\"Field '%s' does not support null values in the existing Realm file. " +
                                "Either set @Required, use the primitive type for field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            } else {
                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                " \"Field '%s' is required. Either set @Required to field '%s' " +
                                "or migrate using RealmObjectSchema.setNullable().\")",
                        fieldName, fieldName);
            }
            writer.endControlFlow();
        }

        // Validate @Index
        if (metadata.getIndexedFields().contains(field)) {
            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
            writer.endControlFlow();
        }
    }

    private void emitValidateRealmModelType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
            throws IOException {
        String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);

        // make field sure types align
        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.OBJECT, \"%s\")",
                fieldName, Utils.getFieldTypeSimpleName(field));
        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
        writer.endControlFlow();

        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                fieldIndexVariableReference(field), fieldIndex);
        emitMigrationNeededException(writer, "\"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                fieldName, fieldIndexVariableReference(field), fieldIndex);
        writer.endControlFlow();
    }

    private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
            throws IOException {

        String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);

        writer.emitStatement(
                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.LIST, \"%s\")",
                fieldName, genericTypeSimpleName);

        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
        writer.endControlFlow();

        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                fieldIndexVariableReference(field), fieldIndex);
        emitMigrationNeededException(writer, "\"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                fieldName, fieldIndexVariableReference(field), fieldIndex);
        writer.endControlFlow();
    }

    private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws IOException {
        String targetField = backlink.getTargetField();
        String targetClass = backlink.getTargetClass();

        // Preceding code has already verified that the backlink field is not in the table.
        // If it were, either the column count would be wrong, or some field would be missing.

        // verify that the source class exists
        String sourceClass = backlink.getSimpleSourceClass();
        String fullyQualifiedSourceClass = backlink.getSourceClass();
        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, sourceClass);
        emitMigrationNeededException(writer, "\"Cannot find source class '%s' for @LinkingObjects field '%s.%s'\")",
                fullyQualifiedSourceClass, targetClass, targetField);
        writer.endControlFlow();

        // verify that the source class contains the source field
        String sourceField = backlink.getSourceField();
        writer.emitStatement("backlinkSourceTable = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, sourceClass);
        writer.emitStatement("backlinkFieldIndex = backlinkSourceTable.getColumnIndex(\"%s\")", sourceField);
        writer.beginControlFlow("if (backlinkFieldIndex == Table.NO_MATCH)");
        emitMigrationNeededException(writer, "\"Cannot find source field '%s.%s' for @LinkingObjects field '%s.%s'\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();

        // verify that the source field type is target class
        writer.emitStatement("backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex)");
        writer.beginControlFlow("if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST))");
        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' is not a RealmObject type\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();
        writer.emitStatement("backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex)");
        writer.beginControlFlow("if (!table.hasSameSchema(backlinkTargetTable))");
        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' has wrong type '\" + backlinkTargetTable.getName() + \"'\")",
                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
        writer.endControlFlow();
    }

    //@formatter:off
    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
                .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
        writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
                .emitStatement("return FIELD_NAMES")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "copyOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
        );

        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null)")
                    .emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm()")
                    .beginControlFlow("if (otherRealm.threadId != realm.threadId)")
                        .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
                    .endControlFlow()

                    // If object is already in the Realm there is nothing to update
                    .beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
                        .emitStatement("return object")
                    .endControlFlow()
                .endControlFlow();


        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");

        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
                .beginControlFlow("if (cachedRealmObject != null)")
                    .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                .endControlFlow()
                .emitEmptyLine();

        if (!metadata.hasPrimaryKey()) {
            writer.emitStatement("return copy(realm, object, update, cache)");
        } else {
            writer
                    .emitStatement("%s realmObject = null", qualifiedClassName)
                    .emitStatement("boolean canUpdate = update")
                    .beginControlFlow("if (canUpdate)")
                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");

            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
            VariableElement primaryKeyElement = metadata.getPrimaryKey();
            if (metadata.isNullable(primaryKeyElement)) {
                if (Utils.isString(primaryKeyElement)) {
                    writer
                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (value == null)")
                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                            .nextControlFlow("else")
                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
                            .endControlFlow();
                } else {
                    writer
                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (value == null)")
                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                            .nextControlFlow("else")
                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
                            .endControlFlow();
                }
            } else {
                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
                        pkType, interfaceName, primaryKeyGetter);
            }

            writer
                    .beginControlFlow("if (rowIndex == Table.NO_MATCH)")
                        .emitStatement("canUpdate = false")
                    .nextControlFlow("else")
                        .beginControlFlow("try")
                            .emitStatement(
                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
                                qualifiedClassName)
                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                        .nextControlFlow("finally")
                            .emitStatement("objectContext.clear()")
                        .endControlFlow()
                    .endControlFlow();

            writer.endControlFlow();

            writer
                    .emitEmptyLine()
                       .emitStatement("return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache)");
        }

        writer.endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
        if ("long".equals(fieldType)
                || "int".equals(fieldType)
                || "short".equals(fieldType)
                || "byte".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Long".equals(fieldType)
                || "java.lang.Integer".equals(fieldType)
                || "java.lang.Short".equals(fieldType)
                || "java.lang.Byte".equals(fieldType)) {
            writer
                    .emitStatement("Number %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("io.realm.MutableRealmInteger".equals(fieldType)) {
            writer
                    .emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("double".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Double".equals(fieldType)) {
            writer
                    .emitStatement("Double %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("float".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Float".equals(fieldType)) {
            writer
                    .emitStatement("Float %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("boolean".equals(fieldType)) {
            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);

        } else if ("java.lang.Boolean".equals(fieldType)) {
            writer
                    .emitStatement("Boolean %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("byte[]".equals(fieldType)) {
            writer
                    .emitStatement("byte[] %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();


        } else if ("java.util.Date".equals(fieldType)) {
            writer
                    .emitStatement("java.util.Date %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();

        } else if ("java.lang.String".equals(fieldType)) {
            writer
                    .emitStatement("String %s = ((%s) object).%s()", getter, interfaceName, getter)
                    .beginControlFlow("if (%s != null)", getter)
                    .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
            if (isUpdate) {
                writer.nextControlFlow("else")
                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
            }
            writer.endControlFlow();
        } else {
            throw new IllegalStateException("Unsupported type " + fieldType);
        }
    }
    //@formatter:on

    private void emitInsertMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "long", // Return type
                "insert", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        // If object is already in the Realm there is nothing to update
        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                .endControlFlow();

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        addPrimaryKeyCheckIfNeeded(metadata, true, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field),
                                fieldName)
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return rowIndex");
        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitInsertListMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "void", // Return type
                "insert", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        writer.emitStatement("%s object = null", qualifiedClassName);

        writer.beginControlFlow("while (objects.hasNext())")
                .emitStatement("object = (%s) objects.next()", qualifiedClassName);
        writer.beginControlFlow("if (cache.containsKey(object))")
                .emitStatement("continue")
                .endControlFlow();

        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                .emitStatement("continue");
        writer.endControlFlow();

        addPrimaryKeyCheckIfNeeded(metadata, true, writer);

        //@formatter:off
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field),
                                fieldName)
                        .endControlFlow()
                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
                }
            }
        }
        //@formatter:on

        writer.endControlFlow();
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "long", // Return type
                "insertOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        // If object is already in the Realm there is nothing to update
        writer
                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                .endControlFlow();

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        addPrimaryKeyCheckIfNeeded(metadata, false, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .nextControlFlow("else")
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return rowIndex");

        writer.endMethod()
                .emitEmptyLine();
    }

    private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                "void", // Return type
                "insertOrUpdate", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
        );

        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
        }
        writer.emitStatement("%s object = null", qualifiedClassName);

        writer.beginControlFlow("while (objects.hasNext())");
        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
        writer.beginControlFlow("if (cache.containsKey(object))")
                .emitStatement("continue")
                .endControlFlow();

        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                .emitStatement("continue");
        writer.endControlFlow();
        addPrimaryKeyCheckIfNeeded(metadata, false, writer);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String getter = metadata.getInternalGetter(fieldName);

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sObj != null)", fieldName)
                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
                        .beginControlFlow("if (cache%s == null)", fieldName)
                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
                                fieldName,
                                Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                        .nextControlFlow("else")
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitEmptyLine()
                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                genericType, fieldName, interfaceName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
                        .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else {
                if (metadata.getPrimaryKey() != field) {
                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
                }
            }
            //@formatter:on
        }
        writer.endControlFlow();

        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfPrimaryKeyDuplicate, JavaWriter writer) throws IOException {
        if (metadata.hasPrimaryKey()) {
            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
            VariableElement primaryKeyElement = metadata.getPrimaryKey();
            if (metadata.isNullable(primaryKeyElement)) {
                //@formatter:off
                if (Utils.isString(primaryKeyElement)) {
                    writer
                            .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (primaryKeyValue == null)")
                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                            .nextControlFlow("else")
                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
                            .endControlFlow();
                } else {
                    writer
                            .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                            .emitStatement("long rowIndex = Table.NO_MATCH")
                            .beginControlFlow("if (primaryKeyValue == null)")
                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                            .nextControlFlow("else")
                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
                            .endControlFlow();
                }
                //@formatter:on
            } else {
                writer.emitStatement("long rowIndex = Table.NO_MATCH");
                writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
                writer.beginControlFlow("if (primaryKeyValue != null)");

                if (Utils.isString(metadata.getPrimaryKey())) {
                    writer.emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)");
                } else {
                    writer.emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
                }
                writer.endControlFlow();
            }

            writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
            if (Utils.isString(metadata.getPrimaryKey())) {
                writer.emitStatement(
                        "rowIndex = OsObject.createRowWithPrimaryKey(table, primaryKeyValue)");
            } else {
                writer.emitStatement(
                        "rowIndex = OsObject.createRowWithPrimaryKey(table, ((%s) object).%s())",
                        interfaceName, primaryKeyGetter);
            }

            if (throwIfPrimaryKeyDuplicate) {
                writer.nextControlFlow("else");
                writer.emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)");
            }

            writer.endControlFlow();
            writer.emitStatement("cache.put(object, rowIndex)");
        } else {
            writer.emitStatement("long rowIndex = OsObject.createRow(table)");
            writer.emitStatement("cache.put(object, rowIndex)");
        }
    }

    private void emitCopyMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "copy", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name

        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
        writer.beginControlFlow("if (cachedRealmObject != null)")
                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
                .endControlFlow();


        writer.emitEmptyLine()
                .emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
                    qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
        } else {
            writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
                    qualifiedClassName, qualifiedClassName);
        }
        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");

        writer.emitEmptyLine()
                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
                .emitStatement("%1$s realmObjectCopy = (%1$s) realmObject", interfaceName);

        writer.emitEmptyLine();
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String fieldType = field.asType().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);

            if (metadata.isPrimaryKey(field)) {
                // PK has been set when creating object.
                continue;
            }

            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer.emitEmptyLine()
                        .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
                        .beginControlFlow("if (%sObj == null)", fieldName)
                            .emitStatement("realmObjectCopy.%s(null)", setter)
                        .nextControlFlow("else")
                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                            .beginControlFlow("if (cache%s != null)", fieldName)
                                .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
                            .nextControlFlow("else")
                                .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
                                    setter, Utils.getProxyClassSimpleName(field), fieldName)
                            .endControlFlow()
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer.emitEmptyLine()
                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                        .beginControlFlow("if (%sList != null)", fieldName)
                            .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
                                genericType, fieldName, getter)
                             // Clear is needed. See bug https://github.com/realm/realm-java/issues/4957
                            .emitStatement("%sRealmList.clear()", fieldName)
                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                                .beginControlFlow("if (cache%s != null)", fieldName)
                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
                                .nextControlFlow("else")
                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, update, cache))",
                                        fieldName, Utils.getProxyClassSimpleName(field))
                                .endControlFlow()
                            .endControlFlow()
                        .endControlFlow()
                        .emitEmptyLine();

            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitEmptyLine()
                        .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
            } else {
                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
            }
            //@formatter:on
        }

        writer.emitStatement("return realmObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    //@formatter:off
    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
        writer.beginMethod(
                qualifiedClassName, // Return type
                "createDetachedCopy", // Method name
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
        writer
                .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                .emitStatement("return null")
                .endControlFlow()
                .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
                .emitStatement("%s unmanagedObject", qualifiedClassName)
                .beginControlFlow("if (cachedObject == null)")
                .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
                .nextControlFlow("else")
                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
                .emitStatement("return (%s) cachedObject.object", qualifiedClassName)
                .endControlFlow()
                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedClassName)
                .emitStatement("cachedObject.minDepth = currentDepth")
                .endControlFlow();

        // may cause an unused variable warning if the object contains only null lists
        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName)
            .emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);

            if (Utils.isRealmModel(field)) {
                writer
                        .emitEmptyLine()
                        .emitSingleLineComment("Deep copy of %s", fieldName)
                        .emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))",
                                setter, Utils.getProxyClassSimpleName(field), getter);
            } else if (Utils.isRealmList(field)) {
                writer
                        .emitEmptyLine()
                        .emitSingleLineComment("Deep copy of %s", fieldName)
                        .beginControlFlow("if (currentDepth == maxDepth)")
                        .emitStatement("unmanagedCopy.%s(null)", setter)
                        .nextControlFlow("else")
                        .emitStatement("RealmList<%s> managed%sList = realmSource.%s()",
                                Utils.getGenericTypeQualifiedName(field), fieldName, getter)
                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
                        .emitStatement("unmanagedCopy.%s(unmanaged%sList)", setter, fieldName)
                        .emitStatement("int nextDepth = currentDepth + 1")
                        .emitStatement("int size = managed%sList.size()", fieldName)
                        .beginControlFlow("for (int i = 0; i < size; i++)")
                        .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
                                Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
                        .emitStatement("unmanaged%sList.add(item)", fieldName)
                        .endControlFlow()
                        .endControlFlow();
            } else if (Utils.isMutableRealmInteger(field)) {
                // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
                writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
            } else {
                writer.emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter);
            }
        }

        writer.emitStatement("return unmanagedObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }
    //@formatter:on

    private void emitUpdateMethod(JavaWriter writer) throws IOException {
        if (!metadata.hasPrimaryKey()) {
            return;
        }

        writer.beginMethod(
                qualifiedClassName, // Return type
                "update", // Method name
                EnumSet.of(Modifier.STATIC), // Modifiers
                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name

        writer
                .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName);

        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String setter = metadata.getInternalSetter(fieldName);
            String getter = metadata.getInternalGetter(fieldName);
            //@formatter:off
            if (Utils.isRealmModel(field)) {
                writer
                        .emitStatement("%s %sObj = realmObjectSource.%s()",
                                Utils.getFieldTypeQualifiedName(field), fieldName, getter)
                        .beginControlFlow("if (%sObj == null)", fieldName)
                        .emitStatement("realmObjectTarget.%s(null)", setter)
                        .nextControlFlow("else")
                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sObj)",
                                Utils.getFieldTypeQualifiedName(field), fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                        .emitStatement("realmObjectTarget.%s(cache%s)", setter, fieldName)
                        .nextControlFlow("else")
                        .emitStatement("realmObjectTarget.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
                                setter, Utils.getProxyClassSimpleName(field), fieldName)
                        .endControlFlow()
                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                        .endControlFlow();
            } else if (Utils.isRealmList(field)) {
                final String genericType = Utils.getGenericTypeQualifiedName(field);
                writer
                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                        .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()",
                                genericType, fieldName, getter)
                        .emitStatement("%sRealmList.clear()", fieldName)
                        .beginControlFlow("if (%sList != null)", fieldName)
                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                        .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                        .beginControlFlow("if (cache%s != null)", fieldName)
                        .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
                        .nextControlFlow("else")
                        .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))",
                                fieldName, Utils.getProxyClassSimpleName(field))
                        .endControlFlow()
                        .endControlFlow()
                        .endControlFlow();

            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
            } else {
                if (field != metadata.getPrimaryKey()) {
                    writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
                }
            }
            //@formatter:on
        }

        writer.emitStatement("return realmObject");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitToStringMethod(JavaWriter writer) throws IOException {
        if (metadata.containsToString()) {
            return;
        }
        writer.emitAnnotation("Override");
        writer.emitAnnotation("SuppressWarnings", "\"ArrayToString\"")
                .beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC))
                .beginControlFlow("if (!RealmObject.isValid(this))")
                .emitStatement("return \"Invalid object\"")
                .endControlFlow();
        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleClassName);

        Collection<VariableElement> fields = metadata.getFields();
        int i = fields.size() - 1;
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();

            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
            if (Utils.isRealmModel(field)) {
                String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                writer.emitStatement(
                        "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
                        metadata.getInternalGetter(fieldName),
                        fieldTypeSimpleName
                );
            } else if (Utils.isRealmList(field)) {
                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                        genericTypeSimpleName,
                        metadata.getInternalGetter(fieldName));
            } else if (Utils.isMutableRealmInteger(field)) {
                writer.emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName));
            } else {
                if (metadata.isNullable(field)) {
                    writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
                            metadata.getInternalGetter(fieldName),
                            metadata.getInternalGetter(fieldName)
                    );
                } else {
                    writer.emitStatement("stringBuilder.append(%s())", metadata.getInternalGetter(fieldName));
                }
            }
            writer.emitStatement("stringBuilder.append(\"}\")");

            if (i-- > 0) {
                writer.emitStatement("stringBuilder.append(\",\")");
            }
        }

        writer.emitStatement("stringBuilder.append(\"]\")");
        writer.emitStatement("return stringBuilder.toString()");
        writer.endMethod()
                .emitEmptyLine();
    }

    /**
     * Currently, the hash value emitted from this could suddenly change as an object's index might
     * alternate due to Realm Java using {@code Table#moveLastOver()}. Hash codes should therefore not
     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
     */
    //@formatter:off
    private void emitHashcodeMethod(JavaWriter writer) throws IOException {
        if (metadata.containsHashCode()) {
            return;
        }
        writer.emitAnnotation("Override")
                .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
                .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
                .emitEmptyLine()
                .emitStatement("int result = 17")
                .emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)")
                .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
                .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
                .emitStatement("return result")
                .endMethod()
                .emitEmptyLine();
    }
    //@formatter:on

    //@formatter:off
    private void emitEqualsMethod(JavaWriter writer) throws IOException {
        if (metadata.containsEquals()) {
            return;
        }
        String proxyClassName = Utils.getProxyClassName(simpleClassName);
        String otherObjectVarName = "a" + simpleClassName;
        writer.emitAnnotation("Override")
                .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
                .emitStatement("if (this == o) return true")
                .emitStatement("if (o == null || getClass() != o.getClass()) return false")
                .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
                .emitEmptyLine()
                .emitStatement("String path = proxyState.getRealm$realm().getPath()")
                .emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName)
                .emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false")
                .emitEmptyLine()
                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                .emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName)
                .emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false")
                .emitEmptyLine()
                .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
                .emitEmptyLine()
                .emitStatement("return true")
                .endMethod();
    }
    //@formatter:on

    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.beginMethod(
                qualifiedClassName,
                "createOrUpdateUsingJsonObject",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                Collections.singletonList("JSONException"));

        final int modelOrListCount = countModelOrListFields(metadata.getFields());
        if (modelOrListCount == 0) {
            writer.emitStatement("final List<String> excludeFields = Collections.<String> emptyList()");
        } else {
            writer.emitStatement("final List<String> excludeFields = new ArrayList<String>(%1$d)",
                    modelOrListCount);
        }

        //@formatter:off
        if (!metadata.hasPrimaryKey()) {
            buildExcludeFieldsList(writer, metadata.getFields());
            writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
                    qualifiedClassName, qualifiedClassName);
        } else {
            String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
            writer
                .emitStatement("%s obj = null", qualifiedClassName)
                .beginControlFlow("if (update)")
                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                    .emitStatement("long rowIndex = Table.NO_MATCH");
            if (metadata.isNullable(metadata.getPrimaryKey())) {
                writer
                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                        .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                    .nextControlFlow("else")
                        .emitStatement(
                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                    .endControlFlow();
            } else {
                writer
                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                        .emitStatement(
                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                    .endControlFlow();
            }
            writer
                .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
                    .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
                    .beginControlFlow("try")
                        .emitStatement(
                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
                                qualifiedClassName)
                        .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
                    .nextControlFlow("finally")
                        .emitStatement("objectContext.clear()")
                    .endControlFlow()
                .endControlFlow()
            .endControlFlow();

            writer.beginControlFlow("if (obj == null)");
            buildExcludeFieldsList(writer, metadata.getFields());
            String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
            String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
                    qualifiedClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
            writer.endControlFlow();
        }
        //@formatter:on

        writer
                .emitEmptyLine()
                .emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        for (VariableElement field : metadata.getFields()) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            if (metadata.isPrimaryKey(field)) {
                // Primary key has already been set when adding new row or finding the existing row.
                continue;
            }
            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer);

            } else {
                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.emitStatement("return obj");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void buildExcludeFieldsList(JavaWriter writer, Collection<VariableElement> fields) throws IOException {
        for (VariableElement field : fields) {
            if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
                final String fieldName = field.getSimpleName().toString();
                writer.beginControlFlow("if (json.has(\"%1$s\"))", fieldName)
                        .emitStatement("excludeFields.add(\"%1$s\")", fieldName)
                        .endControlFlow();
            }
        }
    }

    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
    // instead of createObject() to avoid parsing the stream twice.
    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
        writer.beginMethod(
                qualifiedClassName,
                "createUsingJsonStream",
                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                Collections.singletonList("IOException"));

        if (metadata.hasPrimaryKey()) {
            writer.emitStatement("boolean jsonHasPrimaryKey = false");
        }
        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
        writer.emitStatement("reader.beginObject()");
        writer.beginControlFlow("while (reader.hasNext())");
        writer.emitStatement("String name = reader.nextName()");
        writer.beginControlFlow("if (false)");
        Collection<VariableElement> fields = metadata.getFields();
        for (VariableElement field : fields) {
            String fieldName = field.getSimpleName().toString();
            String qualifiedFieldType = field.asType().toString();
            writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);

            if (Utils.isRealmModel(field)) {
                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
                        "objProxy",
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        Utils.getProxyClassSimpleName(field),
                        writer
                );

            } else if (Utils.isRealmList(field)) {
                RealmJsonTypeHelper.emitFillRealmListFromStream(
                        "objProxy",
                        metadata.getInternalGetter(fieldName),
                        metadata.getInternalSetter(fieldName),
                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                        Utils.getProxyClassSimpleName(field),
                        writer);

            } else if (Utils.isMutableRealmInteger(field)) {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalGetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            } else {
                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                        "objProxy",
                        metadata,
                        metadata.getInternalSetter(fieldName),
                        fieldName,
                        qualifiedFieldType,
                        writer
                );
            }
        }

        writer.nextControlFlow("else");
        writer.emitStatement("reader.skipValue()");
        writer.endControlFlow();

        writer.endControlFlow();
        writer.emitStatement("reader.endObject()");

        if (metadata.hasPrimaryKey()) {
            writer.beginControlFlow("if (!jsonHasPrimaryKey)")
                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey())
                    .endControlFlow();
        }

        writer.emitStatement("return realm.copyToRealm(obj)");
        writer.endMethod();
        writer.emitEmptyLine();
    }

    private void emitMigrationNeededException(JavaWriter writer, String message, Object... args) throws IOException {
        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), " + message, args);
    }

    private String columnInfoClassName() {
        return simpleClassName + "ColumnInfo";
    }

    private String columnIndexVarName(VariableElement variableElement) {
        return variableElement.getSimpleName().toString() + "Index";
    }

    private String mutableRealmIntegerFieldName(VariableElement variableElement) {
        return variableElement.getSimpleName().toString() + "MutableRealmInteger";
    }

    private String fieldIndexVariableReference(VariableElement variableElement) {
        return "columnInfo." + columnIndexVarName(variableElement);
    }

    private static int countModelOrListFields(Collection<VariableElement> fields) {
        int count = 0;
        for (VariableElement f : fields) {
            if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
                count++;
            }
        }
        return count;
    }

    private Constants.RealmFieldType getRealmType(VariableElement field) {
        String fieldTypeCanonicalName = field.asType().toString();
        Constants.RealmFieldType type = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
        if (type != null) {
            return type;
        }
        if (Utils.isMutableRealmInteger(field)) {
            return Constants.RealmFieldType.REALM_INTEGER;
        }
        if (Utils.isRealmModel(field)) {
            return Constants.RealmFieldType.OBJECT;
        }
        if (Utils.isRealmList(field)) {
            return Constants.RealmFieldType.LIST;
        }
        return Constants.RealmFieldType.NOTYPE;
    }

    private Constants.RealmFieldType getRealmTypeChecked(VariableElement field) {
        Constants.RealmFieldType type = getRealmType(field);
        if (type == Constants.RealmFieldType.NOTYPE) {
            throw new IllegalStateException("Unsupported type " + field.asType().toString());
        }
        return type;
    }
}
!@#$%
20190526_211339,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b19760
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @param function transformation function.
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @param fieldName name of the target field.
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        //noinspection ConstantConditions
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211339,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a19760
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211339,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c19760
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.OsObject;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable or this method is called on a synced Realm.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            String name = table.getColumnName(i);
            if (!OsObject.isObjectIdColumn(name)) {
                columnNames.add(name);
            }
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    static final Map<Class<?>, FieldMetaData> getSupportedSimpleFields() {
        return SUPPORTED_SIMPLE_FIELDS;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    static void checkLegalName(String fieldName) {
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
        if (fieldName.length() > 63) {
            throw new IllegalArgumentException("Field name is currently limited to max 63 characters.");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211415,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b18040
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public ColumnDetails getColumnDetails(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnDetails'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211415,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a18040
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211415,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c18040
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @param function transformation function.
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @param fieldName name of the target field.
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        //noinspection ConstantConditions
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211428,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_b02912
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.OsObject;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable or this method is called on a synced Realm.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            String name = table.getColumnName(i);
            if (!OsObject.isObjectIdColumn(name)) {
                columnNames.add(name);
            }
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @param function transformation function.
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @param fieldName name of the target field.
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    static final Map<Class<?>, FieldMetaData> getSupportedSimpleFields() {
        return SUPPORTED_SIMPLE_FIELDS;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    static void checkLegalName(String fieldName) {
        //noinspection ConstantConditions
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
        if (fieldName.length() > 63) {
            throw new IllegalArgumentException("Field name is currently limited to max 63 characters.");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211428,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_a02912
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @param function transformation function.
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @param fieldName name of the target field.
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        //noinspection ConstantConditions
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public RealmFieldType getColumnType(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnType'");
        }

        @Override
        public String getLinkedTable(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getLinkedTable'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
20190526_211428,C:\Users\Alice Borner\Desktop\projects\realm-java\git\.merge_file_c02912
/*
 * Copyright 2017 Realm Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.realm;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import io.realm.annotations.Required;
import io.realm.internal.ColumnInfo;
import io.realm.internal.Table;
import io.realm.internal.fields.FieldDescriptor;


/**
 * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
 * add, delete or change the fields for given class.
 * <p>
 * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
 * will be immutable as well.
 *
 * @see io.realm.RealmMigration
 */
public abstract class RealmObjectSchema {

    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
    }

    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;

    static {
        Map<Class<?>, FieldMetaData> m = new HashMap<>();
        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
    }

    final RealmSchema schema;
    final BaseRealm realm;
    final Table table;
    private final ColumnInfo columnInfo;

    /**
     * Creates a schema object for a given Realm class.
     *
     * @param realm Realm holding the objects.
     * @param table table representation of the Realm class
     * @param columnInfo mapping between field names and column indexes for the given table
     */
    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
        this.schema = schema;
        this.realm = realm;
        this.table = table;
        this.columnInfo = columnInfo;
    }

    /**
     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
     */
    @Deprecated
    public void close() {
    }

    /**
     * Returns the name of the RealmObject class being represented by this schema.
     * <p>
     * <ul>
     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
     * </ul>
     *
     * @return the name of the RealmObject class represented by this schema.
     */
    public String getClassName() {
        return table.getClassName();
    }

    /**
     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
     *
     * @param className the new name for this class.
     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
     * characters.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see RealmSchema#rename(String, String)
     */
    public abstract RealmObjectSchema setClassName(String className);

    /**
     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
     * <p>
     * To add fields that reference other RealmObjects or RealmLists use
     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
     * instead.
     *
     * @param fieldName name of the field to add.
     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
     * @param attributes set of attributes for this field.
     * @return the updated schema.
     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * already exists.
     */
    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);

    /**
     * Adds a new field that references another {@link RealmObject}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Adds a new field that references a {@link RealmList}.
     *
     * @param fieldName name of the field to add.
     * @param objectSchema schema for the Realm type being referenced.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);

    /**
     * Removes a field from the class.
     *
     * @param fieldName field name to remove.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeField(String fieldName);

    /**
     * Renames a field from one name to another.
     *
     * @param currentFieldName field name to rename.
     * @param newFieldName the new field name.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);

    /**
     * Tests if the class has field defined with the given name.
     *
     * @param fieldName field name to test.
     * @return {@code true} if the field exists, {@code false} otherwise.
     */
    public boolean hasField(String fieldName) {
        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
    }

    /**
     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
     * annotation on the field.
     *
     * @param fieldName field to add index to.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
     * index defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addIndex(String fieldName);

    /**
     * Checks if a given field has an index defined.
     *
     * @param fieldName existing field name to check.
     * @return {@code true} if field is indexed, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see io.realm.annotations.Index
     */
    public boolean hasIndex(String fieldName) {
        checkLegalName(fieldName);
        checkFieldExists(fieldName);
        return table.hasSearchIndex(table.getColumnIndex(fieldName));
    }

    /**
     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
     *
     * @param fieldName field to remove index from.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removeIndex(String fieldName);

    /**
     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
     * as well.
     *
     * @param fieldName field to set as primary key.
     * @return the updated schema.
     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
     * has a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema addPrimaryKey(String fieldName);

    /**
     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
     * the field as well.
     *
     * @return the updated schema.
     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema removePrimaryKey();

    /**
     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
     *
     * @param fieldName name of field in the class.
     * @param required {@code true} if field should be required, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
     * the field already have been set as required.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     * @see Required
     */
    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);

    /**
     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
     *
     * @param fieldName name of field in the class.
     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
     * @return the updated schema.
     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);

    /**
     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setRequired(String, boolean)
     */
    public boolean isRequired(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return !table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is required, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #setNullable(String, boolean)
     */
    public boolean isNullable(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.isColumnNullable(columnIndex);
    }

    /**
     * Checks if a given field is the primary key field.
     *
     * @param fieldName field to check.
     * @return {@code true} if it is the primary key field, {@code false} otherwise.
     * @throws IllegalArgumentException if field name doesn't exist.
     * @see #addPrimaryKey(String)
     */
    public boolean isPrimaryKey(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return columnIndex == table.getPrimaryKey();
    }

    /**
     * Checks if the class has a primary key defined.
     *
     * @return {@code true} if a primary key is defined, {@code false} otherwise.
     * @see io.realm.annotations.PrimaryKey
     */
    public boolean hasPrimaryKey() {
        return table.hasPrimaryKey();
    }

    /**
     * Returns the name of the primary key field.
     *
     * @return the name of the primary key field.
     * @throws IllegalStateException if the class doesn't have a primary key defined.
     */
    public String getPrimaryKey() {
        if (!table.hasPrimaryKey()) {
            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
        }
        return table.getColumnName(table.getPrimaryKey());
    }

    /**
     * Returns all fields in this class.
     *
     * @return a list of all the fields in this class.
     */
    public Set<String> getFieldNames() {
        int columnCount = (int) table.getColumnCount();
        Set<String> columnNames = new LinkedHashSet<>(columnCount);
        for (int i = 0; i < columnCount; i++) {
            columnNames.add(table.getColumnName(i));
        }
        return columnNames;
    }

    /**
     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
     * as a {@link DynamicRealmObject}.
     *
     * @param function transformation function.
     * @return this schema.
     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
     */
    public abstract RealmObjectSchema transform(Function function);

    /**
     * Returns the type used by the underlying storage engine to represent this field.
     *
     * @param fieldName name of the target field.
     * @return the underlying type used by Realm to represent this field.
     */
    public RealmFieldType getFieldType(String fieldName) {
        long columnIndex = getColumnIndex(fieldName);
        return table.getColumnType(columnIndex);
    }

    /**
     * Get a parser for a field descriptor.
     *
     * @param fieldDescription fieldName or link path to a field name.
     * @param validColumnTypes valid field type for the last field in a linked field
     * @return a FieldDescriptor
     */
    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
    }

    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);

        if (indexed) { table.addSearchIndex(columnIndex); }

        if (primary) { table.setPrimaryKey(name); }

        return this;
    }

    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
        table.addColumnLink(
                type,
                name,
                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
        return this;
    }

    long getAndCheckFieldIndex(String fieldName) {
        long index = columnInfo.getColumnIndex(fieldName);
        if (index < 0) {
            throw new IllegalArgumentException("Field does not exist: " + fieldName);
        }
        return index;
    }

    Table getTable() {
        return table;
    }

    private SchemaConnector getSchemaConnector() {
        return new SchemaConnector(schema);
    }

    /**
     * Function interface, used when traversing all objects of the current class and apply a function on each.
     *
     * @see #transform(Function)
     */
    public interface Function {
        void apply(DynamicRealmObject obj);
    }

    /**
     * Returns the column index in the underlying table for the given field name.
     * <b>FOR TESTING USE ONLY!</b>
     *
     * @param fieldName field name to find index for.
     * @return column index or -1 if it doesn't exists.
     */
    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
    long getFieldIndex(String fieldName) {
        return columnInfo.getColumnIndex(fieldName);
    }

    void checkLegalName(String fieldName) {
        //noinspection ConstantConditions
        if (fieldName == null || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name can not be null or empty");
        }
        if (fieldName.contains(".")) {
            throw new IllegalArgumentException("Field name can not contain '.'");
        }
    }

    void checkFieldExists(String fieldName) {
        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
        }
    }

    long getColumnIndex(String fieldName) {
        long columnIndex = table.getColumnIndex(fieldName);
        if (columnIndex == -1) {
            throw new IllegalArgumentException(
                    String.format(Locale.US,
                            "Field name '%s' does not exist on schema for '%s'",
                            fieldName, getClassName()
                    ));
        }
        return columnIndex;
    }

    static final class DynamicColumnIndices extends ColumnInfo {
        private final Table table;

        DynamicColumnIndices(Table table) {
            super(null, false);
            this.table = table;
        }

        @Override
        public long getColumnIndex(String columnName) {
            return table.getColumnIndex(columnName);
        }

        @Override
        public ColumnDetails getColumnDetails(String columnName) {
            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnDetails'");
        }

        @Override
        public void copyFrom(ColumnInfo src) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }

        @Override
        protected ColumnInfo copy(boolean immutable) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
        }


        @Override
        protected void copy(ColumnInfo src, ColumnInfo dst) {
            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
        }
    }

    // Tuple containing data about each supported Java type.
    static final class FieldMetaData {
        final RealmFieldType realmType;
        final boolean defaultNullable;

        FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
            this.realmType = realmType;
            this.defaultNullable = defaultNullable;
        }
    }
}
!@#$%
