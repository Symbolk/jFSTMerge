C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b19028;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a19028;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c19028
<<<<<<< MINE
=======
      }
    } catch (Exception e) {
      LOGGER.warn("Error parsing child elements for {}", elementName, e);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b14592;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a14592;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c14592
<<<<<<< MINE
=======
// deserialized objects /////////////////////////////////////////////////////
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
    return new TaskPaginateList(restResponseFactory).paginateList(requestParams, request, taskQuery, "id", properties);
=======
    return new TaskPaginateList(restResponseFactory).paginateList(
        requestParams, request, taskQuery, "id", properties);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
List<String> getTablesPresentInDatabase();
=======
public List<String> getTablesPresentInDatabase() {
    List<String> tableNames = new ArrayList<String>();
    Connection connection = null;
    try {
      connection = getDbSqlSession().getSqlSession().getConnection();
      DatabaseMetaData databaseMetaData = connection.getMetaData();
      ResultSet tables = null;
      try {
        log.debug("retrieving activiti tables from jdbc metadata");
        String databaseTablePrefix = getDbSqlSession().getDbSqlSessionFactory().getDatabaseTablePrefix();
        String tableNameFilter = databaseTablePrefix+"ACT_%";
        if ("postgres".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          tableNameFilter = databaseTablePrefix+"act\\_%";
        }
        if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          tableNameFilter = databaseTablePrefix+"ACT" + databaseMetaData.getSearchStringEscape() + "_%";
        }
        
        String catalog = null;
        if (getProcessEngineConfiguration().getDatabaseCatalog() != null && getProcessEngineConfiguration().getDatabaseCatalog().length() > 0) {
          catalog = getProcessEngineConfiguration().getDatabaseCatalog();
        }
        
        String schema = null;
        if (getProcessEngineConfiguration().getDatabaseSchema() != null && getProcessEngineConfiguration().getDatabaseSchema().length() > 0) {
          if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
            schema = getProcessEngineConfiguration().getDatabaseSchema().toUpperCase();
          } else {
            schema = getProcessEngineConfiguration().getDatabaseSchema();
          }
        }
        
        tables = databaseMetaData.getTables(catalog, schema, tableNameFilter, getDbSqlSession().JDBC_METADATA_TABLE_TYPES);
        while (tables.next()) {
          String tableName = tables.getString("TABLE_NAME");
          tableName = tableName.toUpperCase();
          tableNames.add(tableName);
          log.debug("  retrieved activiti table name {}", tableName);
        }
      } finally {
        tables.close();
      }
    } catch (Exception e) {
      throw new ActivitiException("couldn't get activiti table names using metadata: "+e.getMessage(), e); 
    }
    return tableNames;
  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
TableMetaData getTableMetaData(String tableName);
=======
public TableMetaData getTableMetaData(String tableName) {
    TableMetaData result = new TableMetaData();
    try {
      result.setTableName(tableName);
      DatabaseMetaData metaData = getDbSqlSession()
        .getSqlSession()
        .getConnection()
        .getMetaData();

      if ("postgres".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
        tableName = tableName.toLowerCase();
      }
      
      String catalog = null;
      if (getProcessEngineConfiguration().getDatabaseCatalog() != null && getProcessEngineConfiguration().getDatabaseCatalog().length() > 0) {
        catalog = getProcessEngineConfiguration().getDatabaseCatalog();
      }
      
      String schema = null;
      if (getProcessEngineConfiguration().getDatabaseSchema() != null && getProcessEngineConfiguration().getDatabaseSchema().length() > 0) {
        if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          schema = getProcessEngineConfiguration().getDatabaseSchema().toUpperCase();
        } else {
          schema = getProcessEngineConfiguration().getDatabaseSchema();
        }
      }

      ResultSet resultSet = metaData.getColumns(catalog, schema, tableName, null);
      while(resultSet.next()) {
        boolean wrongSchema = false;
        if (schema != null && schema.length() > 0) {
          for (int i = 0; i < resultSet.getMetaData().getColumnCount(); i++) {
            String columnName = resultSet.getMetaData().getColumnName(i+1);
            if ("TABLE_SCHEM".equalsIgnoreCase(columnName) || "TABLE_SCHEMA".equalsIgnoreCase(columnName)) {
              if (schema.equalsIgnoreCase(resultSet.getString(resultSet.getMetaData().getColumnName(i+1))) == false) {
                wrongSchema = true;
              }
              break;
            }
          }
        }
        
        if (wrongSchema == false) {
          String name = resultSet.getString("COLUMN_NAME").toUpperCase();
          String type = resultSet.getString("TYPE_NAME").toUpperCase();
          result.addColumnMetaData(name, type);
        }
      }
      
    } catch (SQLException e) {
      throw new ActivitiException("Could not retrieve database metadata: " + e.getMessage());
    }

    if(result.getColumnNames().isEmpty()) {
      // According to API, when a table doesn't exist, null should be returned
      result = null;
    }
    return result;
  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
public static List<Class<? extends Entity>> DELETE_ORDER = new ArrayList<Class<? extends Entity>>();
=======
public static List<Class<? extends PersistentObject>> DELETE_ORDER = new ArrayList<Class<? extends PersistentObject>>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
public static List<Class<? extends Entity>> INSERT_ORDER = new ArrayList<Class<? extends Entity>>();
=======
public static List<Class<? extends PersistentObject>> INSERT_ORDER = new ArrayList<Class<? extends PersistentObject>>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
   * A map {class, boolean}, to indicate whether or not a certain {@link Entity} class can be bulk inserted.
=======
   * A map {class, boolean}, to indicate whether or not a certain {@link PersistentObject} class can be bulk inserted.
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
protected static Map<Class<? extends Entity>, Boolean> bulkInsertableMap;
=======
protected static Map<Class<? extends PersistentObject>, Boolean> bulkInsertableMap;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
// Caches, filled while executing processes
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
  	bulkInsertableMap = new HashMap<Class<? extends Entity>, Boolean>();
  	
  	for (Class<? extends Entity> clazz : EntityDependencyOrder.INSERT_ORDER) {
  		bulkInsertableMap.put(clazz, Boolean.TRUE);
  	}

  	// Only Oracle is making a fuss in one specific case right now
		if ("oracle".equals(databaseType)) {
			bulkInsertableMap.put(EventLogEntryEntityImpl.class, Boolean.FALSE);
=======
  	bulkInsertableMap = new HashMap<Class<? extends PersistentObject>, Boolean>();
  	
  	for (Class<? extends PersistentObject> clazz : EntityDependencyOrder.INSERT_ORDER) {
  		bulkInsertableMap.put(clazz, Boolean.TRUE);
  	}

  	// Only Oracle is making a fuss in one specific case right now
		if ("oracle".equals(databaseType)) {
			bulkInsertableMap.put(EventLogEntryEntity.class, Boolean.FALSE);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
protected Map<Class<? extends Entity>, Map<String, Entity>> insertedObjects 
    = new HashMap<Class<? extends Entity>, Map<String, Entity>>();
=======
protected Map<Class<? extends PersistentObject>, List<PersistentObject>> insertedObjects = new HashMap<Class<? extends PersistentObject>, List<PersistentObject>>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.sqlSession = dbSqlSessionFactory
      .getSqlSessionFactory()
      .openSession();
  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
public void insert(PersistentObject persistentObject) {
    if (persistentObject.getId()==null) {
      String id = dbSqlSessionFactory.getIdGenerator().getNextId();  
      persistentObject.setId(id);
    }
    
    Class<? extends PersistentObject> clazz = persistentObject.getClass();
    if (!insertedObjects.containsKey(clazz)) {
    	insertedObjects.put(clazz, new ArrayList<PersistentObject>());
    }
    
    insertedObjects.get(clazz).add(persistentObject);
    cachePut(persistentObject, false);
  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
    for (Class<? extends Entity> entityClass : deletedObjects.keySet()) {
=======
    for (Iterator<DeleteOperation> deleteIterator = deleteOperations.iterator(); deleteIterator.hasNext();) {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
      // Collect ids of deleted entities + remove duplicates 
      Set<String> ids = new HashSet<String>();
      Iterator<Entity> entitiesToDeleteIterator = deletedObjects.get(entityClass).values().iterator();
      while (entitiesToDeleteIterator.hasNext()) {
        Entity entityToDelete = entitiesToDeleteIterator.next();
        if (!ids.contains(entityToDelete.getId())) {
          ids.add(entityToDelete.getId());
        } else {
          entitiesToDeleteIterator.remove(); // Removing duplicate deletes
=======
      DeleteOperation deleteOperation = deleteIterator.next();
      Class<? extends PersistentObject> deletedPersistentObjectClass = deleteOperation.getPersistentObjectClass();
      
      List<PersistentObject> insertedObjectsOfSameClass = insertedObjects.get(deletedPersistentObjectClass);
      if (insertedObjectsOfSameClass != null && insertedObjectsOfSameClass.size() > 0) {
      	
	      for (Iterator<PersistentObject> insertIterator = insertedObjectsOfSameClass.iterator(); insertIterator.hasNext();) {
	        PersistentObject insertedObject = insertIterator.next();
	        
	        // if the deleted object is inserted,
	        if (deleteOperation.sameIdentity(insertedObject)) {
	          // remove the insert and the delete, they cancel each other
	          insertIterator.remove();
	          deleteIterator.remove();
	          // add removed operations to be able to fire events
	          removedDeleteOperations.add( deleteOperation);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
    for (Class<? extends PersistentObject> persistentObjectClass : insertedObjects.keySet()) {
    	for (PersistentObject insertedObject : insertedObjects.get(persistentObjectClass)) {
    		cacheRemove(insertedObject.getClass(), insertedObject.getId());
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
    }

    return removedDeleteOperations;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
//  
//  [Joram] Put this in comments. Had all kinds of errors.
//  
//  /**
//   * Optimizes the given delete operations:
//   * for example, if there are two deletes for two different variables, merges this into
//   * one bulk delete which improves performance
//   */
//  protected List<DeleteOperation> optimizeDeleteOperations(List<DeleteOperation> deleteOperations) {
//  	
//  	// No optimization possible for 0 or 1 operations
//  	if (!isOptimizeDeleteOperationsEnabled || deleteOperations.size() <= 1) {
//  		return deleteOperations;
//  	}
//  	
//  	List<DeleteOperation> optimizedDeleteOperations = new ArrayList<DbSqlSession.DeleteOperation>();
//  	boolean[] checkedIndices = new boolean[deleteOperations.size()];
//  	for (int i=0; i<deleteOperations.size(); i++) {
//  		
//  		if (checkedIndices[i] == true) {
//  			continue;
//  		}
//  		
//  		DeleteOperation deleteOperation = deleteOperations.get(i);
//  		boolean couldOptimize = false;
//  		if (deleteOperation instanceof CheckedDeleteOperation) {
//  			
//  			PersistentObject persistentObject = ((CheckedDeleteOperation) deleteOperation).getPersistentObject();
//  			if (persistentObject instanceof BulkDeleteable) {
//				String bulkDeleteStatement = dbSqlSessionFactory.getBulkDeleteStatement(persistentObject.getClass());
//				bulkDeleteStatement = dbSqlSessionFactory.mapStatement(bulkDeleteStatement);
//				if (bulkDeleteStatement != null) {
//					BulkCheckedDeleteOperation bulkCheckedDeleteOperation = null;
//					
//					// Find all objects of the same type
//					for (int j=0; j<deleteOperations.size(); j++) {
//						DeleteOperation otherDeleteOperation = deleteOperations.get(j);
//						if (j != i && checkedIndices[j] == false && otherDeleteOperation instanceof CheckedDeleteOperation) {
//							PersistentObject otherPersistentObject = ((CheckedDeleteOperation) otherDeleteOperation).getPersistentObject();
//							if (otherPersistentObject.getClass().equals(persistentObject.getClass())) {
//	  							if (bulkCheckedDeleteOperation == null) {
//	  								bulkCheckedDeleteOperation = new BulkCheckedDeleteOperation(persistentObject.getClass());
//	  								bulkCheckedDeleteOperation.addPersistentObject(persistentObject);
//	  								optimizedDeleteOperations.add(bulkCheckedDeleteOperation);
//	  							}
//	  							couldOptimize = true;
//	  							bulkCheckedDeleteOperation.addPersistentObject(otherPersistentObject);
//	  							checkedIndices[j] = true;
//							} else {
//							    // We may only optimize subsequent delete operations of the same type, to prevent messing up 
//							    // the order of deletes of related entities which may depend on the referenced entity being deleted before
//							    break;
//							}
//						}
//						
//					}
//				}
//  			}
//  		}
//  		
//   		if (!couldOptimize) {
//  			optimizedDeleteOperations.add(deleteOperation);
//  		}
//  		checkedIndices[i]=true;
//  		
//  	}
//  	return optimizedDeleteOperations;
//  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
    if (insertedObjects.size() == 0) {
      return;
=======
  	// Handle in entity dependency order
    for (Class<? extends PersistentObject> persistentObjectClass : EntityDependencyOrder.INSERT_ORDER) {
      if (insertedObjects.containsKey(persistentObjectClass)) {
      	flushPersistentObjects(persistentObjectClass, insertedObjects.get(persistentObjectClass));
      	insertedObjects.remove(persistentObjectClass);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
  	
  	// Handle in entity dependency order
    for (Class<? extends Entity> entityClass : EntityDependencyOrder.INSERT_ORDER) {
      if (insertedObjects.containsKey(entityClass)) {
        flushInsertEntities(entityClass, insertedObjects.get(entityClass).values());
      	insertedObjects.remove(entityClass);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
    
    // Next, in case of custom entities or we've screwed up and forgotten some entity
    if (insertedObjects.size() > 0) {
	    for (Class<? extends PersistentObject> persistentObjectClass : insertedObjects.keySet()) {
      	flushPersistentObjects(persistentObjectClass, insertedObjects.get(persistentObjectClass));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
    
    // Next, in case of custom entities or we've screwed up and forgotten some entity
    if (insertedObjects.size() > 0) {
	    for (Class<? extends Entity> entityClass : insertedObjects.keySet()) {
      	flushInsertEntities(entityClass, insertedObjects.get(entityClass).values());
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
    }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
protected void flushUpdates(List<PersistentObject> updatedObjects) {
    for (PersistentObject updatedObject: updatedObjects) {
      String updateStatement = dbSqlSessionFactory.getUpdateStatement(updatedObject);
      updateStatement = dbSqlSessionFactory.mapStatement(updateStatement);
      
      if (updateStatement==null) {
        throw new ActivitiException("no update statement for "+updatedObject.getClass()+" in the ibatis mapping files");
      }
      
      log.debug("updating: {}", updatedObject);
      int updatedRecords = sqlSession.update(updateStatement, updatedObject);
      if (updatedRecords!=1) {
        throw new ActivitiOptimisticLockingException(updatedObject + " was updated by another transaction concurrently");
      } 
      
      // See https://activiti.atlassian.net/browse/ACT-1290
      if (updatedObject instanceof HasRevision) {
        ((HasRevision) updatedObject).setRevision(((HasRevision) updatedObject).getRevisionNext());
      }
      
    }
    updatedObjects.clear();
  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
protected void flushDeletes(List<DeleteOperation> removedOperations) {
    flushRegularDeletes();
    deleteOperations.clear();
  }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444;C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
<<<<<<< MINE
=======
				if (xtr.isEndElement()  && ELEMENT_TRANSACTION.equals(xtr.getLocalName())) {
          activeSubProcessList.remove(activeSubProcessList.size() - 1);
        }

>>>>>>> YOURS
