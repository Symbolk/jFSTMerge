20190526_171328,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.image.impl;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.font.FontRenderContext;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;

import org.activiti.bpmn.model.AssociationDirection;
import org.activiti.bpmn.model.GraphicInfo;
import org.activiti.image.exception.ActivitiImageException;
import org.activiti.image.util.ReflectUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Represents a canvas on which BPMN 2.0 constructs can be drawn.
 * 
 * Some of the icons used are licensed under a Creative Commons Attribution 2.5
 * License, see http://www.famfamfam.com/lab/icons/silk/
 * 
 * @see org.activiti.engine.impl.bpmn.diagram.DefaultProcessDiagramGenerator
 * @author Joram Barrez
 */
public class DefaultProcessDiagramCanvas {

  protected static final Logger LOGGER = LoggerFactory.getLogger(DefaultProcessDiagramCanvas.class);
  public enum SHAPE_TYPE {Rectangle, Rhombus, Ellipse}

  // Predefined sized
  protected static final int ARROW_WIDTH = 5;
  protected static final int CONDITIONAL_INDICATOR_WIDTH = 16;
  protected static final int DEFAULT_INDICATOR_WIDTH = 10;
  protected static final int MARKER_WIDTH = 12;
  protected static final int FONT_SIZE = 11;
  protected static final int FONT_SPACING = 2;
  protected static final int TEXT_PADDING = 3;
  protected static final int ANNOTATION_TEXT_PADDING = 7;
  protected static final int LINE_HEIGHT = FONT_SIZE + FONT_SPACING;
  

  // Colors
  protected static Color TASK_BOX_COLOR = new Color(249, 249, 249);
  protected static Color SUBPROCESS_BOX_COLOR = new Color(255, 255, 255);
  protected static Color EVENT_COLOR = new Color(255, 255, 255);
  protected static Color CONNECTION_COLOR = new Color(88, 88, 88);
  protected static Color CONDITIONAL_INDICATOR_COLOR = new Color(255, 255, 255);
  protected static Color HIGHLIGHT_COLOR = Color.RED;
  protected static Color LABEL_COLOR = new Color(112, 146, 190);
  protected static Color TASK_BORDER_COLOR = new Color(187, 187, 187);
  protected static Color EVENT_BORDER_COLOR = new Color(88, 88, 88);
  protected static Color SUBPROCESS_BORDER_COLOR = new Color(0, 0, 0);
  
  // Fonts
  protected static Font LABEL_FONT = null;
  protected static Font ANNOTATION_FONT = null;
  
  // Strokes
  protected static Stroke THICK_TASK_BORDER_STROKE = new BasicStroke(3.0f);
  protected static Stroke GATEWAY_TYPE_STROKE = new BasicStroke(3.0f);
  protected static Stroke END_EVENT_STROKE = new BasicStroke(3.0f);
  protected static Stroke MULTI_INSTANCE_STROKE = new BasicStroke(1.3f);
  protected static Stroke EVENT_SUBPROCESS_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 1.0f }, 0.0f);
  protected static Stroke NON_INTERRUPTING_EVENT_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 4.0f, 3.0f }, 0.0f);
  protected static Stroke HIGHLIGHT_FLOW_STROKE = new BasicStroke(1.3f);
  protected static Stroke ANNOTATION_STROKE = new BasicStroke(2.0f);
  protected static Stroke ASSOCIATION_STROKE = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 2.0f, 2.0f }, 0.0f);

  // icons
  protected static int ICON_PADDING = 5;
  protected static BufferedImage USERTASK_IMAGE;
  protected static BufferedImage SCRIPTTASK_IMAGE;
  protected static BufferedImage SERVICETASK_IMAGE;
  protected static BufferedImage RECEIVETASK_IMAGE;
  protected static BufferedImage SENDTASK_IMAGE;
  protected static BufferedImage MANUALTASK_IMAGE;
  protected static BufferedImage BUSINESS_RULE_TASK_IMAGE;
  protected static BufferedImage SHELL_TASK_IMAGE;
  protected static BufferedImage MULE_TASK_IMAGE;
  protected static BufferedImage CAMEL_TASK_IMAGE;
  
  protected static BufferedImage TIMER_IMAGE;
  protected static BufferedImage COMPENSATE_THROW_IMAGE;
  protected static BufferedImage COMPENSATE_CATCH_IMAGE;
  protected static BufferedImage ERROR_THROW_IMAGE;
  protected static BufferedImage ERROR_CATCH_IMAGE;
  protected static BufferedImage MESSAGE_THROW_IMAGE;
  protected static BufferedImage MESSAGE_CATCH_IMAGE;
  protected static BufferedImage SIGNAL_CATCH_IMAGE;
  protected static BufferedImage SIGNAL_THROW_IMAGE;

  protected int canvasWidth = -1;
  protected int canvasHeight = -1;
  protected int minX = -1;
  protected int minY = -1;
  protected BufferedImage processDiagram;
  protected Graphics2D g;
  protected FontMetrics fontMetrics;
  protected boolean closed;
  protected ClassLoader customClassLoader;
  protected String activityFontName = "Arial";
  protected String labelFontName = "Arial";
  protected String annotationFontName = "Arial";
  
  /**
   * Creates an empty canvas with given width and height.
   * 
   * Allows to specify minimal boundaries on the left and upper side of the
   * canvas. This is useful for diagrams that have white space there.
   * Everything beneath these minimum values will be cropped. 
   * It's also possible to pass a specific font name and a class loader for the icon images.
   * 
   */
  public DefaultProcessDiagramCanvas(int width, int height, int minX, int minY, String imageType, 
      String activityFontName, String labelFontName, String annotationFontName, ClassLoader customClassLoader) {
    
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.minX = minX;
    this.minY = minY;
    if (activityFontName != null) {
      this.activityFontName = activityFontName;
    }
    if (labelFontName != null) {
      this.labelFontName = labelFontName;
    }
    if (annotationFontName != null) {
      this.annotationFontName = annotationFontName;
    }
    this.customClassLoader = customClassLoader;
    
    initialize(imageType);
  }

  /**
   * Creates an empty canvas with given width and height.
   * 
   * Allows to specify minimal boundaries on the left and upper side of the
   * canvas. This is useful for diagrams that have white space there (eg
   * Signavio). Everything beneath these minimum values will be cropped.
   * 
   * @param minX
   *          Hint that will be used when generating the image. Parts that fall
   *          below minX on the horizontal scale will be cropped.
   * @param minY
   *          Hint that will be used when generating the image. Parts that fall
   *          below minX on the horizontal scale will be cropped.
   */
  public DefaultProcessDiagramCanvas(int width, int height, int minX, int minY, String imageType) {
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.minX = minX;
    this.minY = minY;
    
    initialize(imageType);
  }
  
  public void initialize(String imageType) {
    if ("png".equalsIgnoreCase(imageType)) {
      this.processDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_ARGB);
    } else {
      this.processDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_RGB);
    }
    
    this.g = processDiagram.createGraphics();
    if ("png".equalsIgnoreCase(imageType) == false) {
      this.g.setBackground(new Color(255, 255, 255, 0));
      this.g.clearRect(0, 0, canvasWidth, canvasHeight);
    }

    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setPaint(Color.black);
    
    Font font = new Font(activityFontName, Font.BOLD, FONT_SIZE);
    g.setFont(font);
    this.fontMetrics = g.getFontMetrics();

    LABEL_FONT = new Font(labelFontName, Font.ITALIC, 10);
    ANNOTATION_FONT = new Font(annotationFontName, Font.PLAIN, FONT_SIZE);
    
    try {
      USERTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/userTask.png", customClassLoader));
      SCRIPTTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/scriptTask.png", customClassLoader));
      SERVICETASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/serviceTask.png", customClassLoader));
      RECEIVETASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/receiveTask.png", customClassLoader));
      SENDTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/sendTask.png", customClassLoader));
      MANUALTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/manualTask.png", customClassLoader));
      BUSINESS_RULE_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/businessRuleTask.png", customClassLoader));
      SHELL_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/shellTask.png", customClassLoader));
      CAMEL_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/camelTask.png", customClassLoader));
      MULE_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/muleTask.png", customClassLoader));
      
      TIMER_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/timer.png", customClassLoader));
      COMPENSATE_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/compensate-throw.png", customClassLoader));
      COMPENSATE_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/compensate.png", customClassLoader));
      ERROR_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/error-throw.png", customClassLoader));
      ERROR_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/error.png", customClassLoader));
      MESSAGE_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/message-throw.png", customClassLoader));
      MESSAGE_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/message.png", customClassLoader));
      SIGNAL_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/signal-throw.png", customClassLoader));
      SIGNAL_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/signal.png", customClassLoader));
    } catch (IOException e) {
      LOGGER.warn("Could not load image for process diagram creation: {}", e.getMessage());
    }
  }

  /**
   * Generates an image of what currently is drawn on the canvas.
   * 
   * Throws an {@link ActivitiException} when {@link #close()} is already
   * called.
   */
  public InputStream generateImage(String imageType) {
    if (closed) {
      throw new ActivitiImageException("ProcessDiagramGenerator already closed");
    }

    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try {
      ImageIO.write(processDiagram, imageType, out);
      
    } catch (IOException e) {
      throw new ActivitiImageException("Error while generating process image", e);
    } finally {
      try {
        if (out != null) {
          out.close();
        }
      } catch(IOException ignore) {
        // Exception is silently ignored
      }
    }
    return new ByteArrayInputStream(out.toByteArray());
  }
  
  /**
   * Generates an image of what currently is drawn on the canvas.
   * 
   * Throws an {@link ActivitiException} when {@link #close()} is already
   * called.
   */
  public BufferedImage generateBufferedImage(String imageType) {
    if (closed) {
      throw new ActivitiImageException("ProcessDiagramGenerator already closed");
    }

    // Try to remove white space
    minX = (minX <= 5) ? 5 : minX;
    minY = (minY <= 5) ? 5 : minY;
    BufferedImage imageToSerialize = processDiagram;
    if (minX >= 0 && minY >= 0) {
      imageToSerialize = processDiagram.getSubimage(minX - 5, minY - 5, canvasWidth - minX + 5, canvasHeight - minY + 5);
    }
    return imageToSerialize;
  }

  /**
   * Closes the canvas which dissallows further drawing and releases graphical
   * resources.
   */
  public void close() {
    g.dispose();
    closed = true;
  }

  public void drawNoneStartEvent(GraphicInfo graphicInfo) {
    drawStartEvent(graphicInfo, null, 1.0);
  }

  public void drawTimerStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, TIMER_IMAGE, scaleFactor);
  }
  
  public void drawSignalStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, SIGNAL_CATCH_IMAGE, scaleFactor);
  }
  
  public void drawMessageStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, MESSAGE_CATCH_IMAGE, scaleFactor);
  }

  public void drawStartEvent(GraphicInfo graphicInfo, BufferedImage image, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    g.setPaint(EVENT_COLOR);
    Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    g.fill(circle);
    g.setPaint(EVENT_BORDER_COLOR);
    g.draw(circle);
    g.setPaint(originalPaint);
    if (image != null) {
      // calculate coordinates to center image
      int imageX = (int) Math.round(graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / 2 * scaleFactor));
      int imageY = (int) Math.round(graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / 2 * scaleFactor));  
      g.drawImage(image, imageX, imageY,
          (int) (image.getWidth() / scaleFactor), (int) (image.getHeight() / scaleFactor), null);
    }

  }

  public void drawNoneEndEvent(GraphicInfo graphicInfo, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();
    g.setPaint(EVENT_COLOR);
    Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    g.fill(circle);
    g.setPaint(EVENT_BORDER_COLOR);
    if (scaleFactor == 1.0) {
      g.setStroke(END_EVENT_STROKE);
    } else {
      g.setStroke(new BasicStroke(2.0f));
    }
    g.draw(circle);
    g.setStroke(originalStroke);
    g.setPaint(originalPaint);
  }

  public void drawErrorEndEvent(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawErrorEndEvent(graphicInfo, scaleFactor);
    if (scaleFactor == 1.0) {
      drawLabel(name, graphicInfo);
    }
  }
  
  public void drawErrorEndEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawNoneEndEvent(graphicInfo, scaleFactor);
    g.drawImage(ERROR_THROW_IMAGE, (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 4)), 
        (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 4)), 
        (int) (ERROR_THROW_IMAGE.getWidth() / scaleFactor), 
        (int) (ERROR_THROW_IMAGE.getHeight() / scaleFactor), null);
  }
  
  public void drawErrorStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawNoneStartEvent(graphicInfo);
    g.drawImage(ERROR_CATCH_IMAGE, (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 4)), 
        (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 4)), 
        (int) (ERROR_CATCH_IMAGE.getWidth() / scaleFactor), 
        (int) (ERROR_CATCH_IMAGE.getHeight() / scaleFactor), null);
  }

  public void drawCatchingEvent(GraphicInfo graphicInfo, boolean isInterrupting, 
      BufferedImage image, String eventType, double scaleFactor) {
    
    // event circles
    Ellipse2D outerCircle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    int innerCircleSize = (int) (4 / scaleFactor);
    if (innerCircleSize == 0) {
      innerCircleSize = 1;
    }
    int innerCircleX = (int) graphicInfo.getX() + innerCircleSize;
    int innerCircleY = (int) graphicInfo.getY() + innerCircleSize;
    int innerCircleWidth = (int) graphicInfo.getWidth() - (2 * innerCircleSize);
    int innerCircleHeight = (int) graphicInfo.getHeight() - (2 * innerCircleSize);
    Ellipse2D innerCircle = new Ellipse2D.Double(innerCircleX, innerCircleY, innerCircleWidth, innerCircleHeight);

    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();
    g.setPaint(EVENT_COLOR);
    g.fill(outerCircle);

    g.setPaint(EVENT_BORDER_COLOR);
    if (isInterrupting == false) 
      g.setStroke(NON_INTERRUPTING_EVENT_STROKE);
    g.draw(outerCircle);
    g.setStroke(originalStroke);
    g.setPaint(originalPaint);
    g.draw(innerCircle);

    if (image != null) {
      // calculate coordinates to center image
      int imageX = (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / 2 * scaleFactor));
      int imageY = (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / 2 * scaleFactor));  
      if (scaleFactor == 1.0 && "timer".equals(eventType)) {
        // move image one pixel to center timer image
        imageX++;
        imageY++;
      }
      g.drawImage(image, imageX, imageY, (int) (image.getWidth() / scaleFactor), 
          (int) (image.getHeight() / scaleFactor), null);
    }
  }

  public void drawCatchingCompensateEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingCompensateEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingCompensateEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, COMPENSATE_CATCH_IMAGE, "compensate", scaleFactor);
  }

  public void drawCatchingTimerEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingTimerEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingTimerEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, TIMER_IMAGE, "timer", scaleFactor);
  }

  public void drawCatchingErrorEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingErrorEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingErrorEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, ERROR_CATCH_IMAGE, "error", scaleFactor);
  }

  public void drawCatchingSignalEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingSignalEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingSignalEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, SIGNAL_CATCH_IMAGE, "signal", scaleFactor);
  }
  
  public void drawCatchingMessageEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, MESSAGE_CATCH_IMAGE, "message", scaleFactor);
  }

  public void drawCatchingMessageEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, MESSAGE_CATCH_IMAGE, "message", scaleFactor);
    drawLabel(name, graphicInfo);
  }
  
  public void drawThrowingCompensateEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, COMPENSATE_THROW_IMAGE, "compensate", scaleFactor);
  }

  public void drawThrowingSignalEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, SIGNAL_THROW_IMAGE, "signal", scaleFactor);
  }
  
  public void drawThrowingNoneEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, null, "none", scaleFactor);
  }

  public void drawSequenceflow(int srcX, int srcY, int targetX, int targetY, boolean conditional, double scaleFactor) {
    drawSequenceflow(srcX, srcY, targetX, targetY, conditional, false, scaleFactor);
  }
  
  public void drawSequenceflow(int srcX, int srcY, int targetX, int targetY, boolean conditional, boolean highLighted, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    if (highLighted)
      g.setPaint(HIGHLIGHT_COLOR);

    Line2D.Double line = new Line2D.Double(srcX, srcY, targetX, targetY);
    g.draw(line);
    drawArrowHead(line, scaleFactor);

    if (conditional) {
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }

    if (highLighted)
      g.setPaint(originalPaint);
  }

  public void drawAssociation(int[] xPoints, int[] yPoints, AssociationDirection associationDirection, boolean highLighted, double scaleFactor) {
    boolean conditional = false, isDefault = false;
    drawConnection(xPoints, yPoints, conditional, isDefault, "association", associationDirection, highLighted, scaleFactor);
  }

  public void drawSequenceflow(int[] xPoints, int[] yPoints, boolean conditional, boolean isDefault, boolean highLighted, double scaleFactor) {
	  drawConnection(xPoints, yPoints, conditional, isDefault, "sequenceFlow", AssociationDirection.ONE, highLighted, scaleFactor);
  }
  
  public void drawConnection(int[] xPoints, int[] yPoints, boolean conditional, boolean isDefault, String connectionType, 
      AssociationDirection associationDirection, boolean highLighted, double scaleFactor) {
    
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();

    g.setPaint(CONNECTION_COLOR);
    if (connectionType.equals("association")) {
      g.setStroke(ASSOCIATION_STROKE);
    } else if (highLighted) {
      g.setPaint(HIGHLIGHT_COLOR);
      g.setStroke(HIGHLIGHT_FLOW_STROKE);
    }

    for (int i=1; i<xPoints.length; i++) {
      Integer sourceX = xPoints[i - 1];
      Integer sourceY = yPoints[i - 1];
      Integer targetX = xPoints[i];
      Integer targetY = yPoints[i];
      Line2D.Double line = new Line2D.Double(sourceX, sourceY, targetX, targetY);
      g.draw(line);
    }
  
    if (isDefault){
      Line2D.Double line = new Line2D.Double(xPoints[0], yPoints[0], xPoints[1], yPoints[1]);
      drawDefaultSequenceFlowIndicator(line, scaleFactor);
    }

    if (conditional) {
      Line2D.Double line = new Line2D.Double(xPoints[0], yPoints[0], xPoints[1], yPoints[1]);
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }
  
    if (associationDirection.equals(AssociationDirection.ONE) || associationDirection.equals(AssociationDirection.BOTH)) {
      Line2D.Double line = new Line2D.Double(xPoints[xPoints.length-2], yPoints[xPoints.length-2], xPoints[xPoints.length-1], yPoints[xPoints.length-1]);
      drawArrowHead(line, scaleFactor);
    }
    if (associationDirection.equals(AssociationDirection.BOTH)) {
      Line2D.Double line = new Line2D.Double(xPoints[1], yPoints[1], xPoints[0], yPoints[0]);
      drawArrowHead(line, scaleFactor);
    }
    g.setPaint(originalPaint);
    g.setStroke(originalStroke);
  }

  public void drawSequenceflowWithoutArrow(int srcX, int srcY, int targetX, int targetY, boolean conditional, double scaleFactor) {
    drawSequenceflowWithoutArrow(srcX, srcY, targetX, targetY, conditional, false, scaleFactor);
  }

  public void drawSequenceflowWithoutArrow(int srcX, int srcY, int targetX, int targetY, boolean conditional, boolean highLighted, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    if (highLighted)
      g.setPaint(HIGHLIGHT_COLOR);

    Line2D.Double line = new Line2D.Double(srcX, srcY, targetX, targetY);
    g.draw(line);

    if (conditional) {
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }

    if (highLighted)
      g.setPaint(originalPaint);
  }

  public void drawArrowHead(Line2D.Double line, double scaleFactor) {
    int doubleArrowWidth = (int) (2 * ARROW_WIDTH / scaleFactor);
    if (doubleArrowWidth == 0) {
      doubleArrowWidth = 2;
    }
    Polygon arrowHead = new Polygon();
    arrowHead.addPoint(0, 0);
    int arrowHeadPoint = (int) (-ARROW_WIDTH / scaleFactor);
    if (arrowHeadPoint == 0) {
      arrowHeadPoint = -1;
    }
    arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);
    arrowHeadPoint = (int) (ARROW_WIDTH / scaleFactor);
    if (arrowHeadPoint == 0) {
      arrowHeadPoint = 1;
    }
    arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    transformation.translate(line.x2, line.y2);
    transformation.rotate((angle - Math.PI / 2d));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.fill(arrowHead);
    g.setTransform(originalTransformation);
  }

  public void drawDefaultSequenceFlowIndicator(Line2D.Double line, double scaleFactor) {
    double length = DEFAULT_INDICATOR_WIDTH / scaleFactor, halfOfLength = length/2, f = 8;
    Line2D.Double defaultIndicator = new Line2D.Double(-halfOfLength, 0, halfOfLength, 0);

    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    double dx = f * Math.cos(angle), dy = f * Math.sin(angle),
	       x1 = line.x1 + dx, y1 = line.y1 + dy;

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    transformation.translate(x1, y1);
    transformation.rotate((angle - 3 * Math.PI / 4));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.draw(defaultIndicator);

    g.setTransform(originalTransformation);
  }

  public void drawConditionalSequenceFlowIndicator(Line2D.Double line, double scaleFactor) {
    if (scaleFactor > 1.0) return;
    int horizontal = (int) (CONDITIONAL_INDICATOR_WIDTH * 0.7);
    int halfOfHorizontal = horizontal / 2;
    int halfOfVertical = CONDITIONAL_INDICATOR_WIDTH / 2;

    Polygon conditionalIndicator = new Polygon();
    conditionalIndicator.addPoint(0, 0);
    conditionalIndicator.addPoint(-halfOfHorizontal, halfOfVertical);
    conditionalIndicator.addPoint(0, CONDITIONAL_INDICATOR_WIDTH);
    conditionalIndicator.addPoint(halfOfHorizontal, halfOfVertical);

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    transformation.translate(line.x1, line.y1);
    transformation.rotate((angle - Math.PI / 2d));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.draw(conditionalIndicator);

    Paint originalPaint = g.getPaint();
    g.setPaint(CONDITIONAL_INDICATOR_COLOR);
    g.fill(conditionalIndicator);

    g.setPaint(originalPaint);
    g.setTransform(originalTransformation);
  }

  public void drawTask(BufferedImage icon, String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(name, graphicInfo);
    g.drawImage(icon, (int) (graphicInfo.getX() + ICON_PADDING / scaleFactor), 
        (int) (graphicInfo.getY() + ICON_PADDING / scaleFactor), 
        (int) (icon.getWidth() / scaleFactor), (int) (icon.getHeight() / scaleFactor), null);
  }

  public void drawTask(String name, GraphicInfo graphicInfo) {
    drawTask(name, graphicInfo, false);
  }
  
  public void drawPoolOrLane(String name, GraphicInfo graphicInfo) {
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    g.drawRect(x, y, width, height);
    
    // Add the name as text, vertical
    if(name != null && name.length() > 0) {
      // Include some padding
      int availableTextSpace = height - 6;

      // Create rotation for derived font
      AffineTransform transformation = new AffineTransform();
      transformation.setToIdentity();
      transformation.rotate(270 * Math.PI/180);

      Font currentFont = g.getFont();
      Font theDerivedFont = currentFont.deriveFont(transformation);
      g.setFont(theDerivedFont);
      
      String truncated = fitTextToWidth(name, availableTextSpace);
      int realWidth = fontMetrics.stringWidth(truncated);
      
      g.drawString(truncated, x + 2 + fontMetrics.getHeight(), 3 + y + availableTextSpace - (availableTextSpace - realWidth) / 2);
      g.setFont(currentFont);
    }
  }

  protected void drawTask(String name, GraphicInfo graphicInfo, boolean thickBorder) {
    Paint originalPaint = g.getPaint();
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
    // Create a new gradient paint for every task box, gradient depends on x and y and is not relative
    g.setPaint(TASK_BOX_COLOR);

    int arcR = 6;
    if (thickBorder)
    	arcR = 3;
    
    // shape
    RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcR, arcR);
    g.fill(rect);
    g.setPaint(TASK_BORDER_COLOR);

    if (thickBorder) {
      Stroke originalStroke = g.getStroke();
      g.setStroke(THICK_TASK_BORDER_STROKE);
      g.draw(rect);
      g.setStroke(originalStroke);
    } else {
      g.draw(rect);
    }

    g.setPaint(originalPaint);
    // text
    if (name != null && name.length() > 0) {
      int boxWidth = width - (2 * TEXT_PADDING);
      int boxHeight = height - 16 - ICON_PADDING - ICON_PADDING - MARKER_WIDTH - 2 - 2;
      int boxX = x + width/2 - boxWidth/2;
      int boxY = y + height/2 - boxHeight/2 + ICON_PADDING + ICON_PADDING - 2 - 2;
      
      drawMultilineCentredText(name, boxX, boxY, boxWidth, boxHeight);
    }
  }
  
  protected void drawMultilineCentredText(String text, int x, int y, int boxWidth, int boxHeight) {
    drawMultilineText(text, x, y, boxWidth, boxHeight, true);
  }

  protected void drawMultilineAnnotationText(String text, int x, int y, int boxWidth, int boxHeight) {
	  drawMultilineText(text, x, y, boxWidth, boxHeight, false);
  }
  
  protected void drawMultilineText(String text, int x, int y, int boxWidth, int boxHeight, boolean centered) {
    // Create an attributed string based in input text
    AttributedString attributedString = new AttributedString(text);
    attributedString.addAttribute(TextAttribute.FONT, g.getFont());
    attributedString.addAttribute(TextAttribute.FOREGROUND, Color.black);
    
    AttributedCharacterIterator characterIterator = attributedString.getIterator();
    
    int currentHeight = 0;
    // Prepare a list of lines of text we'll be drawing
    List<TextLayout> layouts = new ArrayList<TextLayout>();
    String lastLine = null;
    
    LineBreakMeasurer measurer = new LineBreakMeasurer(characterIterator, g.getFontRenderContext());
    
    TextLayout layout = null;
    while (measurer.getPosition() < characterIterator.getEndIndex() && currentHeight <= boxHeight) {
       
      int previousPosition = measurer.getPosition();
      
      // Request next layout
      layout = measurer.nextLayout(boxWidth);
      
      int height = ((Float)(layout.getDescent() + layout.getAscent() + layout.getLeading())).intValue();
      
      if(currentHeight + height > boxHeight) {
        // The line we're about to add should NOT be added anymore, append three dots to previous one instead
        // to indicate more text is truncated
        if (!layouts.isEmpty()) {
          layouts.remove(layouts.size() - 1);
          
          if(lastLine.length() >= 4) {
            lastLine = lastLine.substring(0, lastLine.length() - 4) + "...";
          }
          layouts.add(new TextLayout(lastLine, g.getFont(), g.getFontRenderContext()));
        }
        break;
      } else {
        layouts.add(layout);
        lastLine = text.substring(previousPosition, measurer.getPosition());
        currentHeight += height;
      }
    }
    
    
    int currentY = y + (centered ? ((boxHeight - currentHeight) /2) : 0);
    int currentX = 0;
    
    // Actually draw the lines
    for(TextLayout textLayout : layouts) {
      
      currentY += textLayout.getAscent();
      currentX = x + (centered ? ((boxWidth - ((Double)textLayout.getBounds().getWidth()).intValue()) /2) : 0);
      
      textLayout.draw(g, currentX, currentY);
      currentY += textLayout.getDescent() + textLayout.getLeading();
    }
    
  }
  

  protected String fitTextToWidth(String original, int width) {
    String text = original;

    // remove length for "..."
    int maxWidth = width - 10;

    while (fontMetrics.stringWidth(text + "...") > maxWidth && text.length() > 0) {
      text = text.substring(0, text.length() - 1);
    }

    if (!text.equals(original)) {
      text = text + "...";
    }

    return text;
  }

  public void drawUserTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(USERTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawScriptTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SCRIPTTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawServiceTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SERVICETASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawReceiveTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(RECEIVETASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawSendTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SENDTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawManualTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(MANUALTASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawBusinessRuleTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(BUSINESS_RULE_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawCamelTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(CAMEL_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawMuleTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(MULE_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawExpandedSubProcess(String name, GraphicInfo graphicInfo, Boolean isTriggeredByEvent, double scaleFactor) {
    RoundRectangle2D rect = new RoundRectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight(), 8, 8);
    
    // Use different stroke (dashed)
    if (isTriggeredByEvent) {
      Stroke originalStroke = g.getStroke();
      g.setStroke(EVENT_SUBPROCESS_STROKE);
      g.draw(rect);
      g.setStroke(originalStroke);
    } else {
      Paint originalPaint = g.getPaint();
      g.setPaint(SUBPROCESS_BOX_COLOR);
      g.fill(rect);
      g.setPaint(SUBPROCESS_BORDER_COLOR);
      g.draw(rect);
      g.setPaint(originalPaint);
    }

    if (scaleFactor == 1.0 && name != null && !name.isEmpty()) {
      String text = fitTextToWidth(name, (int) graphicInfo.getWidth());
      g.drawString(text, (int) graphicInfo.getX() + 10, (int) graphicInfo.getY() + 15);
    }
  }

  public void drawCollapsedSubProcess(String name, GraphicInfo graphicInfo, Boolean isTriggeredByEvent) {
    drawCollapsedTask(name, graphicInfo, false);
  }

  public void drawCollapsedCallActivity(String name, GraphicInfo graphicInfo) {
    drawCollapsedTask(name, graphicInfo, true);
  }

  protected void drawCollapsedTask(String name, GraphicInfo graphicInfo, boolean thickBorder) {
    // The collapsed marker is now visualized separately
    drawTask(name, graphicInfo, thickBorder);
  }

  public void drawCollapsedMarker(int x, int y, int width, int height) {
    // rectangle
    int rectangleWidth = MARKER_WIDTH;
    int rectangleHeight = MARKER_WIDTH;
    Rectangle rect = new Rectangle(x + (width - rectangleWidth) / 2, y + height - rectangleHeight - 3, rectangleWidth, rectangleHeight);
    g.draw(rect);

    // plus inside rectangle
    Line2D.Double line = new Line2D.Double(rect.getCenterX(), rect.getY() + 2, rect.getCenterX(), rect.getMaxY() - 2);
    g.draw(line);
    line = new Line2D.Double(rect.getMinX() + 2, rect.getCenterY(), rect.getMaxX() - 2, rect.getCenterY());
    g.draw(line);
  }

  public void drawActivityMarkers(int x, int y, int width, int height, boolean multiInstanceSequential, boolean multiInstanceParallel, boolean collapsed) {
    if (collapsed) {
      if (!multiInstanceSequential && !multiInstanceParallel) {
        drawCollapsedMarker(x, y, width, height);
      } else {
        drawCollapsedMarker(x - MARKER_WIDTH / 2 - 2, y, width, height);
        if (multiInstanceSequential) {
          drawMultiInstanceMarker(true, x + MARKER_WIDTH / 2 + 2, y, width, height);
        } else {
          drawMultiInstanceMarker(false, x + MARKER_WIDTH / 2 + 2, y, width, height);
        }
      }
    } else {
      if (multiInstanceSequential) {
        drawMultiInstanceMarker(true, x, y, width, height);
      } else if (multiInstanceParallel) {
        drawMultiInstanceMarker(false, x, y, width, height);
      }
    }
  }

  public void drawGateway(GraphicInfo graphicInfo) {
    Polygon rhombus = new Polygon();
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
    rhombus.addPoint(x, y + (height / 2));
    rhombus.addPoint(x + (width / 2), y + height);
    rhombus.addPoint(x + width, y + (height / 2));
    rhombus.addPoint(x + (width / 2), y);
    g.draw(rhombus);
  }

  public void drawParallelGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    if (scaleFactor == 1.0) {
      // plus inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Line2D.Double line = new Line2D.Double(x + 10, y + height / 2, x + width - 10, y + height / 2); // horizontal
      g.draw(line);
      line = new Line2D.Double(x + width / 2, y + height - 10, x + width / 2, y + 10); // vertical
      g.draw(line);
      g.setStroke(orginalStroke);
    }
  }

  public void drawExclusiveGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    int quarterWidth = width / 4;
    int quarterHeight = height / 4;

    if (scaleFactor == 1.0) {
      // X inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Line2D.Double line = new Line2D.Double(x + quarterWidth + 3, y + quarterHeight + 3, x + 3 * quarterWidth - 3, y + 3 * quarterHeight - 3);
      g.draw(line);
      line = new Line2D.Double(x + quarterWidth + 3, y + 3 * quarterHeight - 3, x + 3 * quarterWidth - 3, y + quarterHeight + 3);
      g.draw(line);
      g.setStroke(orginalStroke);
    }
  }

  public void drawInclusiveGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    int diameter = width / 2;

    if (scaleFactor == 1.0) {
      // circle inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Ellipse2D.Double circle = new Ellipse2D.Double(((width - diameter) / 2) + x, ((height - diameter) / 2) + y, diameter, diameter);
      g.draw(circle);
      g.setStroke(orginalStroke);
    }
  }
  
  public void drawEventBasedGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    
    if (scaleFactor == 1.0) {
      int x = (int) graphicInfo.getX();
      int y = (int) graphicInfo.getY();
      int width = (int) graphicInfo.getWidth();
      int height = (int) graphicInfo.getHeight();
      
      double scale = .6;
      
      GraphicInfo eventInfo = new GraphicInfo();
      eventInfo.setX(x + width*(1-scale)/2);
      eventInfo.setY(y + height*(1-scale)/2);
      eventInfo.setWidth(width*scale);
      eventInfo.setHeight(height*scale);
      drawCatchingEvent(eventInfo, true, null, "eventGateway", scaleFactor);
      
      double r = width / 6.;
      
      // create pentagon (coords with respect to center)
      int topX = (int)(.95 * r); // top right corner
      int topY = (int)(-.31 * r);
      int bottomX = (int)(.59 * r); // bottom right corner
      int bottomY = (int)(.81 * r);
      
      int[] xPoints = new int[]{ 0, topX, bottomX, -bottomX, -topX };
      int[] yPoints = new int[]{ -(int)r, topY, bottomY, bottomY, topY };
      Polygon pentagon = new Polygon(xPoints, yPoints, 5);
      pentagon.translate(x+width/2, y+width/2);
  
      // draw
      g.drawPolygon(pentagon);
    }
  }

  public void drawMultiInstanceMarker(boolean sequential, int x, int y, int width, int height) {
    int rectangleWidth = MARKER_WIDTH;
    int rectangleHeight = MARKER_WIDTH;
    int lineX = x + (width - rectangleWidth) / 2;
    int lineY = y + height - rectangleHeight - 3;

    Stroke orginalStroke = g.getStroke();
    g.setStroke(MULTI_INSTANCE_STROKE);

    if (sequential) {
      g.draw(new Line2D.Double(lineX, lineY, lineX + rectangleWidth, lineY));
      g.draw(new Line2D.Double(lineX, lineY + rectangleHeight / 2, lineX + rectangleWidth, lineY + rectangleHeight / 2));
      g.draw(new Line2D.Double(lineX, lineY + rectangleHeight, lineX + rectangleWidth, lineY + rectangleHeight));
    } else {
      g.draw(new Line2D.Double(lineX, lineY, lineX, lineY + rectangleHeight));
      g.draw(new Line2D.Double(lineX + rectangleWidth / 2, lineY, lineX + rectangleWidth / 2, lineY + rectangleHeight));
      g.draw(new Line2D.Double(lineX + rectangleWidth, lineY, lineX + rectangleWidth, lineY + rectangleHeight));
    }

    g.setStroke(orginalStroke);
  }

  public void drawHighLight(int x, int y, int width, int height) {
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();

    g.setPaint(HIGHLIGHT_COLOR);
    g.setStroke(THICK_TASK_BORDER_STROKE);

    RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, 20, 20);
    g.draw(rect);

    g.setPaint(originalPaint);
    g.setStroke(originalStroke);
  }

  public void drawTextAnnotation(String text, GraphicInfo graphicInfo) {
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
	  Font originalFont = g.getFont();
	  Stroke originalStroke = g.getStroke();
	  
	  g.setFont(ANNOTATION_FONT);
	  
	  Path2D path = new Path2D.Double();
	  x += .5;
	  int lineLength = 18;
	  path.moveTo(x + lineLength, y);
	  path.lineTo(x, y);
	  path.lineTo(x, y + height);
	  path.lineTo(x + lineLength, y + height);
	  
	  path.lineTo(x + lineLength, y + height -1);
	  path.lineTo(x + 1, y + height -1);
	  path.lineTo(x + 1, y + 1);
	  path.lineTo(x + lineLength, y + 1);
	  path.closePath();
	  
	  g.draw(path);
	  
	  int boxWidth = width - (2 * ANNOTATION_TEXT_PADDING);
    int boxHeight = height - (2 * ANNOTATION_TEXT_PADDING);
    int boxX = x + width/2 - boxWidth/2;
    int boxY = y + height/2 - boxHeight/2;
    
    if (text != null && text.isEmpty() == false) {
      drawMultilineAnnotationText(text, boxX, boxY, boxWidth, boxHeight);
    }
	  
	  // restore originals
    g.setFont(originalFont);
    g.setStroke(originalStroke);
  }
  
  public void drawLabel(String text, GraphicInfo graphicInfo){
	  drawLabel(text, graphicInfo, true);
  }
  public void drawLabel(String text, GraphicInfo graphicInfo, boolean centered){
	float interline = 1.0f;
	
    // text
    if (text != null && text.length()>0) {
      Paint originalPaint = g.getPaint();
      Font originalFont = g.getFont();

      g.setPaint(LABEL_COLOR);
      g.setFont(LABEL_FONT);

      int wrapWidth = 100;
      int textY = (int) graphicInfo.getY();
      
      // TODO: use drawMultilineText()
      AttributedString as = new AttributedString(text);
      as.addAttribute(TextAttribute.FOREGROUND, g.getPaint());
      as.addAttribute(TextAttribute.FONT, g.getFont());
      AttributedCharacterIterator aci = as.getIterator();
      FontRenderContext frc = new FontRenderContext(null, true, false);
      LineBreakMeasurer lbm = new LineBreakMeasurer(aci, frc);
      
      while (lbm.getPosition() < text.length()) {
    	  TextLayout tl = lbm.nextLayout(wrapWidth);
    	  textY += tl.getAscent();
    	  Rectangle2D bb = tl.getBounds();
    	  double tX = graphicInfo.getX();
    	  if (centered) {
    	  	tX += (int) (graphicInfo.getWidth() / 2 - bb.getWidth() / 2);
    	  }
    	  tl.draw(g, (float) tX, textY);
    	  textY += tl.getDescent() + tl.getLeading() + (interline - 1.0f) * tl.getAscent();
      }
  
      // restore originals
      g.setFont(originalFont);
      g.setPaint(originalPaint);
    }
  }

  /**
   * This method makes coordinates of connection flow better.
   * @param sourceShapeType
   * @param targetShapeType
   * @param sourceGraphicInfo
   * @param targetGraphicInfo
   * @param graphicInfoList
   * 
   */
  public List<GraphicInfo> connectionPerfectionizer(SHAPE_TYPE sourceShapeType, SHAPE_TYPE targetShapeType, GraphicInfo sourceGraphicInfo, GraphicInfo targetGraphicInfo, List<GraphicInfo> graphicInfoList) {
    Shape shapeFirst = createShape(sourceShapeType, sourceGraphicInfo);
    Shape shapeLast = createShape(targetShapeType, targetGraphicInfo);

    if (graphicInfoList != null && graphicInfoList.size() > 0) {
      GraphicInfo graphicInfoFirst = graphicInfoList.get(0);
      GraphicInfo graphicInfoLast = graphicInfoList.get(graphicInfoList.size()-1);
      if (shapeFirst != null) {
        graphicInfoFirst.setX(shapeFirst.getBounds2D().getCenterX());
        graphicInfoFirst.setY(shapeFirst.getBounds2D().getCenterY());
      }
      if (shapeLast != null) {
        graphicInfoLast.setX(shapeLast.getBounds2D().getCenterX());
        graphicInfoLast.setY(shapeLast.getBounds2D().getCenterY());
      }
  
      Point p = null;
      
      if (shapeFirst != null) {
        Line2D.Double lineFirst = new Line2D.Double(graphicInfoFirst.getX(), graphicInfoFirst.getY(), graphicInfoList.get(1).getX(), graphicInfoList.get(1).getY());
        p = getIntersection(shapeFirst, lineFirst);
        if (p != null) {
          graphicInfoFirst.setX(p.getX());
          graphicInfoFirst.setY(p.getY());
        }
      }
  
      if (shapeLast != null) {
        Line2D.Double lineLast = new Line2D.Double(graphicInfoLast.getX(), graphicInfoLast.getY(), graphicInfoList.get(graphicInfoList.size()-2).getX(), graphicInfoList.get(graphicInfoList.size()-2).getY());
        p = getIntersection(shapeLast, lineLast);
        if (p != null) {
          graphicInfoLast.setX(p.getX());
          graphicInfoLast.setY(p.getY());
        }
      }
    }

    return graphicInfoList;
  }

  /**
   * This method creates shape by type and coordinates.
   * @param shapeType
   * @param graphicInfo
   * @return Shape
   */
  private static Shape createShape(SHAPE_TYPE shapeType, GraphicInfo graphicInfo) {
    if (SHAPE_TYPE.Rectangle.equals(shapeType)) {
      // source is rectangle
      return new Rectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());       
    } else if (SHAPE_TYPE.Rhombus.equals(shapeType)) {
      // source is rhombus
      Path2D.Double rhombus = new Path2D.Double();
      rhombus.moveTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY() + graphicInfo.getHeight());
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY());
      rhombus.lineTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.closePath();
      return rhombus;
    } else if (SHAPE_TYPE.Ellipse.equals(shapeType)) {
      // source is ellipse
      return new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());
    } else {
      // unknown source element, just do not correct coordinates
    }
    return null;
  }

  /**
   * This method returns intersection point of shape border and line.
   * 
   * @param shape
   * @param line
   * @return Point
   */
  private static Point getIntersection(Shape shape, Line2D.Double line) {
    if (shape instanceof Ellipse2D) {
      return getEllipseIntersection(shape, line);
    } else if (shape instanceof Rectangle2D || shape instanceof Path2D) {
      return getShapeIntersection(shape, line);
    } else {
      // something strange
      return null;
    }
  }

    /**
     * This method calculates ellipse intersection with line
     * @param shape
     *                  Bounds of this shape used to calculate parameters of inscribed into this bounds ellipse.
     * @param line
     * @return Intersection point
     */
  private static Point getEllipseIntersection(Shape shape, Line2D.Double line) {
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    double x = shape.getBounds2D().getWidth()/2 * Math.cos(angle) + shape.getBounds2D().getCenterX();
    double y = shape.getBounds2D().getHeight()/2 * Math.sin(angle) + shape.getBounds2D().getCenterY();
    Point p = new Point();
    p.setLocation(x, y);
    return p;
  }

  /**
   * This method calculates shape intersection with line.
   * 
   * @param shape
   * @param line
   * @return Intersection point
   */
  private static Point getShapeIntersection(Shape shape, Line2D.Double line) {
    PathIterator it = shape.getPathIterator(null);
    double[] coords = new double[6];
    double[] pos = new double[2];
    Line2D.Double l = new Line2D.Double();
    while (!it.isDone()) {
      int type = it.currentSegment(coords);
      switch (type) {
      case PathIterator.SEG_MOVETO:
        pos[0] = coords[0];
        pos[1] = coords[1];
        break;
      case PathIterator.SEG_LINETO:
        l = new Line2D.Double(pos[0], pos[1], coords[0], coords[1]);
        if (line.intersectsLine(l)) {
          return getLinesIntersection(line, l);
        }
        pos[0] = coords[0];
        pos[1] = coords[1];
        break;
      case PathIterator.SEG_CLOSE:
        break;
      default:
        // whatever
      }
      it.next();
    }
    return null;
  }

  /**
   * This method calculates intersections of two lines.
   * @param a Line 1
   * @param b Line 2
   * @return Intersection point
   */
  private static Point getLinesIntersection(Line2D a, Line2D b) {
    double d  = (a.getX1()-a.getX2())*(b.getY2()-b.getY1()) - (a.getY1()-a.getY2())*(b.getX2()-b.getX1());
    double da = (a.getX1()-b.getX1())*(b.getY2()-b.getY1()) - (a.getY1()-b.getY1())*(b.getX2()-b.getX1());
    // double db = (a.getX1()-a.getX2())*(a.getY1()-b.getY1()) - (a.getY1()-a.getY2())*(a.getX1()-b.getX1());
    double ta = da/d;
    // double tb = db/d;
    Point p = new Point();
    p.setLocation(a.getX1()+ta*(a.getX2()-a.getX1()), a.getY1()+ta*(a.getY2()-a.getY1()));
    return p;
  }
}
!@#$%
20190526_171328,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.image.impl;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.font.FontRenderContext;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;

import org.activiti.bpmn.model.AssociationDirection;
import org.activiti.bpmn.model.GraphicInfo;
import org.activiti.image.exception.ActivitiImageException;
import org.activiti.image.util.ReflectUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Represents a canvas on which BPMN 2.0 constructs can be drawn.
 * 
 * Some of the icons used are licensed under a Creative Commons Attribution 2.5
 * License, see http://www.famfamfam.com/lab/icons/silk/
 * 
 * @see org.activiti.engine.impl.bpmn.diagram.DefaultProcessDiagramGenerator
 * @author Joram Barrez
 */
public class DefaultProcessDiagramCanvas {

  protected static final Logger LOGGER = LoggerFactory.getLogger(DefaultProcessDiagramCanvas.class);
  public enum SHAPE_TYPE {Rectangle, Rhombus, Ellipse}

  // Predefined sized
  protected static final int ARROW_WIDTH = 5;
  protected static final int CONDITIONAL_INDICATOR_WIDTH = 16;
  protected static final int DEFAULT_INDICATOR_WIDTH = 10;
  protected static final int MARKER_WIDTH = 12;
  protected static final int FONT_SIZE = 11;
  protected static final int FONT_SPACING = 2;
  protected static final int TEXT_PADDING = 3;
  protected static final int ANNOTATION_TEXT_PADDING = 7;
  protected static final int LINE_HEIGHT = FONT_SIZE + FONT_SPACING;
  

  // Colors
  protected static Color TASK_BOX_COLOR = new Color(249, 249, 249);
  protected static Color SUBPROCESS_BOX_COLOR = new Color(255, 255, 255);
  protected static Color EVENT_COLOR = new Color(255, 255, 255);
  protected static Color CONNECTION_COLOR = new Color(88, 88, 88);
  protected static Color CONDITIONAL_INDICATOR_COLOR = new Color(255, 255, 255);
  protected static Color HIGHLIGHT_COLOR = Color.RED;
  protected static Color LABEL_COLOR = new Color(112, 146, 190);
  protected static Color TASK_BORDER_COLOR = new Color(187, 187, 187);
  protected static Color EVENT_BORDER_COLOR = new Color(88, 88, 88);
  protected static Color SUBPROCESS_BORDER_COLOR = new Color(0, 0, 0);
  
  // Fonts
  protected static Font LABEL_FONT = null;
  protected static Font ANNOTATION_FONT = new Font("Arial", Font.PLAIN, FONT_SIZE);
  protected static Font TASK_FONT = new Font("Arial", Font.PLAIN, FONT_SIZE);

  // Strokes
  protected static Stroke THICK_TASK_BORDER_STROKE = new BasicStroke(3.0f);
  protected static Stroke GATEWAY_TYPE_STROKE = new BasicStroke(3.0f);
  protected static Stroke END_EVENT_STROKE = new BasicStroke(3.0f);
  protected static Stroke MULTI_INSTANCE_STROKE = new BasicStroke(1.3f);
  protected static Stroke EVENT_SUBPROCESS_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 1.0f }, 0.0f);
  protected static Stroke NON_INTERRUPTING_EVENT_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 4.0f, 3.0f }, 0.0f);
  protected static Stroke HIGHLIGHT_FLOW_STROKE = new BasicStroke(1.3f);
  protected static Stroke ANNOTATION_STROKE = new BasicStroke(2.0f);
  protected static Stroke ASSOCIATION_STROKE = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 2.0f, 2.0f }, 0.0f);

  // icons
  protected static int ICON_PADDING = 5;
  protected static BufferedImage USERTASK_IMAGE;
  protected static BufferedImage SCRIPTTASK_IMAGE;
  protected static BufferedImage SERVICETASK_IMAGE;
  protected static BufferedImage RECEIVETASK_IMAGE;
  protected static BufferedImage SENDTASK_IMAGE;
  protected static BufferedImage MANUALTASK_IMAGE;
  protected static BufferedImage BUSINESS_RULE_TASK_IMAGE;
  protected static BufferedImage SHELL_TASK_IMAGE;
  protected static BufferedImage MULE_TASK_IMAGE;
  protected static BufferedImage CAMEL_TASK_IMAGE;
  
  protected static BufferedImage TIMER_IMAGE;
  protected static BufferedImage COMPENSATE_THROW_IMAGE;
  protected static BufferedImage COMPENSATE_CATCH_IMAGE;
  protected static BufferedImage ERROR_THROW_IMAGE;
  protected static BufferedImage ERROR_CATCH_IMAGE;
  protected static BufferedImage MESSAGE_THROW_IMAGE;
  protected static BufferedImage MESSAGE_CATCH_IMAGE;
  protected static BufferedImage SIGNAL_CATCH_IMAGE;
  protected static BufferedImage SIGNAL_THROW_IMAGE;

  protected int canvasWidth = -1;
  protected int canvasHeight = -1;
  protected int minX = -1;
  protected int minY = -1;
  protected BufferedImage processDiagram;
  protected Graphics2D g;
  protected FontMetrics fontMetrics;
  protected boolean closed;
  protected ClassLoader customClassLoader;
  protected String activityFontName = "Arial";
  protected String labelFontName = "Arial";
  
  /**
   * Creates an empty canvas with given width and height.
   * 
   * Allows to specify minimal boundaries on the left and upper side of the
   * canvas. This is useful for diagrams that have white space there.
   * Everything beneath these minimum values will be cropped. 
   * It's also possible to pass a specific font name and a class loader for the icon images.
   * 
   */
  public DefaultProcessDiagramCanvas(int width, int height, int minX, int minY, String imageType, 
      String activityFontName, String labelFontName, ClassLoader customClassLoader) {
    
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.minX = minX;
    this.minY = minY;
    if (activityFontName != null) {
      this.activityFontName = activityFontName;
    }
    if (labelFontName != null) {
      this.labelFontName = labelFontName;
    }
    this.customClassLoader = customClassLoader;
    
    initialize(imageType);
  }

  /**
   * Creates an empty canvas with given width and height.
   * 
   * Allows to specify minimal boundaries on the left and upper side of the
   * canvas. This is useful for diagrams that have white space there (eg
   * Signavio). Everything beneath these minimum values will be cropped.
   * 
   * @param minX
   *          Hint that will be used when generating the image. Parts that fall
   *          below minX on the horizontal scale will be cropped.
   * @param minY
   *          Hint that will be used when generating the image. Parts that fall
   *          below minX on the horizontal scale will be cropped.
   */
  public DefaultProcessDiagramCanvas(int width, int height, int minX, int minY, String imageType) {
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.minX = minX;
    this.minY = minY;
    
    initialize(imageType);
  }
  
  public void initialize(String imageType) {
    if ("png".equalsIgnoreCase(imageType)) {
      this.processDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_ARGB);
    } else {
      this.processDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_RGB);
    }
    
    this.g = processDiagram.createGraphics();
    if ("png".equalsIgnoreCase(imageType) == false) {
      this.g.setBackground(new Color(255, 255, 255, 0));
      this.g.clearRect(0, 0, canvasWidth, canvasHeight);
    }

    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setPaint(Color.black);
    
    Font font = new Font(activityFontName, Font.BOLD, FONT_SIZE);
    g.setFont(font);
    this.fontMetrics = g.getFontMetrics();

    LABEL_FONT = new Font(labelFontName, Font.ITALIC, 10);
    
    try {
      USERTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/userTask.png", customClassLoader));
      SCRIPTTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/scriptTask.png", customClassLoader));
      SERVICETASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/serviceTask.png", customClassLoader));
      RECEIVETASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/receiveTask.png", customClassLoader));
      SENDTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/sendTask.png", customClassLoader));
      MANUALTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/manualTask.png", customClassLoader));
      BUSINESS_RULE_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/businessRuleTask.png", customClassLoader));
      SHELL_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/shellTask.png", customClassLoader));
      CAMEL_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/camelTask.png", customClassLoader));
      MULE_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/muleTask.png", customClassLoader));
      
      TIMER_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/timer.png", customClassLoader));
      COMPENSATE_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/compensate-throw.png", customClassLoader));
      COMPENSATE_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/compensate.png", customClassLoader));
      ERROR_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/error-throw.png", customClassLoader));
      ERROR_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/error.png", customClassLoader));
      MESSAGE_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/message-throw.png", customClassLoader));
      MESSAGE_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/message.png", customClassLoader));
      SIGNAL_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/signal-throw.png", customClassLoader));
      SIGNAL_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/signal.png", customClassLoader));
    } catch (IOException e) {
      LOGGER.warn("Could not load image for process diagram creation: {}", e.getMessage());
    }
  }

  /**
   * Generates an image of what currently is drawn on the canvas.
   * 
   * Throws an {@link ActivitiException} when {@link #close()} is already
   * called.
   */
  public InputStream generateImage(String imageType) {
    if (closed) {
      throw new ActivitiImageException("ProcessDiagramGenerator already closed");
    }

    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try {
      ImageIO.write(processDiagram, imageType, out);
      
    } catch (IOException e) {
      throw new ActivitiImageException("Error while generating process image", e);
    } finally {
      try {
        if (out != null) {
          out.close();
        }
      } catch(IOException ignore) {
        // Exception is silently ignored
      }
    }
    return new ByteArrayInputStream(out.toByteArray());
  }
  
  /**
   * Generates an image of what currently is drawn on the canvas.
   * 
   * Throws an {@link ActivitiException} when {@link #close()} is already
   * called.
   */
  public BufferedImage generateBufferedImage(String imageType) {
    if (closed) {
      throw new ActivitiImageException("ProcessDiagramGenerator already closed");
    }

    // Try to remove white space
    minX = (minX <= 5) ? 5 : minX;
    minY = (minY <= 5) ? 5 : minY;
    BufferedImage imageToSerialize = processDiagram;
    if (minX >= 0 && minY >= 0) {
      imageToSerialize = processDiagram.getSubimage(minX - 5, minY - 5, canvasWidth - minX + 5, canvasHeight - minY + 5);
    }
    return imageToSerialize;
  }

  /**
   * Closes the canvas which dissallows further drawing and releases graphical
   * resources.
   */
  public void close() {
    g.dispose();
    closed = true;
  }

  public void drawNoneStartEvent(GraphicInfo graphicInfo) {
    drawStartEvent(graphicInfo, null, 1.0);
  }

  public void drawTimerStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, TIMER_IMAGE, scaleFactor);
  }
  
  public void drawSignalStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, SIGNAL_CATCH_IMAGE, scaleFactor);
  }
  
  public void drawMessageStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, MESSAGE_CATCH_IMAGE, scaleFactor);
  }

  public void drawStartEvent(GraphicInfo graphicInfo, BufferedImage image, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    g.setPaint(EVENT_COLOR);
    Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    g.fill(circle);
    g.setPaint(EVENT_BORDER_COLOR);
    g.draw(circle);
    g.setPaint(originalPaint);
    if (image != null) {
      // calculate coordinates to center image
      int imageX = (int) Math.round(graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / 2 * scaleFactor));
      int imageY = (int) Math.round(graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / 2 * scaleFactor));  
      g.drawImage(image, imageX, imageY,
          (int) (image.getWidth() / scaleFactor), (int) (image.getHeight() / scaleFactor), null);
    }

  }

  public void drawNoneEndEvent(GraphicInfo graphicInfo, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();
    g.setPaint(EVENT_COLOR);
    Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    g.fill(circle);
    g.setPaint(EVENT_BORDER_COLOR);
    if (scaleFactor == 1.0) {
      g.setStroke(END_EVENT_STROKE);
    } else {
      g.setStroke(new BasicStroke(2.0f));
    }
    g.draw(circle);
    g.setStroke(originalStroke);
    g.setPaint(originalPaint);
  }

  public void drawErrorEndEvent(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawErrorEndEvent(graphicInfo, scaleFactor);
    if (scaleFactor == 1.0) {
      drawLabel(name, graphicInfo);
    }
  }
  
  public void drawErrorEndEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawNoneEndEvent(graphicInfo, scaleFactor);
    g.drawImage(ERROR_THROW_IMAGE, (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 4)), 
        (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 4)), 
        (int) (ERROR_THROW_IMAGE.getWidth() / scaleFactor), 
        (int) (ERROR_THROW_IMAGE.getHeight() / scaleFactor), null);
  }
  
  public void drawErrorStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawNoneStartEvent(graphicInfo);
    g.drawImage(ERROR_CATCH_IMAGE, (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 4)), 
        (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 4)), 
        (int) (ERROR_CATCH_IMAGE.getWidth() / scaleFactor), 
        (int) (ERROR_CATCH_IMAGE.getHeight() / scaleFactor), null);
  }

  public void drawCatchingEvent(GraphicInfo graphicInfo, boolean isInterrupting, 
      BufferedImage image, String eventType, double scaleFactor) {
    
    // event circles
    Ellipse2D outerCircle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    int innerCircleSize = (int) (4 / scaleFactor);
    if (innerCircleSize == 0) {
      innerCircleSize = 1;
    }
    int innerCircleX = (int) graphicInfo.getX() + innerCircleSize;
    int innerCircleY = (int) graphicInfo.getY() + innerCircleSize;
    int innerCircleWidth = (int) graphicInfo.getWidth() - (2 * innerCircleSize);
    int innerCircleHeight = (int) graphicInfo.getHeight() - (2 * innerCircleSize);
    Ellipse2D innerCircle = new Ellipse2D.Double(innerCircleX, innerCircleY, innerCircleWidth, innerCircleHeight);

    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();
    g.setPaint(EVENT_COLOR);
    g.fill(outerCircle);

    g.setPaint(EVENT_BORDER_COLOR);
    if (isInterrupting == false) 
      g.setStroke(NON_INTERRUPTING_EVENT_STROKE);
    g.draw(outerCircle);
    g.setStroke(originalStroke);
    g.setPaint(originalPaint);
    g.draw(innerCircle);

    if (image != null) {
      // calculate coordinates to center image
      int imageX = (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / 2 * scaleFactor));
      int imageY = (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / 2 * scaleFactor));  
      if (scaleFactor == 1.0 && "timer".equals(eventType)) {
        // move image one pixel to center timer image
        imageX++;
        imageY++;
      }
      g.drawImage(image, imageX, imageY, (int) (image.getWidth() / scaleFactor), 
          (int) (image.getHeight() / scaleFactor), null);
    }
  }

  public void drawCatchingCompensateEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingCompensateEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingCompensateEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, COMPENSATE_CATCH_IMAGE, "compensate", scaleFactor);
  }

  public void drawCatchingTimerEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingTimerEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingTimerEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, TIMER_IMAGE, "timer", scaleFactor);
  }

  public void drawCatchingErrorEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingErrorEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingErrorEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, ERROR_CATCH_IMAGE, "error", scaleFactor);
  }

  public void drawCatchingSignalEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingSignalEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingSignalEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, SIGNAL_CATCH_IMAGE, "signal", scaleFactor);
  }
  
  public void drawCatchingMessageEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, MESSAGE_CATCH_IMAGE, "message", scaleFactor);
  }

  public void drawCatchingMessageEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, MESSAGE_CATCH_IMAGE, "message", scaleFactor);
    drawLabel(name, graphicInfo);
  }
  
  public void drawThrowingCompensateEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, COMPENSATE_THROW_IMAGE, "compensate", scaleFactor);
  }

  public void drawThrowingSignalEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, SIGNAL_THROW_IMAGE, "signal", scaleFactor);
  }
  
  public void drawThrowingNoneEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, null, "none", scaleFactor);
  }

  public void drawSequenceflow(int srcX, int srcY, int targetX, int targetY, boolean conditional, double scaleFactor) {
    drawSequenceflow(srcX, srcY, targetX, targetY, conditional, false, scaleFactor);
  }
  
  public void drawSequenceflow(int srcX, int srcY, int targetX, int targetY, boolean conditional, boolean highLighted, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    if (highLighted)
      g.setPaint(HIGHLIGHT_COLOR);

    Line2D.Double line = new Line2D.Double(srcX, srcY, targetX, targetY);
    g.draw(line);
    drawArrowHead(line, scaleFactor);

    if (conditional) {
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }

    if (highLighted)
      g.setPaint(originalPaint);
  }

  public void drawAssociation(int[] xPoints, int[] yPoints, AssociationDirection associationDirection, boolean highLighted, double scaleFactor) {
    boolean conditional = false, isDefault = false;
    drawConnection(xPoints, yPoints, conditional, isDefault, "association", associationDirection, highLighted, scaleFactor);
  }

  public void drawSequenceflow(int[] xPoints, int[] yPoints, boolean conditional, boolean isDefault, boolean highLighted, double scaleFactor) {
	  drawConnection(xPoints, yPoints, conditional, isDefault, "sequenceFlow", AssociationDirection.ONE, highLighted, scaleFactor);
  }
  
  public void drawConnection(int[] xPoints, int[] yPoints, boolean conditional, boolean isDefault, String connectionType, 
      AssociationDirection associationDirection, boolean highLighted, double scaleFactor) {
    
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();

    g.setPaint(CONNECTION_COLOR);
    if (connectionType.equals("association")) {
      g.setStroke(ASSOCIATION_STROKE);
    } else if (highLighted) {
      g.setPaint(HIGHLIGHT_COLOR);
      g.setStroke(HIGHLIGHT_FLOW_STROKE);
    }

    for (int i=1; i<xPoints.length; i++) {
      Integer sourceX = xPoints[i - 1];
      Integer sourceY = yPoints[i - 1];
      Integer targetX = xPoints[i];
      Integer targetY = yPoints[i];
      Line2D.Double line = new Line2D.Double(sourceX, sourceY, targetX, targetY);
      g.draw(line);
    }
  
    if (isDefault){
      Line2D.Double line = new Line2D.Double(xPoints[0], yPoints[0], xPoints[1], yPoints[1]);
      drawDefaultSequenceFlowIndicator(line, scaleFactor);
    }

    if (conditional) {
      Line2D.Double line = new Line2D.Double(xPoints[0], yPoints[0], xPoints[1], yPoints[1]);
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }
  
    if (associationDirection.equals(AssociationDirection.ONE) || associationDirection.equals(AssociationDirection.BOTH)) {
      Line2D.Double line = new Line2D.Double(xPoints[xPoints.length-2], yPoints[xPoints.length-2], xPoints[xPoints.length-1], yPoints[xPoints.length-1]);
      drawArrowHead(line, scaleFactor);
    }
    if (associationDirection.equals(AssociationDirection.BOTH)) {
      Line2D.Double line = new Line2D.Double(xPoints[1], yPoints[1], xPoints[0], yPoints[0]);
      drawArrowHead(line, scaleFactor);
    }
    g.setPaint(originalPaint);
    g.setStroke(originalStroke);
  }

  public void drawSequenceflowWithoutArrow(int srcX, int srcY, int targetX, int targetY, boolean conditional, double scaleFactor) {
    drawSequenceflowWithoutArrow(srcX, srcY, targetX, targetY, conditional, false, scaleFactor);
  }

  public void drawSequenceflowWithoutArrow(int srcX, int srcY, int targetX, int targetY, boolean conditional, boolean highLighted, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    if (highLighted)
      g.setPaint(HIGHLIGHT_COLOR);

    Line2D.Double line = new Line2D.Double(srcX, srcY, targetX, targetY);
    g.draw(line);

    if (conditional) {
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }

    if (highLighted)
      g.setPaint(originalPaint);
  }

  public void drawArrowHead(Line2D.Double line, double scaleFactor) {
    int doubleArrowWidth = (int) (2 * ARROW_WIDTH / scaleFactor);
    if (doubleArrowWidth == 0) {
      doubleArrowWidth = 2;
    }
    Polygon arrowHead = new Polygon();
    arrowHead.addPoint(0, 0);
    int arrowHeadPoint = (int) (-ARROW_WIDTH / scaleFactor);
    if (arrowHeadPoint == 0) {
      arrowHeadPoint = -1;
    }
    arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);
    arrowHeadPoint = (int) (ARROW_WIDTH / scaleFactor);
    if (arrowHeadPoint == 0) {
      arrowHeadPoint = 1;
    }
    arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    transformation.translate(line.x2, line.y2);
    transformation.rotate((angle - Math.PI / 2d));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.fill(arrowHead);
    g.setTransform(originalTransformation);
  }

  public void drawDefaultSequenceFlowIndicator(Line2D.Double line, double scaleFactor) {
    double length = DEFAULT_INDICATOR_WIDTH / scaleFactor, halfOfLength = length/2, f = 8;
    Line2D.Double defaultIndicator = new Line2D.Double(-halfOfLength, 0, halfOfLength, 0);

    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    double dx = f * Math.cos(angle), dy = f * Math.sin(angle),
	       x1 = line.x1 + dx, y1 = line.y1 + dy;

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    transformation.translate(x1, y1);
    transformation.rotate((angle - 3 * Math.PI / 4));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.draw(defaultIndicator);

    g.setTransform(originalTransformation);
  }

  public void drawConditionalSequenceFlowIndicator(Line2D.Double line, double scaleFactor) {
    if (scaleFactor > 1.0) return;
    int horizontal = (int) (CONDITIONAL_INDICATOR_WIDTH * 0.7);
    int halfOfHorizontal = horizontal / 2;
    int halfOfVertical = CONDITIONAL_INDICATOR_WIDTH / 2;

    Polygon conditionalIndicator = new Polygon();
    conditionalIndicator.addPoint(0, 0);
    conditionalIndicator.addPoint(-halfOfHorizontal, halfOfVertical);
    conditionalIndicator.addPoint(0, CONDITIONAL_INDICATOR_WIDTH);
    conditionalIndicator.addPoint(halfOfHorizontal, halfOfVertical);

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    transformation.translate(line.x1, line.y1);
    transformation.rotate((angle - Math.PI / 2d));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.draw(conditionalIndicator);

    Paint originalPaint = g.getPaint();
    g.setPaint(CONDITIONAL_INDICATOR_COLOR);
    g.fill(conditionalIndicator);

    g.setPaint(originalPaint);
    g.setTransform(originalTransformation);
  }

  public void drawTask(BufferedImage icon, String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(name, graphicInfo);
    g.drawImage(icon, (int) (graphicInfo.getX() + ICON_PADDING / scaleFactor), 
        (int) (graphicInfo.getY() + ICON_PADDING / scaleFactor), 
        (int) (icon.getWidth() / scaleFactor), (int) (icon.getHeight() / scaleFactor), null);
  }

  public void drawTask(String name, GraphicInfo graphicInfo) {
    drawTask(name, graphicInfo, false);
  }
  
  public void drawPoolOrLane(String name, GraphicInfo graphicInfo) {
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    g.drawRect(x, y, width, height);
    
    // Add the name as text, vertical
    if(name != null && name.length() > 0) {
      // Include some padding
      int availableTextSpace = height - 6;

      // Create rotation for derived font
      AffineTransform transformation = new AffineTransform();
      transformation.setToIdentity();
      transformation.rotate(270 * Math.PI/180);

      Font currentFont = g.getFont();
      Font theDerivedFont = currentFont.deriveFont(transformation);
      g.setFont(theDerivedFont);
      
      String truncated = fitTextToWidth(name, availableTextSpace);
      int realWidth = fontMetrics.stringWidth(truncated);
      
      g.drawString(truncated, x + 2 + fontMetrics.getHeight(), 3 + y + availableTextSpace - (availableTextSpace - realWidth) / 2);
      g.setFont(currentFont);
    }
  }

  protected void drawTask(String name, GraphicInfo graphicInfo, boolean thickBorder) {
    Paint originalPaint = g.getPaint();
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
    // Create a new gradient paint for every task box, gradient depends on x and y and is not relative
    g.setPaint(TASK_BOX_COLOR);

    int arcR = 6;
    if (thickBorder)
    	arcR = 3;
    
    // shape
    RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcR, arcR);
    g.fill(rect);
    g.setPaint(TASK_BORDER_COLOR);

    if (thickBorder) {
      Stroke originalStroke = g.getStroke();
      g.setStroke(THICK_TASK_BORDER_STROKE);
      g.draw(rect);
      g.setStroke(originalStroke);
    } else {
      g.draw(rect);
    }

    g.setPaint(originalPaint);
    // text
    if (name != null && name.length() > 0) {
      int boxWidth = width - (2 * TEXT_PADDING);
      int boxHeight = height - 16 - ICON_PADDING - ICON_PADDING - MARKER_WIDTH - 2 - 2;
      int boxX = x + width/2 - boxWidth/2;
      int boxY = y + height/2 - boxHeight/2 + ICON_PADDING + ICON_PADDING - 2 - 2;
      
      drawMultilineCentredText(name, boxX, boxY, boxWidth, boxHeight);
    }
  }
  
  protected void drawMultilineCentredText(String text, int x, int y, int boxWidth, int boxHeight) {
    drawMultilineText(text, x, y, boxWidth, boxHeight, true);
  }

  protected void drawMultilineAnnotationText(String text, int x, int y, int boxWidth, int boxHeight) {
	  drawMultilineText(text, x, y, boxWidth, boxHeight, false);
  }
  
  protected void drawMultilineText(String text, int x, int y, int boxWidth, int boxHeight, boolean centered) {
    // Create an attributed string based in input text
    AttributedString attributedString = new AttributedString(text);
    attributedString.addAttribute(TextAttribute.FONT, g.getFont());
    attributedString.addAttribute(TextAttribute.FOREGROUND, Color.black);
    
    AttributedCharacterIterator characterIterator = attributedString.getIterator();
    
    int currentHeight = 0;
    // Prepare a list of lines of text we'll be drawing
    List<TextLayout> layouts = new ArrayList<TextLayout>();
    String lastLine = null;
    
    LineBreakMeasurer measurer = new LineBreakMeasurer(characterIterator, g.getFontRenderContext());
    
    TextLayout layout = null;
    while (measurer.getPosition() < characterIterator.getEndIndex() && currentHeight <= boxHeight) {
       
      int previousPosition = measurer.getPosition();
      
      // Request next layout
      layout = measurer.nextLayout(boxWidth);
      
      int height = ((Float)(layout.getDescent() + layout.getAscent() + layout.getLeading())).intValue();
      
      if(currentHeight + height > boxHeight) {
        // The line we're about to add should NOT be added anymore, append three dots to previous one instead
        // to indicate more text is truncated
        if (!layouts.isEmpty()) {
          layouts.remove(layouts.size() - 1);
          
          if(lastLine.length() >= 4) {
            lastLine = lastLine.substring(0, lastLine.length() - 4) + "...";
          }
          layouts.add(new TextLayout(lastLine, g.getFont(), g.getFontRenderContext()));
        }
      } else {
        layouts.add(layout);
        lastLine = text.substring(previousPosition, measurer.getPosition());
        currentHeight += height;
      }
    }
    
    
    int currentY = y + (centered ? ((boxHeight - currentHeight) /2) : 0);
    int currentX = 0;
    
    // Actually draw the lines
    for(TextLayout textLayout : layouts) {
      
      currentY += textLayout.getAscent();
      currentX = x + (centered ? ((boxWidth - ((Double)textLayout.getBounds().getWidth()).intValue()) /2) : 0);
      
      textLayout.draw(g, currentX, currentY);
      currentY += textLayout.getDescent() + textLayout.getLeading();
    }
    
  }
  

  protected String fitTextToWidth(String original, int width) {
    String text = original;

    // remove length for "..."
    int maxWidth = width - 10;

    while (fontMetrics.stringWidth(text + "...") > maxWidth && text.length() > 0) {
      text = text.substring(0, text.length() - 1);
    }

    if (!text.equals(original)) {
      text = text + "...";
    }

    return text;
  }

  public void drawUserTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(USERTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawScriptTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SCRIPTTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawServiceTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SERVICETASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawReceiveTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(RECEIVETASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawSendTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SENDTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawManualTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(MANUALTASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawBusinessRuleTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(BUSINESS_RULE_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawCamelTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(CAMEL_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawMuleTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(MULE_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawExpandedSubProcess(String name, GraphicInfo graphicInfo, Boolean isTriggeredByEvent, double scaleFactor) {
    RoundRectangle2D rect = new RoundRectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight(), 8, 8);
    
    // Use different stroke (dashed)
    if (isTriggeredByEvent) {
      Stroke originalStroke = g.getStroke();
      g.setStroke(EVENT_SUBPROCESS_STROKE);
      g.draw(rect);
      g.setStroke(originalStroke);
    } else {
      Paint originalPaint = g.getPaint();
      g.setPaint(SUBPROCESS_BOX_COLOR);
      g.fill(rect);
      g.setPaint(SUBPROCESS_BORDER_COLOR);
      g.draw(rect);
      g.setPaint(originalPaint);
    }

    if (scaleFactor == 1.0 && name != null && !name.isEmpty()) {
      String text = fitTextToWidth(name, (int) graphicInfo.getWidth());
      g.drawString(text, (int) graphicInfo.getX() + 10, (int) graphicInfo.getY() + 15);
    }
  }

  public void drawCollapsedSubProcess(String name, GraphicInfo graphicInfo, Boolean isTriggeredByEvent) {
    drawCollapsedTask(name, graphicInfo, false);
  }

  public void drawCollapsedCallActivity(String name, GraphicInfo graphicInfo) {
    drawCollapsedTask(name, graphicInfo, true);
  }

  protected void drawCollapsedTask(String name, GraphicInfo graphicInfo, boolean thickBorder) {
    // The collapsed marker is now visualized separately
    drawTask(name, graphicInfo, thickBorder);
  }

  public void drawCollapsedMarker(int x, int y, int width, int height) {
    // rectangle
    int rectangleWidth = MARKER_WIDTH;
    int rectangleHeight = MARKER_WIDTH;
    Rectangle rect = new Rectangle(x + (width - rectangleWidth) / 2, y + height - rectangleHeight - 3, rectangleWidth, rectangleHeight);
    g.draw(rect);

    // plus inside rectangle
    Line2D.Double line = new Line2D.Double(rect.getCenterX(), rect.getY() + 2, rect.getCenterX(), rect.getMaxY() - 2);
    g.draw(line);
    line = new Line2D.Double(rect.getMinX() + 2, rect.getCenterY(), rect.getMaxX() - 2, rect.getCenterY());
    g.draw(line);
  }

  public void drawActivityMarkers(int x, int y, int width, int height, boolean multiInstanceSequential, boolean multiInstanceParallel, boolean collapsed) {
    if (collapsed) {
      if (!multiInstanceSequential && !multiInstanceParallel) {
        drawCollapsedMarker(x, y, width, height);
      } else {
        drawCollapsedMarker(x - MARKER_WIDTH / 2 - 2, y, width, height);
        if (multiInstanceSequential) {
          drawMultiInstanceMarker(true, x + MARKER_WIDTH / 2 + 2, y, width, height);
        } else {
          drawMultiInstanceMarker(false, x + MARKER_WIDTH / 2 + 2, y, width, height);
        }
      }
    } else {
      if (multiInstanceSequential) {
        drawMultiInstanceMarker(true, x, y, width, height);
      } else if (multiInstanceParallel) {
        drawMultiInstanceMarker(false, x, y, width, height);
      }
    }
  }

  public void drawGateway(GraphicInfo graphicInfo) {
    Polygon rhombus = new Polygon();
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
    rhombus.addPoint(x, y + (height / 2));
    rhombus.addPoint(x + (width / 2), y + height);
    rhombus.addPoint(x + width, y + (height / 2));
    rhombus.addPoint(x + (width / 2), y);
    g.draw(rhombus);
  }

  public void drawParallelGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    if (scaleFactor == 1.0) {
      // plus inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Line2D.Double line = new Line2D.Double(x + 10, y + height / 2, x + width - 10, y + height / 2); // horizontal
      g.draw(line);
      line = new Line2D.Double(x + width / 2, y + height - 10, x + width / 2, y + 10); // vertical
      g.draw(line);
      g.setStroke(orginalStroke);
    }
  }

  public void drawExclusiveGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    int quarterWidth = width / 4;
    int quarterHeight = height / 4;

    if (scaleFactor == 1.0) {
      // X inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Line2D.Double line = new Line2D.Double(x + quarterWidth + 3, y + quarterHeight + 3, x + 3 * quarterWidth - 3, y + 3 * quarterHeight - 3);
      g.draw(line);
      line = new Line2D.Double(x + quarterWidth + 3, y + 3 * quarterHeight - 3, x + 3 * quarterWidth - 3, y + quarterHeight + 3);
      g.draw(line);
      g.setStroke(orginalStroke);
    }
  }

  public void drawInclusiveGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    int diameter = width / 2;

    if (scaleFactor == 1.0) {
      // circle inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Ellipse2D.Double circle = new Ellipse2D.Double(((width - diameter) / 2) + x, ((height - diameter) / 2) + y, diameter, diameter);
      g.draw(circle);
      g.setStroke(orginalStroke);
    }
  }
  
  public void drawEventBasedGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    
    if (scaleFactor == 1.0) {
      int x = (int) graphicInfo.getX();
      int y = (int) graphicInfo.getY();
      int width = (int) graphicInfo.getWidth();
      int height = (int) graphicInfo.getHeight();
      
      double scale = .6;
      
      GraphicInfo eventInfo = new GraphicInfo();
      eventInfo.setX(x + width*(1-scale)/2);
      eventInfo.setY(y + height*(1-scale)/2);
      eventInfo.setWidth(width*scale);
      eventInfo.setHeight(height*scale);
      drawCatchingEvent(eventInfo, true, null, "eventGateway", scaleFactor);
      
      double r = width / 6.;
      
      // create pentagon (coords with respect to center)
      int topX = (int)(.95 * r); // top right corner
      int topY = (int)(-.31 * r);
      int bottomX = (int)(.59 * r); // bottom right corner
      int bottomY = (int)(.81 * r);
      
      int[] xPoints = new int[]{ 0, topX, bottomX, -bottomX, -topX };
      int[] yPoints = new int[]{ -(int)r, topY, bottomY, bottomY, topY };
      Polygon pentagon = new Polygon(xPoints, yPoints, 5);
      pentagon.translate(x+width/2, y+width/2);
  
      // draw
      g.drawPolygon(pentagon);
    }
  }

  public void drawMultiInstanceMarker(boolean sequential, int x, int y, int width, int height) {
    int rectangleWidth = MARKER_WIDTH;
    int rectangleHeight = MARKER_WIDTH;
    int lineX = x + (width - rectangleWidth) / 2;
    int lineY = y + height - rectangleHeight - 3;

    Stroke orginalStroke = g.getStroke();
    g.setStroke(MULTI_INSTANCE_STROKE);

    if (sequential) {
      g.draw(new Line2D.Double(lineX, lineY, lineX + rectangleWidth, lineY));
      g.draw(new Line2D.Double(lineX, lineY + rectangleHeight / 2, lineX + rectangleWidth, lineY + rectangleHeight / 2));
      g.draw(new Line2D.Double(lineX, lineY + rectangleHeight, lineX + rectangleWidth, lineY + rectangleHeight));
    } else {
      g.draw(new Line2D.Double(lineX, lineY, lineX, lineY + rectangleHeight));
      g.draw(new Line2D.Double(lineX + rectangleWidth / 2, lineY, lineX + rectangleWidth / 2, lineY + rectangleHeight));
      g.draw(new Line2D.Double(lineX + rectangleWidth, lineY, lineX + rectangleWidth, lineY + rectangleHeight));
    }

    g.setStroke(orginalStroke);
  }

  public void drawHighLight(int x, int y, int width, int height) {
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();

    g.setPaint(HIGHLIGHT_COLOR);
    g.setStroke(THICK_TASK_BORDER_STROKE);

    RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, 20, 20);
    g.draw(rect);

    g.setPaint(originalPaint);
    g.setStroke(originalStroke);
  }

  public void drawTextAnnotation(String text, GraphicInfo graphicInfo) {
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
	  Font originalFont = g.getFont();
	  Stroke originalStroke = g.getStroke();
	  
	  g.setFont(ANNOTATION_FONT);
	  
	  Path2D path = new Path2D.Double();
	  x += .5;
	  int lineLength = 18;
	  path.moveTo(x + lineLength, y);
	  path.lineTo(x, y);
	  path.lineTo(x, y + height);
	  path.lineTo(x + lineLength, y + height);
	  
	  path.lineTo(x + lineLength, y + height -1);
	  path.lineTo(x + 1, y + height -1);
	  path.lineTo(x + 1, y + 1);
	  path.lineTo(x + lineLength, y + 1);
	  path.closePath();
	  
	  g.draw(path);
	  
	  int boxWidth = width - (2 * ANNOTATION_TEXT_PADDING);
    int boxHeight = height - (2 * ANNOTATION_TEXT_PADDING);
    int boxX = x + width/2 - boxWidth/2;
    int boxY = y + height/2 - boxHeight/2;
    
    if (text != null && text.isEmpty() == false) {
      drawMultilineAnnotationText(text, boxX, boxY, boxWidth, boxHeight);
    }
	  
	  // restore originals
    g.setFont(originalFont);
    g.setStroke(originalStroke);
  }
  
  public void drawLabel(String text, GraphicInfo graphicInfo){
	  drawLabel(text, graphicInfo, true);
  }
  public void drawLabel(String text, GraphicInfo graphicInfo, boolean centered){
	float interline = 1.0f;
	
    // text
    if (text != null && text.length()>0) {
      Paint originalPaint = g.getPaint();
      Font originalFont = g.getFont();

      g.setPaint(LABEL_COLOR);
      g.setFont(LABEL_FONT);

      int wrapWidth = 100;
      int textY = (int) graphicInfo.getY();
      
      // TODO: use drawMultilineText()
      AttributedString as = new AttributedString(text);
      as.addAttribute(TextAttribute.FOREGROUND, g.getPaint());
      as.addAttribute(TextAttribute.FONT, g.getFont());
      AttributedCharacterIterator aci = as.getIterator();
      FontRenderContext frc = new FontRenderContext(null, true, false);
      LineBreakMeasurer lbm = new LineBreakMeasurer(aci, frc);
      
      while (lbm.getPosition() < text.length()) {
    	  TextLayout tl = lbm.nextLayout(wrapWidth);
    	  textY += tl.getAscent();
    	  Rectangle2D bb = tl.getBounds();
    	  double tX = graphicInfo.getX();
    	  if (centered) {
    	  	tX += (int) (graphicInfo.getWidth() / 2 - bb.getWidth() / 2);
    	  }
    	  tl.draw(g, (float) tX, textY);
    	  textY += tl.getDescent() + tl.getLeading() + (interline - 1.0f) * tl.getAscent();
      }
  
      // restore originals
      g.setFont(originalFont);
      g.setPaint(originalPaint);
    }
  }

  /**
   * This method makes coordinates of connection flow better.
   * @param sourceShapeType
   * @param targetShapeType
   * @param sourceGraphicInfo
   * @param targetGraphicInfo
   * @param graphicInfoList
   * 
   */
  public List<GraphicInfo> connectionPerfectionizer(SHAPE_TYPE sourceShapeType, SHAPE_TYPE targetShapeType, GraphicInfo sourceGraphicInfo, GraphicInfo targetGraphicInfo, List<GraphicInfo> graphicInfoList) {
    Shape shapeFirst = createShape(sourceShapeType, sourceGraphicInfo);
    Shape shapeLast = createShape(targetShapeType, targetGraphicInfo);

    if (graphicInfoList != null && graphicInfoList.size() > 0) {
      GraphicInfo graphicInfoFirst = graphicInfoList.get(0);
      GraphicInfo graphicInfoLast = graphicInfoList.get(graphicInfoList.size()-1);
      if (shapeFirst != null) {
        graphicInfoFirst.setX(shapeFirst.getBounds2D().getCenterX());
        graphicInfoFirst.setY(shapeFirst.getBounds2D().getCenterY());
      }
      if (shapeLast != null) {
        graphicInfoLast.setX(shapeLast.getBounds2D().getCenterX());
        graphicInfoLast.setY(shapeLast.getBounds2D().getCenterY());
      }
  
      Point p = null;
      
      if (shapeFirst != null) {
        Line2D.Double lineFirst = new Line2D.Double(graphicInfoFirst.getX(), graphicInfoFirst.getY(), graphicInfoList.get(1).getX(), graphicInfoList.get(1).getY());
        p = getIntersection(shapeFirst, lineFirst);
        if (p != null) {
          graphicInfoFirst.setX(p.getX());
          graphicInfoFirst.setY(p.getY());
        }
      }
  
      if (shapeLast != null) {
        Line2D.Double lineLast = new Line2D.Double(graphicInfoLast.getX(), graphicInfoLast.getY(), graphicInfoList.get(graphicInfoList.size()-2).getX(), graphicInfoList.get(graphicInfoList.size()-2).getY());
        p = getIntersection(shapeLast, lineLast);
        if (p != null) {
          graphicInfoLast.setX(p.getX());
          graphicInfoLast.setY(p.getY());
        }
      }
    }

    return graphicInfoList;
  }

  /**
   * This method creates shape by type and coordinates.
   * @param shapeType
   * @param graphicInfo
   * @return Shape
   */
  private static Shape createShape(SHAPE_TYPE shapeType, GraphicInfo graphicInfo) {
    if (SHAPE_TYPE.Rectangle.equals(shapeType)) {
      // source is rectangle
      return new Rectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());       
    } else if (SHAPE_TYPE.Rhombus.equals(shapeType)) {
      // source is rhombus
      Path2D.Double rhombus = new Path2D.Double();
      rhombus.moveTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY() + graphicInfo.getHeight());
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY());
      rhombus.lineTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.closePath();
      return rhombus;
    } else if (SHAPE_TYPE.Ellipse.equals(shapeType)) {
      // source is ellipse
      return new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());
    } else {
      // unknown source element, just do not correct coordinates
    }
    return null;
  }

  /**
   * This method returns intersection point of shape border and line.
   * 
   * @param shape
   * @param line
   * @return Point
   */
  private static Point getIntersection(Shape shape, Line2D.Double line) {
    if (shape instanceof Ellipse2D) {
      return getEllipseIntersection(shape, line);
    } else if (shape instanceof Rectangle2D || shape instanceof Path2D) {
      return getShapeIntersection(shape, line);
    } else {
      // something strange
      return null;
    }
  }

    /**
     * This method calculates ellipse intersection with line
     * @param shape
     *                  Bounds of this shape used to calculate parameters of inscribed into this bounds ellipse.
     * @param line
     * @return Intersection point
     */
  private static Point getEllipseIntersection(Shape shape, Line2D.Double line) {
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    double x = shape.getBounds2D().getWidth()/2 * Math.cos(angle) + shape.getBounds2D().getCenterX();
    double y = shape.getBounds2D().getHeight()/2 * Math.sin(angle) + shape.getBounds2D().getCenterY();
    Point p = new Point();
    p.setLocation(x, y);
    return p;
  }

  /**
   * This method calculates shape intersection with line.
   * 
   * @param shape
   * @param line
   * @return Intersection point
   */
  private static Point getShapeIntersection(Shape shape, Line2D.Double line) {
    PathIterator it = shape.getPathIterator(null);
    double[] coords = new double[6];
    double[] pos = new double[2];
    Line2D.Double l = new Line2D.Double();
    while (!it.isDone()) {
      int type = it.currentSegment(coords);
      switch (type) {
      case PathIterator.SEG_MOVETO:
        pos[0] = coords[0];
        pos[1] = coords[1];
        break;
      case PathIterator.SEG_LINETO:
        l = new Line2D.Double(pos[0], pos[1], coords[0], coords[1]);
        if (line.intersectsLine(l)) {
          return getLinesIntersection(line, l);
        }
        pos[0] = coords[0];
        pos[1] = coords[1];
        break;
      case PathIterator.SEG_CLOSE:
        break;
      default:
        // whatever
      }
      it.next();
    }
    return null;
  }

  /**
   * This method calculates intersections of two lines.
   * @param a Line 1
   * @param b Line 2
   * @return Intersection point
   */
  private static Point getLinesIntersection(Line2D a, Line2D b) {
    double d  = (a.getX1()-a.getX2())*(b.getY2()-b.getY1()) - (a.getY1()-a.getY2())*(b.getX2()-b.getX1());
    double da = (a.getX1()-b.getX1())*(b.getY2()-b.getY1()) - (a.getY1()-b.getY1())*(b.getX2()-b.getX1());
    // double db = (a.getX1()-a.getX2())*(a.getY1()-b.getY1()) - (a.getY1()-a.getY2())*(a.getX1()-b.getX1());
    double ta = da/d;
    // double tb = db/d;
    Point p = new Point();
    p.setLocation(a.getX1()+ta*(a.getX2()-a.getX1()), a.getY1()+ta*(a.getY2()-a.getY1()));
    return p;
  }
}
!@#$%
20190526_171328,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.image.impl;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.font.FontRenderContext;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;

import org.activiti.bpmn.model.AssociationDirection;
import org.activiti.bpmn.model.GraphicInfo;
import org.activiti.image.exception.ActivitiImageException;
import org.activiti.image.util.ReflectUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Represents a canvas on which BPMN 2.0 constructs can be drawn.
 * 
 * Some of the icons used are licensed under a Creative Commons Attribution 2.5
 * License, see http://www.famfamfam.com/lab/icons/silk/
 * 
 * @see org.activiti.engine.impl.bpmn.diagram.DefaultProcessDiagramGenerator
 * @author Joram Barrez
 */
public class DefaultProcessDiagramCanvas {

  protected static final Logger LOGGER = LoggerFactory.getLogger(DefaultProcessDiagramCanvas.class);
  public enum SHAPE_TYPE {Rectangle, Rhombus, Ellipse}

  // Predefined sized
  protected static final int ARROW_WIDTH = 5;
  protected static final int CONDITIONAL_INDICATOR_WIDTH = 16;
  protected static final int DEFAULT_INDICATOR_WIDTH = 10;
  protected static final int MARKER_WIDTH = 12;
  protected static final int FONT_SIZE = 11;
  protected static final int FONT_SPACING = 2;
  protected static final int TEXT_PADDING = 3;
  protected static final int ANNOTATION_TEXT_PADDING = 7;
  protected static final int LINE_HEIGHT = FONT_SIZE + FONT_SPACING;
  

  // Colors
  protected static Color TASK_BOX_COLOR = new Color(249, 249, 249);
  protected static Color SUBPROCESS_BOX_COLOR = new Color(255, 255, 255);
  protected static Color EVENT_COLOR = new Color(255, 255, 255);
  protected static Color CONNECTION_COLOR = new Color(88, 88, 88);
  protected static Color CONDITIONAL_INDICATOR_COLOR = new Color(255, 255, 255);
  protected static Color HIGHLIGHT_COLOR = Color.RED;
  protected static Color LABEL_COLOR = new Color(112, 146, 190);
  protected static Color TASK_BORDER_COLOR = new Color(187, 187, 187);
  protected static Color EVENT_BORDER_COLOR = new Color(88, 88, 88);
  protected static Color SUBPROCESS_BORDER_COLOR = new Color(0, 0, 0);
  
  // Fonts
  protected static Font LABEL_FONT = null;
  protected static Font ANNOTATION_FONT = null;

  // Strokes
  protected static Stroke THICK_TASK_BORDER_STROKE = new BasicStroke(3.0f);
  protected static Stroke GATEWAY_TYPE_STROKE = new BasicStroke(3.0f);
  protected static Stroke END_EVENT_STROKE = new BasicStroke(3.0f);
  protected static Stroke MULTI_INSTANCE_STROKE = new BasicStroke(1.3f);
  protected static Stroke EVENT_SUBPROCESS_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 1.0f }, 0.0f);
  protected static Stroke NON_INTERRUPTING_EVENT_STROKE = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 4.0f, 3.0f }, 0.0f);
  protected static Stroke HIGHLIGHT_FLOW_STROKE = new BasicStroke(1.3f);
  protected static Stroke ANNOTATION_STROKE = new BasicStroke(2.0f);
  protected static Stroke ASSOCIATION_STROKE = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f,  new float[] { 2.0f, 2.0f }, 0.0f);

  // icons
  protected static int ICON_PADDING = 5;
  protected static BufferedImage USERTASK_IMAGE;
  protected static BufferedImage SCRIPTTASK_IMAGE;
  protected static BufferedImage SERVICETASK_IMAGE;
  protected static BufferedImage RECEIVETASK_IMAGE;
  protected static BufferedImage SENDTASK_IMAGE;
  protected static BufferedImage MANUALTASK_IMAGE;
  protected static BufferedImage BUSINESS_RULE_TASK_IMAGE;
  protected static BufferedImage SHELL_TASK_IMAGE;
  protected static BufferedImage MULE_TASK_IMAGE;
  protected static BufferedImage CAMEL_TASK_IMAGE;
  
  protected static BufferedImage TIMER_IMAGE;
  protected static BufferedImage COMPENSATE_THROW_IMAGE;
  protected static BufferedImage COMPENSATE_CATCH_IMAGE;
  protected static BufferedImage ERROR_THROW_IMAGE;
  protected static BufferedImage ERROR_CATCH_IMAGE;
  protected static BufferedImage MESSAGE_THROW_IMAGE;
  protected static BufferedImage MESSAGE_CATCH_IMAGE;
  protected static BufferedImage SIGNAL_CATCH_IMAGE;
  protected static BufferedImage SIGNAL_THROW_IMAGE;

  protected int canvasWidth = -1;
  protected int canvasHeight = -1;
  protected int minX = -1;
  protected int minY = -1;
  protected BufferedImage processDiagram;
  protected Graphics2D g;
  protected FontMetrics fontMetrics;
  protected boolean closed;
  protected ClassLoader customClassLoader;
  protected String activityFontName = "Arial";
  protected String labelFontName = "Arial";
  protected String annotationFontName = "Arial";
  
  /**
   * Creates an empty canvas with given width and height.
   * 
   * Allows to specify minimal boundaries on the left and upper side of the
   * canvas. This is useful for diagrams that have white space there.
   * Everything beneath these minimum values will be cropped. 
   * It's also possible to pass a specific font name and a class loader for the icon images.
   * 
   */
  public DefaultProcessDiagramCanvas(int width, int height, int minX, int minY, String imageType, 
      String activityFontName, String labelFontName, String annotationFontName, ClassLoader customClassLoader) {
    
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.minX = minX;
    this.minY = minY;
    if (activityFontName != null) {
      this.activityFontName = activityFontName;
    }
    if (labelFontName != null) {
      this.labelFontName = labelFontName;
    }
    if (annotationFontName != null) {
        this.annotationFontName = annotationFontName;
    }
    this.customClassLoader = customClassLoader;
    
    initialize(imageType);
  }

  /**
   * Creates an empty canvas with given width and height.
   * 
   * Allows to specify minimal boundaries on the left and upper side of the
   * canvas. This is useful for diagrams that have white space there (eg
   * Signavio). Everything beneath these minimum values will be cropped.
   * 
   * @param minX
   *          Hint that will be used when generating the image. Parts that fall
   *          below minX on the horizontal scale will be cropped.
   * @param minY
   *          Hint that will be used when generating the image. Parts that fall
   *          below minX on the horizontal scale will be cropped.
   */
  public DefaultProcessDiagramCanvas(int width, int height, int minX, int minY, String imageType) {
    this.canvasWidth = width;
    this.canvasHeight = height;
    this.minX = minX;
    this.minY = minY;
    
    initialize(imageType);
  }
  
  public void initialize(String imageType) {
    if ("png".equalsIgnoreCase(imageType)) {
      this.processDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_ARGB);
    } else {
      this.processDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_RGB);
    }
    
    this.g = processDiagram.createGraphics();
    if ("png".equalsIgnoreCase(imageType) == false) {
      this.g.setBackground(new Color(255, 255, 255, 0));
      this.g.clearRect(0, 0, canvasWidth, canvasHeight);
    }

    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setPaint(Color.black);
    
    Font font = new Font(activityFontName, Font.BOLD, FONT_SIZE);
    g.setFont(font);
    this.fontMetrics = g.getFontMetrics();

    LABEL_FONT = new Font(labelFontName, Font.ITALIC, 10);
    ANNOTATION_FONT = new Font(annotationFontName, Font.PLAIN, FONT_SIZE);
    
    try {
      USERTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/userTask.png", customClassLoader));
      SCRIPTTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/scriptTask.png", customClassLoader));
      SERVICETASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/serviceTask.png", customClassLoader));
      RECEIVETASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/receiveTask.png", customClassLoader));
      SENDTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/sendTask.png", customClassLoader));
      MANUALTASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/manualTask.png", customClassLoader));
      BUSINESS_RULE_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/businessRuleTask.png", customClassLoader));
      SHELL_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/shellTask.png", customClassLoader));
      CAMEL_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/camelTask.png", customClassLoader));
      MULE_TASK_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/muleTask.png", customClassLoader));
      
      TIMER_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/timer.png", customClassLoader));
      COMPENSATE_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/compensate-throw.png", customClassLoader));
      COMPENSATE_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/compensate.png", customClassLoader));
      ERROR_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/error-throw.png", customClassLoader));
      ERROR_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/error.png", customClassLoader));
      MESSAGE_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/message-throw.png", customClassLoader));
      MESSAGE_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/message.png", customClassLoader));
      SIGNAL_THROW_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/signal-throw.png", customClassLoader));
      SIGNAL_CATCH_IMAGE = ImageIO.read(ReflectUtil.getResource("org/activiti/icons/signal.png", customClassLoader));
    } catch (IOException e) {
      LOGGER.warn("Could not load image for process diagram creation: {}", e.getMessage());
    }
  }

  /**
   * Generates an image of what currently is drawn on the canvas.
   * 
   * Throws an {@link ActivitiException} when {@link #close()} is already
   * called.
   */
  public InputStream generateImage(String imageType) {
    if (closed) {
      throw new ActivitiImageException("ProcessDiagramGenerator already closed");
    }

    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try {
      ImageIO.write(processDiagram, imageType, out);
      
    } catch (IOException e) {
      throw new ActivitiImageException("Error while generating process image", e);
    } finally {
      try {
        if (out != null) {
          out.close();
        }
      } catch(IOException ignore) {
        // Exception is silently ignored
      }
    }
    return new ByteArrayInputStream(out.toByteArray());
  }
  
  /**
   * Generates an image of what currently is drawn on the canvas.
   * 
   * Throws an {@link ActivitiException} when {@link #close()} is already
   * called.
   */
  public BufferedImage generateBufferedImage(String imageType) {
    if (closed) {
      throw new ActivitiImageException("ProcessDiagramGenerator already closed");
    }

    // Try to remove white space
    minX = (minX <= 5) ? 5 : minX;
    minY = (minY <= 5) ? 5 : minY;
    BufferedImage imageToSerialize = processDiagram;
    if (minX >= 0 && minY >= 0) {
      imageToSerialize = processDiagram.getSubimage(minX - 5, minY - 5, canvasWidth - minX + 5, canvasHeight - minY + 5);
    }
    return imageToSerialize;
  }

  /**
   * Closes the canvas which dissallows further drawing and releases graphical
   * resources.
   */
  public void close() {
    g.dispose();
    closed = true;
  }

  public void drawNoneStartEvent(GraphicInfo graphicInfo) {
    drawStartEvent(graphicInfo, null, 1.0);
  }

  public void drawTimerStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, TIMER_IMAGE, scaleFactor);
  }
  
  public void drawSignalStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, SIGNAL_CATCH_IMAGE, scaleFactor);
  }
  
  public void drawMessageStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawStartEvent(graphicInfo, MESSAGE_CATCH_IMAGE, scaleFactor);
  }

  public void drawStartEvent(GraphicInfo graphicInfo, BufferedImage image, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    g.setPaint(EVENT_COLOR);
    Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    g.fill(circle);
    g.setPaint(EVENT_BORDER_COLOR);
    g.draw(circle);
    g.setPaint(originalPaint);
    if (image != null) {
      // calculate coordinates to center image
      int imageX = (int) Math.round(graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / 2 * scaleFactor));
      int imageY = (int) Math.round(graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / 2 * scaleFactor));  
      g.drawImage(image, imageX, imageY,
          (int) (image.getWidth() / scaleFactor), (int) (image.getHeight() / scaleFactor), null);
    }

  }

  public void drawNoneEndEvent(GraphicInfo graphicInfo, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();
    g.setPaint(EVENT_COLOR);
    Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    g.fill(circle);
    g.setPaint(EVENT_BORDER_COLOR);
    if (scaleFactor == 1.0) {
      g.setStroke(END_EVENT_STROKE);
    } else {
      g.setStroke(new BasicStroke(2.0f));
    }
    g.draw(circle);
    g.setStroke(originalStroke);
    g.setPaint(originalPaint);
  }

  public void drawErrorEndEvent(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawErrorEndEvent(graphicInfo, scaleFactor);
    if (scaleFactor == 1.0) {
      drawLabel(name, graphicInfo);
    }
  }
  
  public void drawErrorEndEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawNoneEndEvent(graphicInfo, scaleFactor);
    g.drawImage(ERROR_THROW_IMAGE, (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 4)), 
        (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 4)), 
        (int) (ERROR_THROW_IMAGE.getWidth() / scaleFactor), 
        (int) (ERROR_THROW_IMAGE.getHeight() / scaleFactor), null);
  }
  
  public void drawErrorStartEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawNoneStartEvent(graphicInfo);
    g.drawImage(ERROR_CATCH_IMAGE, (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 4)), 
        (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 4)), 
        (int) (ERROR_CATCH_IMAGE.getWidth() / scaleFactor), 
        (int) (ERROR_CATCH_IMAGE.getHeight() / scaleFactor), null);
  }

  public void drawCatchingEvent(GraphicInfo graphicInfo, boolean isInterrupting, 
      BufferedImage image, String eventType, double scaleFactor) {
    
    // event circles
    Ellipse2D outerCircle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight());
    int innerCircleSize = (int) (4 / scaleFactor);
    if (innerCircleSize == 0) {
      innerCircleSize = 1;
    }
    int innerCircleX = (int) graphicInfo.getX() + innerCircleSize;
    int innerCircleY = (int) graphicInfo.getY() + innerCircleSize;
    int innerCircleWidth = (int) graphicInfo.getWidth() - (2 * innerCircleSize);
    int innerCircleHeight = (int) graphicInfo.getHeight() - (2 * innerCircleSize);
    Ellipse2D innerCircle = new Ellipse2D.Double(innerCircleX, innerCircleY, innerCircleWidth, innerCircleHeight);

    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();
    g.setPaint(EVENT_COLOR);
    g.fill(outerCircle);

    g.setPaint(EVENT_BORDER_COLOR);
    if (isInterrupting == false) 
      g.setStroke(NON_INTERRUPTING_EVENT_STROKE);
    g.draw(outerCircle);
    g.setStroke(originalStroke);
    g.setPaint(originalPaint);
    g.draw(innerCircle);

    if (image != null) {
      // calculate coordinates to center image
      int imageX = (int) (graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / 2 * scaleFactor));
      int imageY = (int) (graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / 2 * scaleFactor));  
      if (scaleFactor == 1.0 && "timer".equals(eventType)) {
        // move image one pixel to center timer image
        imageX++;
        imageY++;
      }
      g.drawImage(image, imageX, imageY, (int) (image.getWidth() / scaleFactor), 
          (int) (image.getHeight() / scaleFactor), null);
    }
  }

  public void drawCatchingCompensateEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingCompensateEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingCompensateEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, COMPENSATE_CATCH_IMAGE, "compensate", scaleFactor);
  }

  public void drawCatchingTimerEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingTimerEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingTimerEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, TIMER_IMAGE, "timer", scaleFactor);
  }

  public void drawCatchingErrorEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingErrorEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingErrorEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, ERROR_CATCH_IMAGE, "error", scaleFactor);
  }

  public void drawCatchingSignalEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingSignalEvent(graphicInfo, isInterrupting, scaleFactor);
    drawLabel(name, graphicInfo);
  }

  public void drawCatchingSignalEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, SIGNAL_CATCH_IMAGE, "signal", scaleFactor);
  }
  
  public void drawCatchingMessageEvent(GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, MESSAGE_CATCH_IMAGE, "message", scaleFactor);
  }

  public void drawCatchingMessageEvent(String name, GraphicInfo graphicInfo, boolean isInterrupting, double scaleFactor) {
    drawCatchingEvent(graphicInfo, isInterrupting, MESSAGE_CATCH_IMAGE, "message", scaleFactor);
    drawLabel(name, graphicInfo);
  }
  
  public void drawThrowingCompensateEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, COMPENSATE_THROW_IMAGE, "compensate", scaleFactor);
  }

  public void drawThrowingSignalEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, SIGNAL_THROW_IMAGE, "signal", scaleFactor);
  }
  
  public void drawThrowingNoneEvent(GraphicInfo graphicInfo, double scaleFactor) {
    drawCatchingEvent(graphicInfo, true, null, "none", scaleFactor);
  }

  public void drawSequenceflow(int srcX, int srcY, int targetX, int targetY, boolean conditional, double scaleFactor) {
    drawSequenceflow(srcX, srcY, targetX, targetY, conditional, false, scaleFactor);
  }
  
  public void drawSequenceflow(int srcX, int srcY, int targetX, int targetY, boolean conditional, boolean highLighted, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    if (highLighted)
      g.setPaint(HIGHLIGHT_COLOR);

    Line2D.Double line = new Line2D.Double(srcX, srcY, targetX, targetY);
    g.draw(line);
    drawArrowHead(line, scaleFactor);

    if (conditional) {
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }

    if (highLighted)
      g.setPaint(originalPaint);
  }

  public void drawAssociation(int[] xPoints, int[] yPoints, AssociationDirection associationDirection, boolean highLighted, double scaleFactor) {
    boolean conditional = false, isDefault = false;
    drawConnection(xPoints, yPoints, conditional, isDefault, "association", associationDirection, highLighted, scaleFactor);
  }

  public void drawSequenceflow(int[] xPoints, int[] yPoints, boolean conditional, boolean isDefault, boolean highLighted, double scaleFactor) {
	  drawConnection(xPoints, yPoints, conditional, isDefault, "sequenceFlow", AssociationDirection.ONE, highLighted, scaleFactor);
  }
  
  public void drawConnection(int[] xPoints, int[] yPoints, boolean conditional, boolean isDefault, String connectionType, 
      AssociationDirection associationDirection, boolean highLighted, double scaleFactor) {
    
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();

    g.setPaint(CONNECTION_COLOR);
    if (connectionType.equals("association")) {
      g.setStroke(ASSOCIATION_STROKE);
    } else if (highLighted) {
      g.setPaint(HIGHLIGHT_COLOR);
      g.setStroke(HIGHLIGHT_FLOW_STROKE);
    }

    for (int i=1; i<xPoints.length; i++) {
      Integer sourceX = xPoints[i - 1];
      Integer sourceY = yPoints[i - 1];
      Integer targetX = xPoints[i];
      Integer targetY = yPoints[i];
      Line2D.Double line = new Line2D.Double(sourceX, sourceY, targetX, targetY);
      g.draw(line);
    }
  
    if (isDefault){
      Line2D.Double line = new Line2D.Double(xPoints[0], yPoints[0], xPoints[1], yPoints[1]);
      drawDefaultSequenceFlowIndicator(line, scaleFactor);
    }

    if (conditional) {
      Line2D.Double line = new Line2D.Double(xPoints[0], yPoints[0], xPoints[1], yPoints[1]);
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }
  
    if (associationDirection.equals(AssociationDirection.ONE) || associationDirection.equals(AssociationDirection.BOTH)) {
      Line2D.Double line = new Line2D.Double(xPoints[xPoints.length-2], yPoints[xPoints.length-2], xPoints[xPoints.length-1], yPoints[xPoints.length-1]);
      drawArrowHead(line, scaleFactor);
    }
    if (associationDirection.equals(AssociationDirection.BOTH)) {
      Line2D.Double line = new Line2D.Double(xPoints[1], yPoints[1], xPoints[0], yPoints[0]);
      drawArrowHead(line, scaleFactor);
    }
    g.setPaint(originalPaint);
    g.setStroke(originalStroke);
  }

  public void drawSequenceflowWithoutArrow(int srcX, int srcY, int targetX, int targetY, boolean conditional, double scaleFactor) {
    drawSequenceflowWithoutArrow(srcX, srcY, targetX, targetY, conditional, false, scaleFactor);
  }

  public void drawSequenceflowWithoutArrow(int srcX, int srcY, int targetX, int targetY, boolean conditional, boolean highLighted, double scaleFactor) {
    Paint originalPaint = g.getPaint();
    if (highLighted)
      g.setPaint(HIGHLIGHT_COLOR);

    Line2D.Double line = new Line2D.Double(srcX, srcY, targetX, targetY);
    g.draw(line);

    if (conditional) {
      drawConditionalSequenceFlowIndicator(line, scaleFactor);
    }

    if (highLighted)
      g.setPaint(originalPaint);
  }

  public void drawArrowHead(Line2D.Double line, double scaleFactor) {
    int doubleArrowWidth = (int) (2 * ARROW_WIDTH / scaleFactor);
    if (doubleArrowWidth == 0) {
      doubleArrowWidth = 2;
    }
    Polygon arrowHead = new Polygon();
    arrowHead.addPoint(0, 0);
    int arrowHeadPoint = (int) (-ARROW_WIDTH / scaleFactor);
    if (arrowHeadPoint == 0) {
      arrowHeadPoint = -1;
    }
    arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);
    arrowHeadPoint = (int) (ARROW_WIDTH / scaleFactor);
    if (arrowHeadPoint == 0) {
      arrowHeadPoint = 1;
    }
    arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    transformation.translate(line.x2, line.y2);
    transformation.rotate((angle - Math.PI / 2d));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.fill(arrowHead);
    g.setTransform(originalTransformation);
  }

  public void drawDefaultSequenceFlowIndicator(Line2D.Double line, double scaleFactor) {
    double length = DEFAULT_INDICATOR_WIDTH / scaleFactor, halfOfLength = length/2, f = 8;
    Line2D.Double defaultIndicator = new Line2D.Double(-halfOfLength, 0, halfOfLength, 0);

    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    double dx = f * Math.cos(angle), dy = f * Math.sin(angle),
	       x1 = line.x1 + dx, y1 = line.y1 + dy;

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    transformation.translate(x1, y1);
    transformation.rotate((angle - 3 * Math.PI / 4));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.draw(defaultIndicator);

    g.setTransform(originalTransformation);
  }

  public void drawConditionalSequenceFlowIndicator(Line2D.Double line, double scaleFactor) {
    if (scaleFactor > 1.0) return;
    int horizontal = (int) (CONDITIONAL_INDICATOR_WIDTH * 0.7);
    int halfOfHorizontal = horizontal / 2;
    int halfOfVertical = CONDITIONAL_INDICATOR_WIDTH / 2;

    Polygon conditionalIndicator = new Polygon();
    conditionalIndicator.addPoint(0, 0);
    conditionalIndicator.addPoint(-halfOfHorizontal, halfOfVertical);
    conditionalIndicator.addPoint(0, CONDITIONAL_INDICATOR_WIDTH);
    conditionalIndicator.addPoint(halfOfHorizontal, halfOfVertical);

    AffineTransform transformation = new AffineTransform();
    transformation.setToIdentity();
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    transformation.translate(line.x1, line.y1);
    transformation.rotate((angle - Math.PI / 2d));

    AffineTransform originalTransformation = g.getTransform();
    g.setTransform(transformation);
    g.draw(conditionalIndicator);

    Paint originalPaint = g.getPaint();
    g.setPaint(CONDITIONAL_INDICATOR_COLOR);
    g.fill(conditionalIndicator);

    g.setPaint(originalPaint);
    g.setTransform(originalTransformation);
  }

  public void drawTask(BufferedImage icon, String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(name, graphicInfo);
    g.drawImage(icon, (int) (graphicInfo.getX() + ICON_PADDING / scaleFactor), 
        (int) (graphicInfo.getY() + ICON_PADDING / scaleFactor), 
        (int) (icon.getWidth() / scaleFactor), (int) (icon.getHeight() / scaleFactor), null);
  }

  public void drawTask(String name, GraphicInfo graphicInfo) {
    drawTask(name, graphicInfo, false);
  }
  
  public void drawPoolOrLane(String name, GraphicInfo graphicInfo) {
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    g.drawRect(x, y, width, height);
    
    // Add the name as text, vertical
    if(name != null && name.length() > 0) {
      // Include some padding
      int availableTextSpace = height - 6;

      // Create rotation for derived font
      AffineTransform transformation = new AffineTransform();
      transformation.setToIdentity();
      transformation.rotate(270 * Math.PI/180);

      Font currentFont = g.getFont();
      Font theDerivedFont = currentFont.deriveFont(transformation);
      g.setFont(theDerivedFont);
      
      String truncated = fitTextToWidth(name, availableTextSpace);
      int realWidth = fontMetrics.stringWidth(truncated);
      
      g.drawString(truncated, x + 2 + fontMetrics.getHeight(), 3 + y + availableTextSpace - (availableTextSpace - realWidth) / 2);
      g.setFont(currentFont);
    }
  }

  protected void drawTask(String name, GraphicInfo graphicInfo, boolean thickBorder) {
    Paint originalPaint = g.getPaint();
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
    // Create a new gradient paint for every task box, gradient depends on x and y and is not relative
    g.setPaint(TASK_BOX_COLOR);

    int arcR = 6;
    if (thickBorder)
    	arcR = 3;
    
    // shape
    RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcR, arcR);
    g.fill(rect);
    g.setPaint(TASK_BORDER_COLOR);

    if (thickBorder) {
      Stroke originalStroke = g.getStroke();
      g.setStroke(THICK_TASK_BORDER_STROKE);
      g.draw(rect);
      g.setStroke(originalStroke);
    } else {
      g.draw(rect);
    }

    g.setPaint(originalPaint);
    // text
    if (name != null && name.length() > 0) {
      int boxWidth = width - (2 * TEXT_PADDING);
      int boxHeight = height - 16 - ICON_PADDING - ICON_PADDING - MARKER_WIDTH - 2 - 2;
      int boxX = x + width/2 - boxWidth/2;
      int boxY = y + height/2 - boxHeight/2 + ICON_PADDING + ICON_PADDING - 2 - 2;
      
      drawMultilineCentredText(name, boxX, boxY, boxWidth, boxHeight);
    }
  }
  
  protected void drawMultilineCentredText(String text, int x, int y, int boxWidth, int boxHeight) {
    drawMultilineText(text, x, y, boxWidth, boxHeight, true);
  }

  protected void drawMultilineAnnotationText(String text, int x, int y, int boxWidth, int boxHeight) {
	  drawMultilineText(text, x, y, boxWidth, boxHeight, false);
  }
  
  protected void drawMultilineText(String text, int x, int y, int boxWidth, int boxHeight, boolean centered) {
    // Create an attributed string based in input text
    AttributedString attributedString = new AttributedString(text);
    attributedString.addAttribute(TextAttribute.FONT, g.getFont());
    attributedString.addAttribute(TextAttribute.FOREGROUND, Color.black);
    
    AttributedCharacterIterator characterIterator = attributedString.getIterator();
    
    int currentHeight = 0;
    // Prepare a list of lines of text we'll be drawing
    List<TextLayout> layouts = new ArrayList<TextLayout>();
    String lastLine = null;
    
    LineBreakMeasurer measurer = new LineBreakMeasurer(characterIterator, g.getFontRenderContext());
    
    TextLayout layout = null;
    while (measurer.getPosition() < characterIterator.getEndIndex() && currentHeight <= boxHeight) {
       
      int previousPosition = measurer.getPosition();
      
      // Request next layout
      layout = measurer.nextLayout(boxWidth);
      
      int height = ((Float)(layout.getDescent() + layout.getAscent() + layout.getLeading())).intValue();
      
      if(currentHeight + height > boxHeight) {
        // The line we're about to add should NOT be added anymore, append three dots to previous one instead
        // to indicate more text is truncated
        if (!layouts.isEmpty()) {
          layouts.remove(layouts.size() - 1);
          
          if(lastLine.length() >= 4) {
            lastLine = lastLine.substring(0, lastLine.length() - 4) + "...";
          }
          layouts.add(new TextLayout(lastLine, g.getFont(), g.getFontRenderContext()));
        }
        break;
      } else {
        layouts.add(layout);
        lastLine = text.substring(previousPosition, measurer.getPosition());
        currentHeight += height;
      }
    }
    
    
    int currentY = y + (centered ? ((boxHeight - currentHeight) /2) : 0);
    int currentX = 0;
    
    // Actually draw the lines
    for(TextLayout textLayout : layouts) {
      
      currentY += textLayout.getAscent();
      currentX = x + (centered ? ((boxWidth - ((Double)textLayout.getBounds().getWidth()).intValue()) /2) : 0);
      
      textLayout.draw(g, currentX, currentY);
      currentY += textLayout.getDescent() + textLayout.getLeading();
    }
    
  }
  

  protected String fitTextToWidth(String original, int width) {
    String text = original;

    // remove length for "..."
    int maxWidth = width - 10;

    while (fontMetrics.stringWidth(text + "...") > maxWidth && text.length() > 0) {
      text = text.substring(0, text.length() - 1);
    }

    if (!text.equals(original)) {
      text = text + "...";
    }

    return text;
  }

  public void drawUserTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(USERTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawScriptTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SCRIPTTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawServiceTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SERVICETASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawReceiveTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(RECEIVETASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawSendTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(SENDTASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawManualTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(MANUALTASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawBusinessRuleTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(BUSINESS_RULE_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawCamelTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(CAMEL_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }
  
  public void drawMuleTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
    drawTask(MULE_TASK_IMAGE, name, graphicInfo, scaleFactor);
  }

  public void drawExpandedSubProcess(String name, GraphicInfo graphicInfo, Boolean isTriggeredByEvent, double scaleFactor) {
    RoundRectangle2D rect = new RoundRectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), 
        graphicInfo.getWidth(), graphicInfo.getHeight(), 8, 8);
    
    // Use different stroke (dashed)
    if (isTriggeredByEvent) {
      Stroke originalStroke = g.getStroke();
      g.setStroke(EVENT_SUBPROCESS_STROKE);
      g.draw(rect);
      g.setStroke(originalStroke);
    } else {
      Paint originalPaint = g.getPaint();
      g.setPaint(SUBPROCESS_BOX_COLOR);
      g.fill(rect);
      g.setPaint(SUBPROCESS_BORDER_COLOR);
      g.draw(rect);
      g.setPaint(originalPaint);
    }

    if (scaleFactor == 1.0 && name != null && !name.isEmpty()) {
      String text = fitTextToWidth(name, (int) graphicInfo.getWidth());
      g.drawString(text, (int) graphicInfo.getX() + 10, (int) graphicInfo.getY() + 15);
    }
  }

  public void drawCollapsedSubProcess(String name, GraphicInfo graphicInfo, Boolean isTriggeredByEvent) {
    drawCollapsedTask(name, graphicInfo, false);
  }

  public void drawCollapsedCallActivity(String name, GraphicInfo graphicInfo) {
    drawCollapsedTask(name, graphicInfo, true);
  }

  protected void drawCollapsedTask(String name, GraphicInfo graphicInfo, boolean thickBorder) {
    // The collapsed marker is now visualized separately
    drawTask(name, graphicInfo, thickBorder);
  }

  public void drawCollapsedMarker(int x, int y, int width, int height) {
    // rectangle
    int rectangleWidth = MARKER_WIDTH;
    int rectangleHeight = MARKER_WIDTH;
    Rectangle rect = new Rectangle(x + (width - rectangleWidth) / 2, y + height - rectangleHeight - 3, rectangleWidth, rectangleHeight);
    g.draw(rect);

    // plus inside rectangle
    Line2D.Double line = new Line2D.Double(rect.getCenterX(), rect.getY() + 2, rect.getCenterX(), rect.getMaxY() - 2);
    g.draw(line);
    line = new Line2D.Double(rect.getMinX() + 2, rect.getCenterY(), rect.getMaxX() - 2, rect.getCenterY());
    g.draw(line);
  }

  public void drawActivityMarkers(int x, int y, int width, int height, boolean multiInstanceSequential, boolean multiInstanceParallel, boolean collapsed) {
    if (collapsed) {
      if (!multiInstanceSequential && !multiInstanceParallel) {
        drawCollapsedMarker(x, y, width, height);
      } else {
        drawCollapsedMarker(x - MARKER_WIDTH / 2 - 2, y, width, height);
        if (multiInstanceSequential) {
          drawMultiInstanceMarker(true, x + MARKER_WIDTH / 2 + 2, y, width, height);
        } else {
          drawMultiInstanceMarker(false, x + MARKER_WIDTH / 2 + 2, y, width, height);
        }
      }
    } else {
      if (multiInstanceSequential) {
        drawMultiInstanceMarker(true, x, y, width, height);
      } else if (multiInstanceParallel) {
        drawMultiInstanceMarker(false, x, y, width, height);
      }
    }
  }

  public void drawGateway(GraphicInfo graphicInfo) {
    Polygon rhombus = new Polygon();
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
    rhombus.addPoint(x, y + (height / 2));
    rhombus.addPoint(x + (width / 2), y + height);
    rhombus.addPoint(x + width, y + (height / 2));
    rhombus.addPoint(x + (width / 2), y);
    g.draw(rhombus);
  }

  public void drawParallelGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    if (scaleFactor == 1.0) {
      // plus inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Line2D.Double line = new Line2D.Double(x + 10, y + height / 2, x + width - 10, y + height / 2); // horizontal
      g.draw(line);
      line = new Line2D.Double(x + width / 2, y + height - 10, x + width / 2, y + 10); // vertical
      g.draw(line);
      g.setStroke(orginalStroke);
    }
  }

  public void drawExclusiveGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    int quarterWidth = width / 4;
    int quarterHeight = height / 4;

    if (scaleFactor == 1.0) {
      // X inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Line2D.Double line = new Line2D.Double(x + quarterWidth + 3, y + quarterHeight + 3, x + 3 * quarterWidth - 3, y + 3 * quarterHeight - 3);
      g.draw(line);
      line = new Line2D.Double(x + quarterWidth + 3, y + 3 * quarterHeight - 3, x + 3 * quarterWidth - 3, y + quarterHeight + 3);
      g.draw(line);
      g.setStroke(orginalStroke);
    }
  }

  public void drawInclusiveGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();

    int diameter = width / 2;

    if (scaleFactor == 1.0) {
      // circle inside rhombus
      Stroke orginalStroke = g.getStroke();
      g.setStroke(GATEWAY_TYPE_STROKE);
      Ellipse2D.Double circle = new Ellipse2D.Double(((width - diameter) / 2) + x, ((height - diameter) / 2) + y, diameter, diameter);
      g.draw(circle);
      g.setStroke(orginalStroke);
    }
  }
  
  public void drawEventBasedGateway(GraphicInfo graphicInfo, double scaleFactor) {
    // rhombus
    drawGateway(graphicInfo);
    
    if (scaleFactor == 1.0) {
      int x = (int) graphicInfo.getX();
      int y = (int) graphicInfo.getY();
      int width = (int) graphicInfo.getWidth();
      int height = (int) graphicInfo.getHeight();
      
      double scale = .6;
      
      GraphicInfo eventInfo = new GraphicInfo();
      eventInfo.setX(x + width*(1-scale)/2);
      eventInfo.setY(y + height*(1-scale)/2);
      eventInfo.setWidth(width*scale);
      eventInfo.setHeight(height*scale);
      drawCatchingEvent(eventInfo, true, null, "eventGateway", scaleFactor);
      
      double r = width / 6.;
      
      // create pentagon (coords with respect to center)
      int topX = (int)(.95 * r); // top right corner
      int topY = (int)(-.31 * r);
      int bottomX = (int)(.59 * r); // bottom right corner
      int bottomY = (int)(.81 * r);
      
      int[] xPoints = new int[]{ 0, topX, bottomX, -bottomX, -topX };
      int[] yPoints = new int[]{ -(int)r, topY, bottomY, bottomY, topY };
      Polygon pentagon = new Polygon(xPoints, yPoints, 5);
      pentagon.translate(x+width/2, y+width/2);
  
      // draw
      g.drawPolygon(pentagon);
    }
  }

  public void drawMultiInstanceMarker(boolean sequential, int x, int y, int width, int height) {
    int rectangleWidth = MARKER_WIDTH;
    int rectangleHeight = MARKER_WIDTH;
    int lineX = x + (width - rectangleWidth) / 2;
    int lineY = y + height - rectangleHeight - 3;

    Stroke orginalStroke = g.getStroke();
    g.setStroke(MULTI_INSTANCE_STROKE);

    if (sequential) {
      g.draw(new Line2D.Double(lineX, lineY, lineX + rectangleWidth, lineY));
      g.draw(new Line2D.Double(lineX, lineY + rectangleHeight / 2, lineX + rectangleWidth, lineY + rectangleHeight / 2));
      g.draw(new Line2D.Double(lineX, lineY + rectangleHeight, lineX + rectangleWidth, lineY + rectangleHeight));
    } else {
      g.draw(new Line2D.Double(lineX, lineY, lineX, lineY + rectangleHeight));
      g.draw(new Line2D.Double(lineX + rectangleWidth / 2, lineY, lineX + rectangleWidth / 2, lineY + rectangleHeight));
      g.draw(new Line2D.Double(lineX + rectangleWidth, lineY, lineX + rectangleWidth, lineY + rectangleHeight));
    }

    g.setStroke(orginalStroke);
  }

  public void drawHighLight(int x, int y, int width, int height) {
    Paint originalPaint = g.getPaint();
    Stroke originalStroke = g.getStroke();

    g.setPaint(HIGHLIGHT_COLOR);
    g.setStroke(THICK_TASK_BORDER_STROKE);

    RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, 20, 20);
    g.draw(rect);

    g.setPaint(originalPaint);
    g.setStroke(originalStroke);
  }

  public void drawTextAnnotation(String text, GraphicInfo graphicInfo) {
    int x = (int) graphicInfo.getX();
    int y = (int) graphicInfo.getY();
    int width = (int) graphicInfo.getWidth();
    int height = (int) graphicInfo.getHeight();
    
	  Font originalFont = g.getFont();
	  Stroke originalStroke = g.getStroke();
	  
	  g.setFont(ANNOTATION_FONT);
	  
	  Path2D path = new Path2D.Double();
	  x += .5;
	  int lineLength = 18;
	  path.moveTo(x + lineLength, y);
	  path.lineTo(x, y);
	  path.lineTo(x, y + height);
	  path.lineTo(x + lineLength, y + height);
	  
	  path.lineTo(x + lineLength, y + height -1);
	  path.lineTo(x + 1, y + height -1);
	  path.lineTo(x + 1, y + 1);
	  path.lineTo(x + lineLength, y + 1);
	  path.closePath();
	  
	  g.draw(path);
	  
	  int boxWidth = width - (2 * ANNOTATION_TEXT_PADDING);
    int boxHeight = height - (2 * ANNOTATION_TEXT_PADDING);
    int boxX = x + width/2 - boxWidth/2;
    int boxY = y + height/2 - boxHeight/2;
    
    if (text != null && text.isEmpty() == false) {
      drawMultilineAnnotationText(text, boxX, boxY, boxWidth, boxHeight);
    }
	  
	  // restore originals
    g.setFont(originalFont);
    g.setStroke(originalStroke);
  }
  
  public void drawLabel(String text, GraphicInfo graphicInfo){
	  drawLabel(text, graphicInfo, true);
  }
  public void drawLabel(String text, GraphicInfo graphicInfo, boolean centered){
	float interline = 1.0f;
	
    // text
    if (text != null && text.length()>0) {
      Paint originalPaint = g.getPaint();
      Font originalFont = g.getFont();

      g.setPaint(LABEL_COLOR);
      g.setFont(LABEL_FONT);

      int wrapWidth = 100;
      int textY = (int) graphicInfo.getY();
      
      // TODO: use drawMultilineText()
      AttributedString as = new AttributedString(text);
      as.addAttribute(TextAttribute.FOREGROUND, g.getPaint());
      as.addAttribute(TextAttribute.FONT, g.getFont());
      AttributedCharacterIterator aci = as.getIterator();
      FontRenderContext frc = new FontRenderContext(null, true, false);
      LineBreakMeasurer lbm = new LineBreakMeasurer(aci, frc);
      
      while (lbm.getPosition() < text.length()) {
    	  TextLayout tl = lbm.nextLayout(wrapWidth);
    	  textY += tl.getAscent();
    	  Rectangle2D bb = tl.getBounds();
    	  double tX = graphicInfo.getX();
    	  if (centered) {
    	  	tX += (int) (graphicInfo.getWidth() / 2 - bb.getWidth() / 2);
    	  }
    	  tl.draw(g, (float) tX, textY);
    	  textY += tl.getDescent() + tl.getLeading() + (interline - 1.0f) * tl.getAscent();
      }
  
      // restore originals
      g.setFont(originalFont);
      g.setPaint(originalPaint);
    }
  }

  /**
   * This method makes coordinates of connection flow better.
   * @param sourceShapeType
   * @param targetShapeType
   * @param sourceGraphicInfo
   * @param targetGraphicInfo
   * @param graphicInfoList
   * 
   */
  public List<GraphicInfo> connectionPerfectionizer(SHAPE_TYPE sourceShapeType, SHAPE_TYPE targetShapeType, GraphicInfo sourceGraphicInfo, GraphicInfo targetGraphicInfo, List<GraphicInfo> graphicInfoList) {
    Shape shapeFirst = createShape(sourceShapeType, sourceGraphicInfo);
    Shape shapeLast = createShape(targetShapeType, targetGraphicInfo);

    if (graphicInfoList != null && graphicInfoList.size() > 0) {
      GraphicInfo graphicInfoFirst = graphicInfoList.get(0);
      GraphicInfo graphicInfoLast = graphicInfoList.get(graphicInfoList.size()-1);
      if (shapeFirst != null) {
        graphicInfoFirst.setX(shapeFirst.getBounds2D().getCenterX());
        graphicInfoFirst.setY(shapeFirst.getBounds2D().getCenterY());
      }
      if (shapeLast != null) {
        graphicInfoLast.setX(shapeLast.getBounds2D().getCenterX());
        graphicInfoLast.setY(shapeLast.getBounds2D().getCenterY());
      }
  
      Point p = null;
      
      if (shapeFirst != null) {
        Line2D.Double lineFirst = new Line2D.Double(graphicInfoFirst.getX(), graphicInfoFirst.getY(), graphicInfoList.get(1).getX(), graphicInfoList.get(1).getY());
        p = getIntersection(shapeFirst, lineFirst);
        if (p != null) {
          graphicInfoFirst.setX(p.getX());
          graphicInfoFirst.setY(p.getY());
        }
      }
  
      if (shapeLast != null) {
        Line2D.Double lineLast = new Line2D.Double(graphicInfoLast.getX(), graphicInfoLast.getY(), graphicInfoList.get(graphicInfoList.size()-2).getX(), graphicInfoList.get(graphicInfoList.size()-2).getY());
        p = getIntersection(shapeLast, lineLast);
        if (p != null) {
          graphicInfoLast.setX(p.getX());
          graphicInfoLast.setY(p.getY());
        }
      }
    }

    return graphicInfoList;
  }

  /**
   * This method creates shape by type and coordinates.
   * @param shapeType
   * @param graphicInfo
   * @return Shape
   */
  private static Shape createShape(SHAPE_TYPE shapeType, GraphicInfo graphicInfo) {
    if (SHAPE_TYPE.Rectangle.equals(shapeType)) {
      // source is rectangle
      return new Rectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());       
    } else if (SHAPE_TYPE.Rhombus.equals(shapeType)) {
      // source is rhombus
      Path2D.Double rhombus = new Path2D.Double();
      rhombus.moveTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY() + graphicInfo.getHeight());
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY());
      rhombus.lineTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);
      rhombus.closePath();
      return rhombus;
    } else if (SHAPE_TYPE.Ellipse.equals(shapeType)) {
      // source is ellipse
      return new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());
    } else {
      // unknown source element, just do not correct coordinates
    }
    return null;
  }

  /**
   * This method returns intersection point of shape border and line.
   * 
   * @param shape
   * @param line
   * @return Point
   */
  private static Point getIntersection(Shape shape, Line2D.Double line) {
    if (shape instanceof Ellipse2D) {
      return getEllipseIntersection(shape, line);
    } else if (shape instanceof Rectangle2D || shape instanceof Path2D) {
      return getShapeIntersection(shape, line);
    } else {
      // something strange
      return null;
    }
  }

    /**
     * This method calculates ellipse intersection with line
     * @param shape
     *                  Bounds of this shape used to calculate parameters of inscribed into this bounds ellipse.
     * @param line
     * @return Intersection point
     */
  private static Point getEllipseIntersection(Shape shape, Line2D.Double line) {
    double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
    double x = shape.getBounds2D().getWidth()/2 * Math.cos(angle) + shape.getBounds2D().getCenterX();
    double y = shape.getBounds2D().getHeight()/2 * Math.sin(angle) + shape.getBounds2D().getCenterY();
    Point p = new Point();
    p.setLocation(x, y);
    return p;
  }

  /**
   * This method calculates shape intersection with line.
   * 
   * @param shape
   * @param line
   * @return Intersection point
   */
  private static Point getShapeIntersection(Shape shape, Line2D.Double line) {
    PathIterator it = shape.getPathIterator(null);
    double[] coords = new double[6];
    double[] pos = new double[2];
    Line2D.Double l = new Line2D.Double();
    while (!it.isDone()) {
      int type = it.currentSegment(coords);
      switch (type) {
      case PathIterator.SEG_MOVETO:
        pos[0] = coords[0];
        pos[1] = coords[1];
        break;
      case PathIterator.SEG_LINETO:
        l = new Line2D.Double(pos[0], pos[1], coords[0], coords[1]);
        if (line.intersectsLine(l)) {
          return getLinesIntersection(line, l);
        }
        pos[0] = coords[0];
        pos[1] = coords[1];
        break;
      case PathIterator.SEG_CLOSE:
        break;
      default:
        // whatever
      }
      it.next();
    }
    return null;
  }

  /**
   * This method calculates intersections of two lines.
   * @param a Line 1
   * @param b Line 2
   * @return Intersection point
   */
  private static Point getLinesIntersection(Line2D a, Line2D b) {
    double d  = (a.getX1()-a.getX2())*(b.getY2()-b.getY1()) - (a.getY1()-a.getY2())*(b.getX2()-b.getX1());
    double da = (a.getX1()-b.getX1())*(b.getY2()-b.getY1()) - (a.getY1()-b.getY1())*(b.getX2()-b.getX1());
    // double db = (a.getX1()-a.getX2())*(a.getY1()-b.getY1()) - (a.getY1()-a.getY2())*(a.getX1()-b.getX1());
    double ta = da/d;
    // double tb = db/d;
    Point p = new Point();
    p.setLocation(a.getX1()+ta*(a.getX2()-a.getX1()), a.getY1()+ta*(a.getY2()-a.getY1()));
    return p;
  }
}
!@#$%
20190526_171339,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.standalone.cfg;

import java.util.List;
import java.util.Map;

import org.apache.ibatis.annotations.Select;

public interface MyTestMapper {

  @Select("SELECT ID_ as id, NAME_ as name, CREATE_TIME_ as createTime FROM ACT_RU_TASK")
  List<Map<String, Object>> selectTasks();

  @Select({ "SELECT task.ID_ as taskId, variable.LONG_ as variableValue FROM ACT_RU_VARIABLE variable", "inner join ACT_RU_TASK task on variable.TASK_ID_ = task.ID_",
      "where variable.NAME_ = #{variableName}" })
  List<Map<String, Object>> selectTaskWithSpecificVariable(String variableName);

}
!@#$%
20190526_171339,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.standalone.cfg;

import java.util.List;
import java.util.Map;

import org.apache.ibatis.annotations.Select;

public interface MyTestMapper {

	@Select("SELECT ID_ as id, NAME_ as name, CREATE_TIME_ as createTime FROM ACT_RU_TASK")
	List<Map<String, Object>> selectTasks();
	
	@Select({
		"SELECT task.ID_ as taskId, variable.LONG_ as variableValue FROM ACT_RU_VARIABLE variable",
		"inner join ACT_RU_TASK task on variable.TASK_ID_ = task.ID_",
		"where variable.NAME_ = #{variableName}"
	})
	List<Map<String, Object>> selectTaskWithSpecificVariable(String variableName);
	
}
!@#$%
20190526_171339,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.standalone.cfg;

import java.util.List;
import java.util.Map;

import org.apache.ibatis.annotations.Select;

public interface MyTestMapper {

	@Select("SELECT ID_ as ID, NAME_ as NAME, CREATE_TIME_ as CREATETIME FROM ACT_RU_TASK")
	List<Map<String, Object>> selectTasks();
	
	@Select({
		"SELECT task.ID_ as TASKID, variable.LONG_ as VARIABLEVALUE FROM ACT_RU_VARIABLE variable",
		"inner join ACT_RU_TASK task on variable.TASK_ID_ = task.ID_",
		"where variable.NAME_ = #{variableName}"
	})
	List<Map<String, Object>> selectTaskWithSpecificVariable(String variableName);
	
}
!@#$%
20190526_171340,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.standalone.cfg;

import java.util.List;
import java.util.Map;

import org.activiti.engine.impl.cmd.AbstractCustomSqlExecution;
import org.activiti.engine.impl.cmd.CustomSqlExecution;
import org.activiti.engine.impl.test.ResourceActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author jbarrez
 */
public class CustomMybatisMapperTest extends ResourceActivitiTestCase {

  public CustomMybatisMapperTest() {
    super("org/activiti/standalone/cfg/custom-mybatis-mappers-activiti.cfg.xml");
  }

  public void testSelectTaskColumns() {

    // Create test data
    for (int i = 0; i < 5; i++) {
      Task task = taskService.newTask();
      task.setName(i + "");
      taskService.saveTask(task);
    }

    // Fetch the columns we're interested in
    CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution = new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {

      public List<Map<String, Object>> execute(MyTestMapper customMapper) {
        return customMapper.selectTasks();
      }
    };

    // Verify
    List<Map<String, Object>> tasks = managementService.executeCustomSql(customSqlExecution);
    assertEquals(5, tasks.size());
    for (int i = 0; i < 5; i++) {
      Map<String, Object> task = tasks.get(i);
      assertNotNull(task.get("ID"));
      assertNotNull(task.get("NAME"));
      assertNotNull(task.get("CREATETIME"));
    }

    // Cleanup
    for (Task task : taskService.createTaskQuery().list()) {
      taskService.deleteTask(task.getId());
      historyService.deleteHistoricTaskInstance(task.getId());
    }

  }

  public void testFetchTaskWithSpecificVariable() {

    // Create test data
    for (int i = 0; i < 5; i++) {
      Task task = taskService.newTask();
      task.setName(i + "");
      taskService.saveTask(task);

      taskService.setVariable(task.getId(), "myVar", Long.valueOf(task.getId()) * 2);
      taskService.setVariable(task.getId(), "myVar2", "SomeOtherValue");
    }

    // Fetch data with custom query
    CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution = new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {

      public List<Map<String, Object>> execute(MyTestMapper customMapper) {
        return customMapper.selectTaskWithSpecificVariable("myVar");
      }

    };

    // Verify
    List<Map<String, Object>> results = managementService.executeCustomSql(customSqlExecution);
    assertEquals(5, results.size());
    for (int i = 0; i < 5; i++) {
      Map<String, Object> result = results.get(i);
      Long id = Long.valueOf((String) result.get("TASKID"));
      Long variableValue = (Long) result.get("VARIABLEVALUE");
      assertEquals(id * 2, variableValue.longValue());
    }

    // Cleanup
    for (Task task : taskService.createTaskQuery().list()) {
      taskService.deleteTask(task.getId());
      historyService.deleteHistoricTaskInstance(task.getId());
    }

  }

}
!@#$%
20190526_171340,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.standalone.cfg;

import java.util.List;
import java.util.Map;

import org.activiti.engine.impl.cmd.AbstractCustomSqlExecution;
import org.activiti.engine.impl.cmd.CustomSqlExecution;
import org.activiti.engine.impl.test.ResourceActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author jbarrez
 */
public class CustomMybatisMapperTest extends ResourceActivitiTestCase {
	
	public CustomMybatisMapperTest() {
		super("org/activiti/standalone/cfg/custom-mybatis-mappers-activiti.cfg.xml");
	}
	
	public void testSelectTaskColumns() {
		
		// Create test data
		for (int i=0; i<5; i++) {
			Task task = taskService.newTask();
			task.setName(i + "");
			taskService.saveTask(task);
		}
		
		// Fetch the columns we're interested in
		CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution = 
				new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {
			
			public List<Map<String, Object>> execute(MyTestMapper customMapper) {
				return customMapper.selectTasks();
			}
		
		};
		
		// Verify
		List<Map<String, Object>> tasks = managementService.executeCustomSql(customSqlExecution);
		assertEquals(5, tasks.size());
		for (int i=0; i<5; i++) {
			Map<String, Object> task = tasks.get(i);
			assertNotNull(task.get("ID"));
			assertNotNull(task.get("NAME"));
			assertNotNull(task.get("CREATETIME"));
		}
		
		// Cleanup
		for (Task task : taskService.createTaskQuery().list()) {
			taskService.deleteTask(task.getId());
			historyService.deleteHistoricTaskInstance(task.getId());
		}
		
	}
	
	public void testFetchTaskWithSpecificVariable() {
		
		// Create test data
		for (int i=0; i<5; i++) {
			Task task = taskService.newTask();
			task.setName(i + "");
			taskService.saveTask(task);
			
			taskService.setVariable(task.getId(), "myVar", Long.valueOf(task.getId()) * 2);
			taskService.setVariable(task.getId(), "myVar2", "SomeOtherValue");
		}
		
		// Fetch data with custom query
		CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution = 
				new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {
			
			public List<Map<String, Object>> execute(MyTestMapper customMapper) {
				return customMapper.selectTaskWithSpecificVariable("myVar");
			}
		
		};
		
		// Verify
		List<Map<String, Object>> results = managementService.executeCustomSql(customSqlExecution);
		assertEquals(5, results.size());
		for (int i=0; i<5; i++) {
			Map<String, Object> result = results.get(i);
			Long id = Long.valueOf((String) result.get("TASKID"));
			Long variableValue = (Long) result.get("VARIABLEVALUE");
			assertEquals(id * 2, variableValue.longValue());
		}
		
		// Cleanup
		for (Task task : taskService.createTaskQuery().list()) {
			taskService.deleteTask(task.getId());
			historyService.deleteHistoricTaskInstance(task.getId());
		}
		
	}
	
}
!@#$%
20190526_171340,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.standalone.cfg;

import java.util.List;
import java.util.Map;

import org.activiti.engine.impl.cmd.AbstractCustomSqlExecution;
import org.activiti.engine.impl.cmd.CustomSqlExecution;
import org.activiti.engine.impl.test.ResourceActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author jbarrez
 */
public class CustomMybatisMapperTest extends ResourceActivitiTestCase {
	
	public CustomMybatisMapperTest() {
		super("org/activiti/standalone/cfg/custom-mybatis-mappers-activiti.cfg.xml");
	}
	
	public void testSelectTaskColumns() {
		
		// Create test data
		for (int i=0; i<5; i++) {
			Task task = taskService.newTask();
			task.setName(i + "");
			taskService.saveTask(task);
		}
		
		// Fetch the columns we're interested in
		CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution = 
				new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {
			
			public List<Map<String, Object>> execute(MyTestMapper customMapper) {
				return customMapper.selectTasks();
			}
		
		};
		
		// Verify
		List<Map<String, Object>> tasks = managementService.executeCustomSql(customSqlExecution);
		assertEquals(5, tasks.size());
		for (int i=0; i<5; i++) {
			Map<String, Object> task = tasks.get(i);
			assertNotNull(getResultObject("ID", task));
			assertNotNull(getResultObject("NAME", task));
			assertNotNull(getResultObject("CREATETIME", task));
		}
		
		// Cleanup
		for (Task task : taskService.createTaskQuery().list()) {
			taskService.deleteTask(task.getId());
			historyService.deleteHistoricTaskInstance(task.getId());
		}
		
	}
	
	public void testFetchTaskWithSpecificVariable() {
		
		// Create test data
		for (int i=0; i<5; i++) {
			Task task = taskService.newTask();
			task.setName(i + "");
			taskService.saveTask(task);
			
			taskService.setVariable(task.getId(), "myVar", Long.valueOf(task.getId()) * 2);
			taskService.setVariable(task.getId(), "myVar2", "SomeOtherValue");
		}
		
		// Fetch data with custom query
		CustomSqlExecution<MyTestMapper, List<Map<String, Object>>> customSqlExecution = 
				new AbstractCustomSqlExecution<MyTestMapper, List<Map<String, Object>>>(MyTestMapper.class) {
			
			public List<Map<String, Object>> execute(MyTestMapper customMapper) {
				return customMapper.selectTaskWithSpecificVariable("myVar");
			}
		
		};
		
		// Verify
		List<Map<String, Object>> results = managementService.executeCustomSql(customSqlExecution);
		assertEquals(5, results.size());
		for (int i=0; i<5; i++) {
		  Map<String, Object> result = results.get(i);
		  Long id = Long.valueOf((String) getResultObject("TASKID", result));
		  Long variableValue = ((Number) getResultObject("VARIABLEVALUE", result)).longValue();
		  assertEquals(id * 2, variableValue.longValue());
		}
		
		// Cleanup
		for (Task task : taskService.createTaskQuery().list()) {
			taskService.deleteTask(task.getId());
			historyService.deleteHistoricTaskInstance(task.getId());
		}
		
	}
	
	protected Object getResultObject(String key, Map<String, Object> result) {
		Object resultObject = result.get(key);
		if (resultObject == null) { // postgresql requires lower case
			resultObject = result.get(key.toLowerCase());
		}
		return resultObject;
	}
	
}
!@#$%
20190526_171342,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.standalone.calendar;

import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.TimeZone;

import org.activiti.engine.impl.calendar.DurationHelper;
import org.activiti.engine.impl.util.DefaultClockImpl;
import org.activiti.engine.runtime.Clock;
import org.apache.commons.lang3.time.DateUtils;
import org.junit.Test;

public class DurationHelperTest {

  @Test
  public void shouldNotExceedNumber() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(new Date(0));
    DurationHelper dh = new DurationHelper("R2/PT10S", testingClock);

    testingClock.setCurrentTime(new Date(15000));
    assertEquals(20000, dh.getDateAfter().getTime());

    testingClock.setCurrentTime(new Date(30000));
    assertEquals(30000, dh.getDateAfter().getTime());
  }

  @Test
  public void shouldNotExceedNumberPeriods() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(parse("19700101-00:00:00"));
    DurationHelper dh = new DurationHelper("R2/1970-01-01T00:00:00/1970-01-01T00:00:10", testingClock);

    testingClock.setCurrentTime(parse("19700101-00:00:15"));
    assertEquals(parse("19700101-00:00:20"), dh.getDateAfter());

    testingClock.setCurrentTime(parse("19700101-00:00:30"));
    assertEquals(parse("19700101-00:00:30"), dh.getDateAfter());
  }

  @Test
  public void shouldNotExceedNumberNegative() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(parse("19700101-00:00:00"));
    DurationHelper dh = new DurationHelper("R2/PT10S/1970-01-01T00:00:50", testingClock);

    testingClock.setCurrentTime(parse("19700101-00:00:20"));
    assertEquals(parse("19700101-00:00:30"), dh.getDateAfter());

    testingClock.setCurrentTime(parse("19700101-00:00:35"));

    assertEquals(parse("19700101-00:00:35"), dh.getDateAfter());
  }

  @Test
  public void daylightSavingFall() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-04:45:00", TimeZone.getTimeZone("UTC")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));

    testingClock.setCurrentCalendar(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")));

    assertEquals(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));
  }

  @Test
  public void daylightSavingFallFirstHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")));
    Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T01:45:00-04:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(easternTime));
  }

  @Test
  public void daylightSavingFallSecondHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")));
    Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T01:45:00-05:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-07:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(easternTime));
  }

  @Test
  public void daylightSavingFallObservedFirstHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT1H", testingClock);
    Calendar expected = parseCalendarWithOffset("20131103-01:45:00 -04:00", TimeZone.getTimeZone("US/Eastern"));

    assertTrue(expected.compareTo(dh.getCalendarAfter()) == 0);
  }

  @Test
  public void daylightSavingFallObservedSecondHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT2H", testingClock);
    Calendar expected = parseCalendarWithOffset("20131103-01:45:00 -05:00", TimeZone.getTimeZone("US/Eastern"));

    assertTrue(expected.compareTo(dh.getCalendarAfter()) == 0);
  }

  @Test
  public void daylightSavingSpring() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-05:45:00", TimeZone.getTimeZone("UTC")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T00:45:00-05:00/PT1H", testingClock);

    assertEquals(parseCalendar("20140309-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));
  }

  @Test
  public void daylightSavingSpringObserved() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-01:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T01:45:00/PT1H", testingClock);
    Calendar expected = parseCalendar("20140309-03:45:00", TimeZone.getTimeZone("US/Eastern"));

    assertEquals(expected, dh.getCalendarAfter());
  }

  @Test
  public void daylightSaving25HourDay() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:00:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20131104-00:00:00", TimeZone.getTimeZone("US/Eastern")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving23HourDay() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-00:00:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20140310-00:00:00", TimeZone.getTimeZone("US/Eastern")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving25HourDayEurope() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131027-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")));

    DurationHelper dh = new DurationHelper("R2/2013-10-27T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20131028-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving23HourDayEurope() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140330-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")));

    DurationHelper dh = new DurationHelper("R2/2014-03-30T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20140331-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  private Date parse(String str) throws Exception {
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd-HH:mm:ss");
    return simpleDateFormat.parse(str);
  }

  private Calendar parseCalendarWithOffset(String str, TimeZone timeZone) throws Exception {

    Calendar cal = Calendar.getInstance();
    cal.setTime(DateUtils.parseDate(str, "yyyyMMdd-HH:mm:ssZZ"));
    return cal;
  }

  private Calendar parseCalendar(String str, TimeZone timeZone) throws Exception {
    return parseCalendar(str, timeZone, "yyyyMMdd-HH:mm:ss");
  }

  private Calendar parseCalendar(String str, TimeZone timeZone, String format) throws Exception {
    Calendar date = new GregorianCalendar(timeZone);
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
    simpleDateFormat.setTimeZone(timeZone);
    date.setTime(simpleDateFormat.parse(str));
    return date;
  }

}
!@#$%
20190526_171342,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.standalone.calendar;

import static groovy.util.GroovyTestCase.assertEquals;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.TimeZone;

import org.activiti.engine.impl.calendar.DurationHelper;
import org.activiti.engine.impl.util.DefaultClockImpl;
import org.activiti.engine.runtime.Clock;
import org.apache.commons.lang3.time.DateUtils;
import org.junit.Test;

public class DurationHelperTest {

  @Test
  public void shouldNotExceedNumber() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(new Date(0));
    DurationHelper dh = new DurationHelper("R2/PT10S", testingClock);

    testingClock.setCurrentTime(new Date(15000));
    assertEquals(20000, dh.getDateAfter().getTime());

    testingClock.setCurrentTime(new Date(30000));
    assertEquals(30000, dh.getDateAfter().getTime());
  }

  @Test
  public void shouldNotExceedNumberPeriods() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(parse("19700101-00:00:00"));
    DurationHelper dh = new DurationHelper("R2/1970-01-01T00:00:00/1970-01-01T00:00:10", testingClock);

    testingClock.setCurrentTime(parse("19700101-00:00:15"));
    assertEquals(parse("19700101-00:00:20"), dh.getDateAfter());


    testingClock.setCurrentTime(parse("19700101-00:00:30"));
    assertEquals(parse("19700101-00:00:30"), dh.getDateAfter());
  }

  @Test
  public void shouldNotExceedNumberNegative() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(parse("19700101-00:00:00"));
    DurationHelper dh = new DurationHelper("R2/PT10S/1970-01-01T00:00:50", testingClock);

    testingClock.setCurrentTime(parse("19700101-00:00:20"));
    assertEquals(parse("19700101-00:00:30"), dh.getDateAfter());


    testingClock.setCurrentTime(parse("19700101-00:00:35"));

    assertEquals(parse("19700101-00:00:35"), dh.getDateAfter());
  }

  @Test
  public void daylightSavingFall() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-04:45:00", TimeZone.getTimeZone("UTC")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));

    testingClock.setCurrentCalendar(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")));

    assertEquals(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));
}

  @Test
  public void daylightSavingFallFirstHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")));
    Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T01:45:00-04:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(easternTime));
  }

  @Test
  public void daylightSavingFallSecondHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")));
    Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T01:45:00-05:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-07:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(easternTime));
  }


  @Test
  public void daylightSavingFallObservedFirstHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT1H", testingClock);
    Calendar expected = parseCalendarWithOffset("20131103-01:45:00 -04:00", TimeZone.getTimeZone("US/Eastern"));

    assertEquals(expected, dh.getCalendarAfter());
  }

  @Test
  public void daylightSavingFallObservedSecondHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT2H", testingClock);
    Calendar expected = parseCalendarWithOffset("20131103-01:45:00 -05:00", TimeZone.getTimeZone("US/Eastern"));

    assertEquals(expected, dh.getCalendarAfter());
  }

  @Test
  public void daylightSavingSpring() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-05:45:00", TimeZone.getTimeZone("UTC")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T00:45:00-05:00/PT1H", testingClock);

    assertEquals(parseCalendar("20140309-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));
}

  @Test
  public void daylightSavingSpringObserved() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-01:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T01:45:00/PT1H", testingClock);
    Calendar expected = parseCalendar("20140309-03:45:00", TimeZone.getTimeZone("US/Eastern"));

    assertEquals(expected, dh.getCalendarAfter());
  }

  @Test
  public void daylightSaving25HourDay() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:00:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20131104-00:00:00", TimeZone.getTimeZone("US/Eastern")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving23HourDay() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-00:00:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20140310-00:00:00", TimeZone.getTimeZone("US/Eastern")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving25HourDayEurope() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131027-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")));

    DurationHelper dh = new DurationHelper("R2/2013-10-27T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20131028-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving23HourDayEurope() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140330-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")));

    DurationHelper dh = new DurationHelper("R2/2014-03-30T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20140331-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  private Date parse(String str) throws Exception {
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd-HH:mm:ss");
    return simpleDateFormat.parse(str);
  }

  private Calendar parseCalendarWithOffset(String str, TimeZone timeZone) throws Exception {

    Calendar cal = Calendar.getInstance();
      cal.setTime(DateUtils.parseDate(str, "yyyyMMdd-HH:mm:ssZZ" ));
    return cal;
  }

  private Calendar parseCalendar(String str, TimeZone timeZone) throws Exception {
    return parseCalendar(str, timeZone, "yyyyMMdd-HH:mm:ss");
  }

  private Calendar parseCalendar(String str, TimeZone timeZone, String format) throws Exception {
    Calendar date = new GregorianCalendar(timeZone);
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
    simpleDateFormat.setTimeZone(timeZone);
    date.setTime(simpleDateFormat.parse(str));
    return date;
  }

}
!@#$%
20190526_171342,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.standalone.calendar;

import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.TimeZone;

import org.activiti.engine.impl.calendar.DurationHelper;
import org.activiti.engine.impl.util.DefaultClockImpl;
import org.activiti.engine.runtime.Clock;
import org.apache.commons.lang3.time.DateUtils;
import org.junit.Test;

public class DurationHelperTest {

  @Test
  public void shouldNotExceedNumber() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(new Date(0));
    DurationHelper dh = new DurationHelper("R2/PT10S", testingClock);

    testingClock.setCurrentTime(new Date(15000));
    assertEquals(20000, dh.getDateAfter().getTime());

    testingClock.setCurrentTime(new Date(30000));
    assertEquals(30000, dh.getDateAfter().getTime());
  }

  @Test
  public void shouldNotExceedNumberPeriods() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(parse("19700101-00:00:00"));
    DurationHelper dh = new DurationHelper("R2/1970-01-01T00:00:00/1970-01-01T00:00:10", testingClock);

    testingClock.setCurrentTime(parse("19700101-00:00:15"));
    assertEquals(parse("19700101-00:00:20"), dh.getDateAfter());


    testingClock.setCurrentTime(parse("19700101-00:00:30"));
    assertEquals(parse("19700101-00:00:30"), dh.getDateAfter());
  }

  @Test
  public void shouldNotExceedNumberNegative() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentTime(parse("19700101-00:00:00"));
    DurationHelper dh = new DurationHelper("R2/PT10S/1970-01-01T00:00:50", testingClock);

    testingClock.setCurrentTime(parse("19700101-00:00:20"));
    assertEquals(parse("19700101-00:00:30"), dh.getDateAfter());


    testingClock.setCurrentTime(parse("19700101-00:00:35"));

    assertEquals(parse("19700101-00:00:35"), dh.getDateAfter());
  }

  @Test
  public void daylightSavingFall() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-04:45:00", TimeZone.getTimeZone("UTC")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));

    testingClock.setCurrentCalendar(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")));

    assertEquals(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));
}

  @Test
  public void daylightSavingFallFirstHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-05:45:00", TimeZone.getTimeZone("UTC")));
    Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T01:45:00-04:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(easternTime));
  }

  @Test
  public void daylightSavingFallSecondHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-06:45:00", TimeZone.getTimeZone("UTC")));
    Calendar easternTime = testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T01:45:00-05:00/PT1H", testingClock);

    assertEquals(parseCalendar("20131103-07:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(easternTime));
  }


  @Test
  public void daylightSavingFallObservedFirstHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT1H", testingClock);
    Calendar expected = parseCalendarWithOffset("20131103-01:45:00 -04:00", TimeZone.getTimeZone("US/Eastern"));

    assertTrue(expected.compareTo(dh.getCalendarAfter()) == 0);
  }

  @Test
  public void daylightSavingFallObservedSecondHour() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:45:00-04:00/PT2H", testingClock);
    Calendar expected = parseCalendarWithOffset("20131103-01:45:00 -05:00", TimeZone.getTimeZone("US/Eastern"));

    assertTrue(expected.compareTo(dh.getCalendarAfter()) == 0);
  }

  @Test
  public void daylightSavingSpring() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-05:45:00", TimeZone.getTimeZone("UTC")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T00:45:00-05:00/PT1H", testingClock);

    assertEquals(parseCalendar("20140309-06:45:00", TimeZone.getTimeZone("UTC")), dh.getCalendarAfter(testingClock.getCurrentCalendar(TimeZone.getTimeZone("US/Eastern"))));
}

  @Test
  public void daylightSavingSpringObserved() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-01:45:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T01:45:00/PT1H", testingClock);
    Calendar expected = parseCalendar("20140309-03:45:00", TimeZone.getTimeZone("US/Eastern"));

    assertEquals(expected, dh.getCalendarAfter());
  }

  @Test
  public void daylightSaving25HourDay() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131103-00:00:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2013-11-03T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20131104-00:00:00", TimeZone.getTimeZone("US/Eastern")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving23HourDay() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140309-00:00:00", TimeZone.getTimeZone("US/Eastern")));

    DurationHelper dh = new DurationHelper("R2/2014-03-09T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20140310-00:00:00", TimeZone.getTimeZone("US/Eastern")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving25HourDayEurope() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20131027-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")));

    DurationHelper dh = new DurationHelper("R2/2013-10-27T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20131028-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  @Test
  public void daylightSaving23HourDayEurope() throws Exception {
    Clock testingClock = new DefaultClockImpl();
    testingClock.setCurrentCalendar(parseCalendar("20140330-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")));

    DurationHelper dh = new DurationHelper("R2/2014-03-30T00:00:00/P1D", testingClock);

    assertEquals(parseCalendar("20140331-00:00:00", TimeZone.getTimeZone("Europe/Amsterdam")), dh.getCalendarAfter(testingClock.getCurrentCalendar()));
  }

  private Date parse(String str) throws Exception {
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd-HH:mm:ss");
    return simpleDateFormat.parse(str);
  }

  private Calendar parseCalendarWithOffset(String str, TimeZone timeZone) throws Exception {

    Calendar cal = Calendar.getInstance();
      cal.setTime(DateUtils.parseDate(str, "yyyyMMdd-HH:mm:ssZZ" ));
    return cal;
  }

  private Calendar parseCalendar(String str, TimeZone timeZone) throws Exception {
    return parseCalendar(str, timeZone, "yyyyMMdd-HH:mm:ss");
  }

  private Calendar parseCalendar(String str, TimeZone timeZone, String format) throws Exception {
    Calendar date = new GregorianCalendar(timeZone);
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format);
    simpleDateFormat.setTimeZone(timeZone);
    date.setTime(simpleDateFormat.parse(str));
    return date;
  }

}
!@#$%
20190526_171345,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.examples.task;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.engine.ActivitiOptimisticLockingException;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.persistence.entity.TaskEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author Joram Barrez
 */
public class StandaloneTaskTest extends PluggableActivitiTestCase {

  public void setUp() throws Exception {
    super.setUp();
    identityService.saveUser(identityService.newUser("kermit"));
    identityService.saveUser(identityService.newUser("gonzo"));
  }

  public void tearDown() throws Exception {
    identityService.deleteUser("kermit");
    identityService.deleteUser("gonzo");
    super.tearDown();
  }

  public void testCreateToComplete() {

    // Create and save task
    Task task = taskService.newTask();
    task.setName("testTask");
    taskService.saveTask(task);
    String taskId = task.getId();

    // Add user as candidate user
    taskService.addCandidateUser(taskId, "kermit");
    taskService.addCandidateUser(taskId, "gonzo");

    // Retrieve task list for kermit
    List<Task> tasks = taskService.createTaskQuery().taskCandidateUser("kermit").list();
    assertEquals(1, tasks.size());
    assertEquals("testTask", tasks.get(0).getName());

    // Retrieve task list for gonzo
    tasks = taskService.createTaskQuery().taskCandidateUser("gonzo").list();
    assertEquals(1, tasks.size());
    assertEquals("testTask", tasks.get(0).getName());

    task.setName("Update name");
    taskService.saveTask(task);
    tasks = taskService.createTaskQuery().taskCandidateUser("kermit").list();
    assertEquals(1, tasks.size());
    assertEquals("Update name", tasks.get(0).getName());

    // Claim task
    taskService.claim(taskId, "kermit");

    // Tasks shouldn't appear in the candidate tasklists anymore
    assertTrue(taskService.createTaskQuery().taskCandidateUser("kermit").list().isEmpty());
    assertTrue(taskService.createTaskQuery().taskCandidateUser("gonzo").list().isEmpty());

    // Complete task
    taskService.deleteTask(taskId, true);

    // Task should be removed from runtime data
    // TODO: check for historic data when implemented!
    assertNull(taskService.createTaskQuery().taskId(taskId).singleResult());
  }

  public void testOptimisticLockingThrownOnMultipleUpdates() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    String taskId = task.getId();

    // first modification
    Task task1 = taskService.createTaskQuery().taskId(taskId).singleResult();
    Task task2 = taskService.createTaskQuery().taskId(taskId).singleResult();

    task1.setDescription("first modification");
    taskService.saveTask(task1);

    // second modification on the initial instance
    task2.setDescription("second modification");
    try {
      taskService.saveTask(task2);
      fail("should get an exception here as the task was modified by someone else.");
    } catch (ActivitiOptimisticLockingException expected) {
      // exception was thrown as expected
    }

    taskService.deleteTask(taskId, true);
  }

  // See https://activiti.atlassian.net/browse/ACT-1290
  public void testRevisionUpdatedOnSave() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    assertEquals(1, ((TaskEntity) task).getRevision());

    task.setDescription("first modification");
    taskService.saveTask(task);
    assertEquals(2, ((TaskEntity) task).getRevision());

    task.setDescription("second modification");
    taskService.saveTask(task);
    assertEquals(3, ((TaskEntity) task).getRevision());

    taskService.deleteTask(task.getId(), true);
  }

  // See https://activiti.atlassian.net/browse/ACT-1290
  public void testRevisionUpdatedOnSaveWhenFetchedUsingQuery() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    assertEquals(1, ((TaskEntity) task).getRevision());

    task.setAssignee("kermit");
    taskService.saveTask(task);
    assertEquals(2, ((TaskEntity) task).getRevision());

    // Now fetch the task through the query api
    task = taskService.createTaskQuery().singleResult();
    assertEquals(2, ((TaskEntity) task).getRevision());
    task.setPriority(1);
    taskService.saveTask(task);

    assertEquals(3, ((TaskEntity) task).getRevision());

    taskService.deleteTask(task.getId(), true);
  }
  
  public void testHistoricVariableOkOnUpdate() {
    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.AUDIT)) {
  		// 1. create a task
  		Task task = taskService.newTask();
  		task.setName("test execution");
  		task.setOwner("josOwner");
  		task.setAssignee("JosAssignee");
  		taskService.saveTask(task);
  		 
  		// 2. set task variables
  		Map<String, Object> taskVariables = new HashMap<String, Object>();
  		taskVariables.put("finishedAmount", 0);
  		taskService.setVariables(task.getId(), taskVariables);
  		 
  		// 3. complete this task with a new variable
  		Map<String, Object> finishVariables = new HashMap<String, Object>();
  		finishVariables.put("finishedAmount", 40);
  		taskService.complete(task.getId(), finishVariables);
  		 
  		// 4. get completed variable
  		List<HistoricVariableInstance> hisVarList = historyService.createHistoricVariableInstanceQuery().taskId(task.getId()).list();
  		assertEquals(1, hisVarList.size());
  		assertEquals(40, hisVarList.get(0).getValue());
  		
  		// Cleanup
  		historyService.deleteHistoricTaskInstance(task.getId());
    }
	}

}
!@#$%
20190526_171345,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.examples.task;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.engine.ActivitiOptimisticLockingException;
import org.activiti.engine.history.HistoricDetail;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.impl.persistence.entity.TaskEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author Joram Barrez
 */
public class StandaloneTaskTest extends PluggableActivitiTestCase {

  public void setUp() throws Exception {
    super.setUp();
    identityService.saveUser(identityService.newUser("kermit"));
    identityService.saveUser(identityService.newUser("gonzo"));
  }

  public void tearDown() throws Exception {
    identityService.deleteUser("kermit");
    identityService.deleteUser("gonzo");
    super.tearDown();
  }

  public void testCreateToComplete() {

    // Create and save task
    Task task = taskService.newTask();
    task.setName("testTask");
    taskService.saveTask(task);
    String taskId = task.getId();

    // Add user as candidate user
    taskService.addCandidateUser(taskId, "kermit");
    taskService.addCandidateUser(taskId, "gonzo");

    // Retrieve task list for kermit
    List<Task> tasks = taskService.createTaskQuery().taskCandidateUser("kermit").list();
    assertEquals(1, tasks.size());
    assertEquals("testTask", tasks.get(0).getName());

    // Retrieve task list for gonzo
    tasks = taskService.createTaskQuery().taskCandidateUser("gonzo").list();
    assertEquals(1, tasks.size());
    assertEquals("testTask", tasks.get(0).getName());
    
    task.setName("Update name");
    taskService.saveTask(task);
    tasks = taskService.createTaskQuery().taskCandidateUser("kermit").list();
    assertEquals(1, tasks.size());
    assertEquals("Update name", tasks.get(0).getName());

    // Claim task
    taskService.claim(taskId, "kermit");

    // Tasks shouldn't appear in the candidate tasklists anymore
    assertTrue(taskService.createTaskQuery().taskCandidateUser("kermit").list().isEmpty());
    assertTrue(taskService.createTaskQuery().taskCandidateUser("gonzo").list().isEmpty());

    // Complete task
    taskService.deleteTask(taskId, true);

    // Task should be removed from runtime data
    // TODO: check for historic data when implemented!
    assertNull(taskService.createTaskQuery().taskId(taskId).singleResult());
  }
  
  public void testOptimisticLockingThrownOnMultipleUpdates() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    String taskId = task.getId();
    
    // first modification
    Task task1 = taskService.createTaskQuery().taskId(taskId).singleResult();
    Task task2 = taskService.createTaskQuery().taskId(taskId).singleResult();
    
    task1.setDescription("first modification");
    taskService.saveTask(task1);

    // second modification on the initial instance
    task2.setDescription("second modification");
    try {
      taskService.saveTask(task2);
      fail("should get an exception here as the task was modified by someone else.");
    } catch (ActivitiOptimisticLockingException expected) {
      //  exception was thrown as expected
    }
    
    taskService.deleteTask(taskId, true);
  }
  
  // See http://jira.codehaus.org/browse/ACT-1290 
  public void testRevisionUpdatedOnSave() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    assertEquals(1, ((TaskEntity) task).getRevision());

    task.setDescription("first modification");
    taskService.saveTask(task);
    assertEquals(2, ((TaskEntity) task).getRevision());

    task.setDescription("second modification");
    taskService.saveTask(task);
    assertEquals(3, ((TaskEntity) task).getRevision());
    
    taskService.deleteTask(task.getId(), true);
  }

  // See http://jira.codehaus.org/browse/ACT-1290 
  public void testRevisionUpdatedOnSaveWhenFetchedUsingQuery() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    assertEquals(1, ((TaskEntity) task).getRevision());
    
    task.setAssignee("kermit");
    taskService.saveTask(task);
    assertEquals(2, ((TaskEntity) task).getRevision());
    
    // Now fetch the task through the query api
    task = taskService.createTaskQuery().singleResult();
    assertEquals(2, ((TaskEntity) task).getRevision());
    task.setPriority(1);
    taskService.saveTask(task);
    
    assertEquals(3, ((TaskEntity) task).getRevision());
    
    taskService.deleteTask(task.getId(), true);
  }
  
  public void testHistoricVariableOkOnUpdate() {
  		//1. create a task
  		Task task = taskService.newTask();
  		task.setName("test execution");
  		task.setOwner("josOwner");
  		task.setAssignee("JosAssignee");
  		taskService.saveTask(task);
  		 
  		//2. set task variables
  		Map<String, Object> taskVariables = new HashMap<String, Object>();
  		taskVariables.put("finishedAmount", 0);
  		taskService.setVariables(task.getId(), taskVariables);
  		 
  		 
  		//3. complete this task with a new variable
  		Map<String, Object> finishVariables = new HashMap<String, Object>();
  		finishVariables.put("finishedAmount", 40);
  		taskService.complete(task.getId(), finishVariables);
  		 
  		//4. get completed variable
  		List<HistoricVariableInstance> hisVarList = historyService.createHistoricVariableInstanceQuery().taskId(task.getId()).list();
  		assertEquals(1, hisVarList.size());
  		assertEquals(40, hisVarList.get(0).getValue());
  		
  		// Cleanup
  		historyService.deleteHistoricTaskInstance(task.getId());
  	}

}
!@#$%
20190526_171345,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.examples.task;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.engine.ActivitiOptimisticLockingException;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.persistence.entity.TaskEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author Joram Barrez
 */
public class StandaloneTaskTest extends PluggableActivitiTestCase {

  public void setUp() throws Exception {
    super.setUp();
    identityService.saveUser(identityService.newUser("kermit"));
    identityService.saveUser(identityService.newUser("gonzo"));
  }

  public void tearDown() throws Exception {
    identityService.deleteUser("kermit");
    identityService.deleteUser("gonzo");
    super.tearDown();
  }

  public void testCreateToComplete() {

    // Create and save task
    Task task = taskService.newTask();
    task.setName("testTask");
    taskService.saveTask(task);
    String taskId = task.getId();

    // Add user as candidate user
    taskService.addCandidateUser(taskId, "kermit");
    taskService.addCandidateUser(taskId, "gonzo");

    // Retrieve task list for kermit
    List<Task> tasks = taskService.createTaskQuery().taskCandidateUser("kermit").list();
    assertEquals(1, tasks.size());
    assertEquals("testTask", tasks.get(0).getName());

    // Retrieve task list for gonzo
    tasks = taskService.createTaskQuery().taskCandidateUser("gonzo").list();
    assertEquals(1, tasks.size());
    assertEquals("testTask", tasks.get(0).getName());
    
    task.setName("Update name");
    taskService.saveTask(task);
    tasks = taskService.createTaskQuery().taskCandidateUser("kermit").list();
    assertEquals(1, tasks.size());
    assertEquals("Update name", tasks.get(0).getName());

    // Claim task
    taskService.claim(taskId, "kermit");

    // Tasks shouldn't appear in the candidate tasklists anymore
    assertTrue(taskService.createTaskQuery().taskCandidateUser("kermit").list().isEmpty());
    assertTrue(taskService.createTaskQuery().taskCandidateUser("gonzo").list().isEmpty());

    // Complete task
    taskService.deleteTask(taskId, true);

    // Task should be removed from runtime data
    // TODO: check for historic data when implemented!
    assertNull(taskService.createTaskQuery().taskId(taskId).singleResult());
  }
  
  public void testOptimisticLockingThrownOnMultipleUpdates() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    String taskId = task.getId();
    
    // first modification
    Task task1 = taskService.createTaskQuery().taskId(taskId).singleResult();
    Task task2 = taskService.createTaskQuery().taskId(taskId).singleResult();
    
    task1.setDescription("first modification");
    taskService.saveTask(task1);

    // second modification on the initial instance
    task2.setDescription("second modification");
    try {
      taskService.saveTask(task2);
      fail("should get an exception here as the task was modified by someone else.");
    } catch (ActivitiOptimisticLockingException expected) {
      //  exception was thrown as expected
    }
    
    taskService.deleteTask(taskId, true);
  }
  
  // See https://activiti.atlassian.net/browse/ACT-1290
  public void testRevisionUpdatedOnSave() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    assertEquals(1, ((TaskEntity) task).getRevision());

    task.setDescription("first modification");
    taskService.saveTask(task);
    assertEquals(2, ((TaskEntity) task).getRevision());

    task.setDescription("second modification");
    taskService.saveTask(task);
    assertEquals(3, ((TaskEntity) task).getRevision());
    
    taskService.deleteTask(task.getId(), true);
  }

  // See https://activiti.atlassian.net/browse/ACT-1290
  public void testRevisionUpdatedOnSaveWhenFetchedUsingQuery() {
    Task task = taskService.newTask();
    taskService.saveTask(task);
    assertEquals(1, ((TaskEntity) task).getRevision());
    
    task.setAssignee("kermit");
    taskService.saveTask(task);
    assertEquals(2, ((TaskEntity) task).getRevision());
    
    // Now fetch the task through the query api
    task = taskService.createTaskQuery().singleResult();
    assertEquals(2, ((TaskEntity) task).getRevision());
    task.setPriority(1);
    taskService.saveTask(task);
    
    assertEquals(3, ((TaskEntity) task).getRevision());
    
    taskService.deleteTask(task.getId(), true);
  }
  
  public void testHistoricVariableOkOnUpdate() {
    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.AUDIT)) {
  		// 1. create a task
  		Task task = taskService.newTask();
  		task.setName("test execution");
  		task.setOwner("josOwner");
  		task.setAssignee("JosAssignee");
  		taskService.saveTask(task);
  		 
  		// 2. set task variables
  		Map<String, Object> taskVariables = new HashMap<String, Object>();
  		taskVariables.put("finishedAmount", 0);
  		taskService.setVariables(task.getId(), taskVariables);
  		 
  		// 3. complete this task with a new variable
  		Map<String, Object> finishVariables = new HashMap<String, Object>();
  		finishVariables.put("finishedAmount", 40);
  		taskService.complete(task.getId(), finishVariables);
  		 
  		// 4. get completed variable
  		List<HistoricVariableInstance> hisVarList = historyService.createHistoricVariableInstanceQuery().taskId(task.getId()).list();
  		assertEquals(1, hisVarList.size());
  		assertEquals(40, hisVarList.get(0).getValue());
  		
  		// Cleanup
  		historyService.deleteHistoricTaskInstance(task.getId());
    }
	}

}
!@#$%
20190526_171350,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.regression;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;

/**
 * All tests that do not belong to any other test case, but test a supposedly working feature go here.
 * 
 * @author Joram Barrez
 */
public class RegressionTest extends PluggableActivitiTestCase {

  // https://jira.codehaus.org/browse/ACT-1623
  // NPE when eventbased gateway is after referenced event
  public void testAct1623() throws Exception {

    // Deploy processes
    String deploymentId = repositoryService.createDeployment().addClasspathResource("org/activiti/engine/test/regression/act1623-processOne.bpmn")
        .addClasspathResource("org/activiti/engine/test/regression/act1623-processTwo.bpmn").deploy().getId();

    runtimeService.startProcessInstanceByKey("ProcessOne");

    // Clean
    repositoryService.deleteDeployment(deploymentId, true);
  }

}
!@#$%
20190526_171350,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.regression;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;


/**
 * All tests that do not belong to any other test case, but test a supposedly working feature go here.
 * 
 * @author Joram Barrez
 */
public class RegressionTest extends PluggableActivitiTestCase {
  
  // https://jira.codehaus.org/browse/ACT-1623
  // NPE when eventbased gateway is after referenced event
  public void testAct1623() throws Exception {
   
    // Deploy processes
    String deploymentId = repositoryService.createDeployment()
      .addClasspathResource("org/activiti/engine/test/regression/act1623-processOne.bpmn")
      .addClasspathResource("org/activiti/engine/test/regression/act1623-processTwo.bpmn")
      .deploy()
      .getId();
    
    runtimeService.startProcessInstanceByKey("ProcessOne");
  
    // Clean
    repositoryService.deleteDeployment(deploymentId, true);
  }

}
!@#$%
20190526_171350,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.regression;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;


/**
 * All tests that do not belong to any other test case, but test a supposedly working feature go here.
 * 
 * @author Joram Barrez
 */
public class RegressionTest extends PluggableActivitiTestCase {
  
  // https://activiti.atlassian.net/browse/ACT-1623
  // NPE when eventbased gateway is after referenced event
  public void testAct1623() throws Exception {
   
    // Deploy processes
    String deploymentId = repositoryService.createDeployment()
      .addClasspathResource("org/activiti/engine/test/regression/act1623-processOne.bpmn")
      .addClasspathResource("org/activiti/engine/test/regression/act1623-processTwo.bpmn")
      .deploy()
      .getId();
    
    runtimeService.startProcessInstanceByKey("ProcessOne");
  
    // Clean
    repositoryService.deleteDeployment(deploymentId, true);
  }

}
!@#$%
20190526_171402,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.usertask;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.IdentityLink;
import org.activiti.engine.task.IdentityLinkType;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

import com.fasterxml.jackson.databind.node.ObjectNode;


/**
 * @author Tijs Rademakers
 */
public class DynamicUserTaskTest extends PluggableActivitiTestCase {
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.assignment.bpmn20.xml"})
  public void testChangeAssignee() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getAssignee());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskAssignee("task1", "test2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test2", task.getAssignee());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.assignment.bpmn20.xml"})
  public void testChangeOwner() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("ownerTest", task.getOwner());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskOwner("task1", "ownerTest2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("ownerTest2", task.getOwner());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeCandidateUsers() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    List<IdentityLink> taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    boolean candidateUserTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      }
    }
    assertFalse(candidateUserTestFound);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskCandidateUser("task1", "test", true);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    taskService.complete(task.getId());
    
    infoNode = dynamicBpmnService.getProcessDefinitionInfo(processDefinitionId);
    dynamicBpmnService.changeUserTaskCandidateUser("task1", "test2", false, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    boolean candidateUserTest2Found = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        } else if ("test2".equals(identityLink.getUserId())) {
          candidateUserTest2Found = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    assertTrue(candidateUserTest2Found);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeCandidateGroups() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    List<IdentityLink> taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    boolean candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertFalse(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test", true);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertTrue(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    infoNode = dynamicBpmnService.getProcessDefinitionInfo(processDefinitionId);
    dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test2", false, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateGroupTestFound = false;
    boolean candidateGroupTest2Found = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        } else if ("test2".equals(identityLink.getGroupId())) {
          candidateGroupTest2Found = true;
        }
      }
    }
    assertTrue(candidateGroupTestFound);
    assertTrue(candidateGroupTest2Found);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeCandidateUsersAndGroups() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    List<IdentityLink> taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    boolean candidateUserTestFound = false;
    boolean candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      } else if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertFalse(candidateUserTestFound);
    assertFalse(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test", true);
    dynamicBpmnService.changeUserTaskCandidateUser("task1", "test", true, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      } else if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    assertTrue(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    infoNode = dynamicBpmnService.getProcessDefinitionInfo(processDefinitionId);
    dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test2", false, infoNode);
    dynamicBpmnService.changeUserTaskCandidateUser("task1", "test2", false, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    boolean candidateUserTestFound2 = false;
    candidateGroupTestFound = false;
    boolean candidateGroupTest2Found = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        } else if ("test2".equals(identityLink.getUserId())) {
          candidateUserTestFound2 = true;
        }
      } else if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        } else if ("test2".equals(identityLink.getGroupId())) {
          candidateGroupTest2Found = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    assertTrue(candidateUserTestFound2);
    assertTrue(candidateGroupTestFound);
    assertTrue(candidateGroupTest2Found);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeNameAndDescription() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertNull(task.getName());
    assertNull(task.getDescription());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskName("task1", "Task name test");
    dynamicBpmnService.changeUserTaskDescription("task1", "Task description test", infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("Task name test", task.getName());
    assertEquals("Task description test", task.getDescription());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.assignment.bpmn20.xml"})
  public void testChangePriorityAndCategory() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals(50, task.getPriority());
    assertNull(task.getCategory());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskPriority("task1", "99");
    dynamicBpmnService.changeUserTaskCategory("task1", "categoryTest", infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals(99, task.getPriority());
    assertEquals("categoryTest", task.getCategory());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment
  public void testChangeFormKey() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskFormKey("task1", "test2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test2", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment
  public void testChangeFormKeyWithExpression() {
    // first test without changing the form key
    Map<String, Object> varMap = new HashMap<String, Object>();
    varMap.put("start", "test");
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask", varMap);
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskFormKey("task1", "${anotherKey}");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    varMap = new HashMap<String, Object>();
    varMap.put("anotherKey", "test2");
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask", varMap);
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test2", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }

}
!@#$%
20190526_171402,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.usertask;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.IdentityLink;
import org.activiti.engine.task.IdentityLinkType;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

import com.fasterxml.jackson.databind.node.ObjectNode;


/**
 * @author Tijs Rademakers
 */
public class DynamicUserTaskTest extends PluggableActivitiTestCase {
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.assignment.bpmn20.xml"})
  public void testChangeAssignee() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getAssignee());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskAssignee("task1", "test2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test2", task.getAssignee());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.assignment.bpmn20.xml"})
  public void testChangeOwner() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("ownerTest", task.getOwner());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskOwner("task1", "ownerTest2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("ownerTest2", task.getOwner());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeCandidateUsers() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    List<IdentityLink> taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    boolean candidateUserTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      }
    }
    assertFalse(candidateUserTestFound);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskCandidateUser("task1", "test", true);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    taskService.complete(task.getId());
    
    infoNode = dynamicBpmnService.getProcessDefinitionInfo(processDefinitionId);
    dynamicBpmnService.changeUserTaskCandidateUser("task1", "test2", false, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    boolean candidateUserTest2Found = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        } else if ("test2".equals(identityLink.getUserId())) {
          candidateUserTest2Found = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    assertTrue(candidateUserTest2Found);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeCandidateGroups() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    List<IdentityLink> taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    boolean candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertFalse(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test", true);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertTrue(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    infoNode = dynamicBpmnService.getProcessDefinitionInfo(processDefinitionId);
    dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test2", false, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateGroupTestFound = false;
    boolean candidateGroupTest2Found = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        } else if ("test2".equals(identityLink.getGroupId())) {
          candidateGroupTest2Found = true;
        }
      }
    }
    assertTrue(candidateGroupTestFound);
    assertTrue(candidateGroupTest2Found);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeCandidateUsersAndGroups() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    List<IdentityLink> taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    boolean candidateUserTestFound = false;
    boolean candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      } else if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertFalse(candidateUserTestFound);
    assertFalse(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test", true);
    dynamicBpmnService.changeUserTaskCandidateUser("task1", "test", true, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    candidateGroupTestFound = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        }
      } else if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    assertTrue(candidateGroupTestFound);
    taskService.complete(task.getId());
    
    infoNode = dynamicBpmnService.getProcessDefinitionInfo(processDefinitionId);
    dynamicBpmnService.changeUserTaskCandidateGroup("task1", "test2", false, infoNode);
    dynamicBpmnService.changeUserTaskCandidateUser("task1", "test2", false, infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskIdentityLinks = taskService.getIdentityLinksForTask(task.getId());
    candidateUserTestFound = false;
    boolean candidateUserTestFound2 = false;
    candidateGroupTestFound = false;
    boolean candidateGroupTest2Found = false;
    for (IdentityLink identityLink : taskIdentityLinks) {
      if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getUserId() != null && identityLink.getGroupId() == null) {
        if ("test".equals(identityLink.getUserId())) {
          candidateUserTestFound = true;
        } else if ("test2".equals(identityLink.getUserId())) {
          candidateUserTestFound2 = true;
        }
      } else if (IdentityLinkType.CANDIDATE.equals(identityLink.getType()) && identityLink.getGroupId() != null && identityLink.getUserId() == null) {
        if ("test".equals(identityLink.getGroupId())) {
          candidateGroupTestFound = true;
        } else if ("test2".equals(identityLink.getGroupId())) {
          candidateGroupTest2Found = true;
        }
      }
    }
    assertTrue(candidateUserTestFound);
    assertTrue(candidateUserTestFound2);
    assertTrue(candidateGroupTestFound);
    assertTrue(candidateGroupTest2Found);
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.basictask.bpmn20.xml"})
  public void testChangeNameAndDescription() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertNull(task.getName());
    assertNull(task.getDescription());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskName("task1", "Task name test");
    dynamicBpmnService.changeUserTaskDescription("task1", "Task description test", infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("Task name test", task.getName());
    assertEquals("Task description test", task.getDescription());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment(resources={"org/activiti/engine/test/bpmn/usertask/DynamicUserTaskTest.assignment.bpmn20.xml"})
  public void testChangePriorityAndCategory() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals(50, task.getPriority());
    assertNull(task.getCategory());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskPriority("task1", "99");
    dynamicBpmnService.changeUserTaskCategory("task1", "categoryTest", infoNode);
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals(99, task.getPriority());
    assertEquals("categoryTest", task.getCategory());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment
  public void testChangeFormKey() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskFormKey("task1", "test2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test2", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment
  public void testChangeFormKeyWithExpression() {
    // first test without changing the form key
    Map<String, Object> varMap = new HashMap<String, Object>();
    varMap.put("start", "test");
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask", varMap);
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskFormKey("task1", "${anotherKey}");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    varMap = new HashMap<String, Object>();
    varMap.put("anotherKey", "test2");
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask", varMap);
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test2", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }

}
!@#$%
20190526_171404,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.usertask;



import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;
import org.activiti.engine.impl.test.AbstractActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

import com.fasterxml.jackson.databind.node.ObjectNode;


/**
 * @author Tijs Rademakers
 */
public class DisabledDefinitionInfoCacheTest extends AbstractActivitiTestCase {

  protected static ProcessEngine cachedProcessEngine;
  
  protected void initializeProcessEngine() {
    if (cachedProcessEngine==null) {
      ProcessEngineConfigurationImpl processEngineConfiguration = (ProcessEngineConfigurationImpl) ProcessEngineConfiguration
          .createProcessEngineConfigurationFromResource("org/activiti/engine/test/bpmn/usertask/activiti.cfg.xml");
      
      cachedProcessEngine = processEngineConfiguration.buildProcessEngine();
    }
    processEngine = cachedProcessEngine;
  }

  @Deployment
  public void testChangeFormKey() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskFormKey("task1", "test2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment
  public void testChangeClassName() {
    // first test without changing the class name
    Map<String, Object> varMap = new HashMap<String, Object>();
    varMap.put("count", 0);
    varMap.put("count2", 0);
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicServiceTask", varMap);
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertEquals(1, runtimeService.getVariable(processInstance.getId(), "count"));
    assertEquals(0, runtimeService.getVariable(processInstance.getId(), "count2"));
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the class name
    varMap = new HashMap<String, Object>();
    varMap.put("count", 0);
    varMap.put("count2", 0);
    processInstance = runtimeService.startProcessInstanceByKey("dynamicServiceTask", varMap);
    
    String processDefinitionId = processInstance.getProcessDefinitionId();
    ObjectNode infoNode = dynamicBpmnService.changeServiceTaskClassName("service", "org.activiti.engine.test.bpmn.servicetask.DummyServiceTask2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertEquals(1, runtimeService.getVariable(processInstance.getId(), "count"));
    assertEquals(0, runtimeService.getVariable(processInstance.getId(), "count2"));
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
}
!@#$%
20190526_171404,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.usertask;



import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;
import org.activiti.engine.impl.test.AbstractActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

import com.fasterxml.jackson.databind.node.ObjectNode;


/**
 * @author Tijs Rademakers
 */
public class DisabledDefinitionInfoCacheTest extends AbstractActivitiTestCase {

  protected static ProcessEngine cachedProcessEngine;
  
  protected void initializeProcessEngine() {
    if (cachedProcessEngine==null) {
      ProcessEngineConfigurationImpl processEngineConfiguration = (ProcessEngineConfigurationImpl) ProcessEngineConfiguration
          .createProcessEngineConfigurationFromResource("org/activiti/engine/test/bpmn/usertask/activiti.cfg.xml");
      
      cachedProcessEngine = processEngineConfiguration.buildProcessEngine();
    }
    processEngine = cachedProcessEngine;
  }

  @Deployment
  public void testChangeFormKey() {
    // first test without changing the form key
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    String processDefinitionId = processInstance.getProcessDefinitionId();
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the form key
    ObjectNode infoNode = dynamicBpmnService.changeUserTaskFormKey("task1", "test2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    processInstance = runtimeService.startProcessInstanceByKey("dynamicUserTask");
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    assertEquals("test", task.getFormKey());
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
  @Deployment
  public void testChangeClassName() {
    // first test without changing the class name
    Map<String, Object> varMap = new HashMap<String, Object>();
    varMap.put("count", 0);
    varMap.put("count2", 0);
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("dynamicServiceTask", varMap);
    
    Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertEquals(1, runtimeService.getVariable(processInstance.getId(), "count"));
    assertEquals(0, runtimeService.getVariable(processInstance.getId(), "count2"));
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
    
    // now test with changing the class name
    varMap = new HashMap<String, Object>();
    varMap.put("count", 0);
    varMap.put("count2", 0);
    processInstance = runtimeService.startProcessInstanceByKey("dynamicServiceTask", varMap);
    
    String processDefinitionId = processInstance.getProcessDefinitionId();
    ObjectNode infoNode = dynamicBpmnService.changeServiceTaskClassName("service", "org.activiti.engine.test.bpmn.servicetask.DummyServiceTask2");
    dynamicBpmnService.saveProcessDefinitionInfo(processDefinitionId, infoNode);
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertEquals(1, runtimeService.getVariable(processInstance.getId(), "count"));
    assertEquals(0, runtimeService.getVariable(processInstance.getId(), "count2"));
    
    task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
    taskService.complete(task.getId());
    
    assertProcessEnded(processInstance.getId());
  }
  
}
!@#$%
20190526_171407,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.subprocess;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.converter.BpmnXMLConverter;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.engine.ActivitiException;
import org.activiti.engine.history.HistoricActivityInstance;
import org.activiti.engine.history.HistoricActivityInstanceQuery;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.history.HistoricVariableInstanceQuery;
import org.activiti.engine.impl.test.ResourceActivitiTestCase;
import org.activiti.engine.impl.util.io.InputStreamSource;
import org.activiti.engine.impl.util.io.StreamSource;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.ProcessInstance;

public class CallActivityTest extends ResourceActivitiTestCase {

  private static String MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_mainProcess.bpmn.xml";
  private static String CHILD_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_childProcess.bpmn.xml";
  private static String MESSAGE_TRIGGERED_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_messageTriggeredProcess.bpmn.xml";
  private static String INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testInheritVariablesCallActivity_mainProcess.bpmn20.xml";
  private static String INHERIT_VARIABLES_CHILD_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testInheritVariablesCallActivity_childProcess.bpmn20.xml";
  private static String NOT_INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testNotInheritVariablesCallActivity_mainProcess.bpmn20.xml";
  
  public CallActivityTest() {
    super("org/activiti/standalone/parsing/encoding.activiti.cfg.xml");
  }

  public void testInstantiateProcessByMessage() throws Exception {
    BpmnModel messageTriggeredBpmnModel = loadBPMNModel(MESSAGE_TRIGGERED_PROCESS_RESOURCE);

    Deployment messageTriggeredBpmnDeployment = processEngine.getRepositoryService().createDeployment().name("messageTriggeredProcessDeployment")
        .addBpmnModel("messageTriggered.bpmn20.xml", messageTriggeredBpmnModel).deploy();

    ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByMessage("TRIGGER_PROCESS_MESSAGE");
    assertNotNull(childProcessInstance);
  }

  public void testInstantiateSuspendedProcessByMessage() throws Exception {
    BpmnModel messageTriggeredBpmnModel = loadBPMNModel(MESSAGE_TRIGGERED_PROCESS_RESOURCE);

    Deployment messageTriggeredBpmnDeployment = processEngine.getRepositoryService().createDeployment().name("messageTriggeredProcessDeployment")
        .addBpmnModel("messageTriggered.bpmn20.xml", messageTriggeredBpmnModel).deploy();

    suspendProcessDefinitions(messageTriggeredBpmnDeployment);

    try {
      ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByMessage("TRIGGER_PROCESS_MESSAGE");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Message Triggered Process", ae.getMessage());
    }

  }

  public void testInstantiateChildProcess() throws Exception {
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService().createDeployment().name("childProcessDeployment").addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByKey("childProcess");
    assertNotNull(childProcessInstance);
  }

  public void testInstantiateSuspendedChildProcess() throws Exception {
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService().createDeployment().name("childProcessDeployment").addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    suspendProcessDefinitions(childDeployment);

    try {
      ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByKey("childProcess");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Child Process", ae.getMessage());
    }

  }

  public void testInstantiateSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService().createDeployment().name("childProcessDeployment").addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    Deployment masterDeployment = processEngine.getRepositoryService().createDeployment().name("masterProcessDeployment").addBpmnModel("masterProcess.bpmn20.xml", mainBpmnModel).deploy();

    suspendProcessDefinitions(childDeployment);

    try {
      ProcessInstance masterProcessInstance = runtimeService.startProcessInstanceByKey("masterProcess");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Child Process", ae.getMessage());
    }

  }
  
  public void testInheritVariablesSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(INHERIT_VARIABLES_CHILD_PROCESS_RESOURCE);

    processEngine.getRepositoryService()
        .createDeployment()
        .name("mainProcessDeployment")
        .addBpmnModel("mainProcess.bpmn20.xml", mainBpmnModel).deploy();

    processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    Map<String, Object> variables = new HashMap<String, Object>();
    variables.put("var1", "String test value");
    variables.put("var2", true);
    variables.put("var3", 12345);
    variables.put("var4", 67890);

    ProcessInstance mainProcessInstance = runtimeService.startProcessInstanceByKey("mainProcess", variables);

    HistoricActivityInstanceQuery activityInstanceQuery = historyService.createHistoricActivityInstanceQuery();
    activityInstanceQuery.processInstanceId(mainProcessInstance.getId());
    activityInstanceQuery.activityId("childProcessCall");
    HistoricActivityInstance activityInstance = activityInstanceQuery.singleResult();
    String calledInstanceId = activityInstance.getCalledProcessInstanceId();

    HistoricVariableInstanceQuery variableInstanceQuery = historyService.createHistoricVariableInstanceQuery();
    List<HistoricVariableInstance> variableInstances = variableInstanceQuery.processInstanceId(calledInstanceId).list();

    assertEquals(4, variableInstances.size());
    for (HistoricVariableInstance variable : variableInstances) {
      assertEquals(variables.get(variable.getVariableName()), variable.getValue());
    }
  }

  public void testNotInheritVariablesSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(NOT_INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(INHERIT_VARIABLES_CHILD_PROCESS_RESOURCE);

    processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();
    
    processEngine.getRepositoryService()
        .createDeployment()
        .name("mainProcessDeployment")
        .addBpmnModel("mainProcess.bpmn20.xml", mainBpmnModel).deploy();
    
    Map<String, Object> variables = new HashMap<String, Object>();
    variables.put("var1", "String test value");
    variables.put("var2", true);
    variables.put("var3", 12345);
    variables.put("var4", 67890);

    ProcessInstance mainProcessInstance = runtimeService.startProcessInstanceByKey("mainProcess", variables);

    HistoricActivityInstanceQuery activityInstanceQuery = historyService.createHistoricActivityInstanceQuery();
    activityInstanceQuery.processInstanceId(mainProcessInstance.getId());
    activityInstanceQuery.activityId("childProcessCall");
    HistoricActivityInstance activityInstance = activityInstanceQuery.singleResult();
    String calledInstanceId = activityInstance.getCalledProcessInstanceId();

    HistoricVariableInstanceQuery variableInstanceQuery = historyService.createHistoricVariableInstanceQuery();
    variableInstanceQuery.processInstanceId(calledInstanceId);
    List<HistoricVariableInstance> variableInstances = variableInstanceQuery.list();

    assertEquals(0, variableInstances.size());
  }

  private void suspendProcessDefinitions(Deployment childDeployment) {
    List<ProcessDefinition> childProcessDefinitionList = repositoryService.createProcessDefinitionQuery().deploymentId(childDeployment.getId()).list();

    for (ProcessDefinition processDefinition : childProcessDefinitionList) {
      repositoryService.suspendProcessDefinitionById(processDefinition.getId());
    }
  }

  protected void tearDown() throws Exception {
    for (Deployment deployment : repositoryService.createDeploymentQuery().list()) {
      repositoryService.deleteDeployment(deployment.getId(), true);
    }
    super.tearDown();
  }

  protected BpmnModel loadBPMNModel(String bpmnModelFilePath) throws Exception {
    InputStream xmlStream = this.getClass().getClassLoader().getResourceAsStream(bpmnModelFilePath);
    StreamSource xmlSource = new InputStreamSource(xmlStream);
    BpmnModel bpmnModel = new BpmnXMLConverter().convertToBpmnModel(xmlSource, false, false, processEngineConfiguration.getXmlEncoding());
    return bpmnModel;
  }

}
!@#$%
20190526_171407,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.subprocess;

import org.activiti.bpmn.converter.BpmnXMLConverter;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.engine.ActivitiException;
import org.activiti.engine.impl.test.ResourceActivitiTestCase;
import org.activiti.engine.impl.util.io.InputStreamSource;
import org.activiti.engine.impl.util.io.StreamSource;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.ProcessInstance;

import java.io.InputStream;
import java.util.List;

public class CallActivityTest extends ResourceActivitiTestCase {

  private static String MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_mainProcess.bpmn.xml";
  private static String CHILD_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_childProcess.bpmn.xml";
  private static String MESSAGE_TRIGGERED_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_messageTriggeredProcess.bpmn.xml";

  public CallActivityTest() {
    super("org/activiti/standalone/parsing/encoding.activiti.cfg.xml");
  }

  public void testInstantiateProcessByMessage() throws Exception {
    BpmnModel messageTriggeredBpmnModel = loadBPMNModel(MESSAGE_TRIGGERED_PROCESS_RESOURCE);

    Deployment messageTriggeredBpmnDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("messageTriggeredProcessDeployment")
        .addBpmnModel("messageTriggered.bpmn20.xml", messageTriggeredBpmnModel).deploy();

    ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByMessage("TRIGGER_PROCESS_MESSAGE");
    assertNotNull(childProcessInstance);
  }

  public void testInstantiateSuspendedProcessByMessage() throws Exception {
    BpmnModel messageTriggeredBpmnModel = loadBPMNModel(MESSAGE_TRIGGERED_PROCESS_RESOURCE);

    Deployment messageTriggeredBpmnDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("messageTriggeredProcessDeployment")
        .addBpmnModel("messageTriggered.bpmn20.xml", messageTriggeredBpmnModel).deploy();

    suspendProcessDefinitions(messageTriggeredBpmnDeployment);

    try {
      ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByMessage("TRIGGER_PROCESS_MESSAGE");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Message Triggered Process", ae.getMessage());
    }

  }

  public void testInstantiateChildProcess() throws Exception {
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByKey("childProcess");
    assertNotNull(childProcessInstance);
  }

  public void testInstantiateSuspendedChildProcess() throws Exception {
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    suspendProcessDefinitions(childDeployment);

    try {
      ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByKey("childProcess");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Child Process", ae.getMessage());
    }

  }


  public void testInstantiateSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    Deployment masterDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("masterProcessDeployment")
        .addBpmnModel("masterProcess.bpmn20.xml", mainBpmnModel).deploy();

    suspendProcessDefinitions(childDeployment);

    try {
      ProcessInstance masterProcessInstance = runtimeService.startProcessInstanceByKey("masterProcess");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Child Process", ae.getMessage());
    }

  }

  private void suspendProcessDefinitions(Deployment childDeployment) {
    List<ProcessDefinition> childProcessDefinitionList = repositoryService.createProcessDefinitionQuery().deploymentId(childDeployment.getId()).list();

    for (ProcessDefinition processDefinition : childProcessDefinitionList) {
      repositoryService.suspendProcessDefinitionById(processDefinition.getId());
    }
  }

  protected void tearDown() throws Exception {
    for (Deployment deployment : repositoryService.createDeploymentQuery().list()) {
      repositoryService.deleteDeployment(deployment.getId(), true);
    }
    super.tearDown();
  }


  protected BpmnModel loadBPMNModel(String bpmnModelFilePath) throws Exception {
    InputStream xmlStream = this.getClass().getClassLoader().getResourceAsStream(bpmnModelFilePath);
    StreamSource xmlSource = new InputStreamSource(xmlStream);
    BpmnModel bpmnModel = new BpmnXMLConverter().convertToBpmnModel(xmlSource, false, false, processEngineConfiguration.getXmlEncoding());
    return bpmnModel;
  }


}
!@#$%
20190526_171407,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.subprocess;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.converter.BpmnXMLConverter;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.engine.ActivitiException;
import org.activiti.engine.history.HistoricActivityInstance;
import org.activiti.engine.history.HistoricActivityInstanceQuery;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.history.HistoricVariableInstanceQuery;
import org.activiti.engine.impl.test.ResourceActivitiTestCase;
import org.activiti.engine.impl.util.io.InputStreamSource;
import org.activiti.engine.impl.util.io.StreamSource;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.ProcessInstance;

public class CallActivityTest extends ResourceActivitiTestCase {

  private static String MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_mainProcess.bpmn.xml";
  private static String CHILD_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_childProcess.bpmn.xml";
  private static String MESSAGE_TRIGGERED_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testSuspendedProcessCallActivity_messageTriggeredProcess.bpmn.xml";
  private static String INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testInheritVariablesCallActivity_mainProcess.bpmn20.xml";
  private static String INHERIT_VARIABLES_CHILD_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testInheritVariablesCallActivity_childProcess.bpmn20.xml";
  private static String NOT_INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE = "org/activiti/engine/test/bpmn/subprocess/SubProcessTest.testNotInheritVariablesCallActivity_mainProcess.bpmn20.xml";

  public CallActivityTest() {
    super("org/activiti/standalone/parsing/encoding.activiti.cfg.xml");
  }

  public void testInstantiateProcessByMessage() throws Exception {
    BpmnModel messageTriggeredBpmnModel = loadBPMNModel(MESSAGE_TRIGGERED_PROCESS_RESOURCE);

    Deployment messageTriggeredBpmnDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("messageTriggeredProcessDeployment")
        .addBpmnModel("messageTriggered.bpmn20.xml", messageTriggeredBpmnModel).deploy();

    ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByMessage("TRIGGER_PROCESS_MESSAGE");
    assertNotNull(childProcessInstance);
  }

  public void testInstantiateSuspendedProcessByMessage() throws Exception {
    BpmnModel messageTriggeredBpmnModel = loadBPMNModel(MESSAGE_TRIGGERED_PROCESS_RESOURCE);

    Deployment messageTriggeredBpmnDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("messageTriggeredProcessDeployment")
        .addBpmnModel("messageTriggered.bpmn20.xml", messageTriggeredBpmnModel).deploy();

    suspendProcessDefinitions(messageTriggeredBpmnDeployment);

    try {
      ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByMessage("TRIGGER_PROCESS_MESSAGE");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Message Triggered Process", ae.getMessage());
    }

  }

  public void testInstantiateChildProcess() throws Exception {
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByKey("childProcess");
    assertNotNull(childProcessInstance);
  }

  public void testInstantiateSuspendedChildProcess() throws Exception {
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    suspendProcessDefinitions(childDeployment);

    try {
      ProcessInstance childProcessInstance = runtimeService.startProcessInstanceByKey("childProcess");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Child Process", ae.getMessage());
    }

  }


  public void testInstantiateSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(CHILD_PROCESS_RESOURCE);

    Deployment childDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    Deployment masterDeployment = processEngine.getRepositoryService()
        .createDeployment()
        .name("masterProcessDeployment")
        .addBpmnModel("masterProcess.bpmn20.xml", mainBpmnModel).deploy();

    suspendProcessDefinitions(childDeployment);

    try {
      ProcessInstance masterProcessInstance = runtimeService.startProcessInstanceByKey("masterProcess");
      fail("Exception expected");
    } catch (ActivitiException ae) {
      assertTextPresent("Cannot start process instance. Process definition Child Process", ae.getMessage());
    }

  }

  public void testInheritVariablesSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(INHERIT_VARIABLES_CHILD_PROCESS_RESOURCE);

    processEngine.getRepositoryService()
        .createDeployment()
        .name("mainProcessDeployment")
        .addBpmnModel("mainProcess.bpmn20.xml", mainBpmnModel).deploy();

    processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();

    Map<String, Object> variables = new HashMap<String, Object>();
    variables.put("var1", "String test value");
    variables.put("var2", true);
    variables.put("var3", 12345);
    variables.put("var4", 67890);

    ProcessInstance mainProcessInstance = runtimeService.startProcessInstanceByKey("mainProcess", variables);

    HistoricActivityInstanceQuery activityInstanceQuery = historyService.createHistoricActivityInstanceQuery();
    activityInstanceQuery.processInstanceId(mainProcessInstance.getId());
    activityInstanceQuery.activityId("childProcessCall");
    HistoricActivityInstance activityInstance = activityInstanceQuery.singleResult();
    String calledInstanceId = activityInstance.getCalledProcessInstanceId();

    HistoricVariableInstanceQuery variableInstanceQuery = historyService.createHistoricVariableInstanceQuery();
    List<HistoricVariableInstance> variableInstances = variableInstanceQuery.processInstanceId(calledInstanceId).list();

    assertEquals(4, variableInstances.size());
    for (HistoricVariableInstance variable : variableInstances) {
      assertEquals(variables.get(variable.getVariableName()), variable.getValue());
    }
  }

  public void testNotInheritVariablesSubprocess() throws Exception {
    BpmnModel mainBpmnModel = loadBPMNModel(NOT_INHERIT_VARIABLES_MAIN_PROCESS_RESOURCE);
    BpmnModel childBpmnModel = loadBPMNModel(INHERIT_VARIABLES_CHILD_PROCESS_RESOURCE);

    processEngine.getRepositoryService()
        .createDeployment()
        .name("childProcessDeployment")
        .addBpmnModel("childProcess.bpmn20.xml", childBpmnModel).deploy();
    
    processEngine.getRepositoryService()
        .createDeployment()
        .name("mainProcessDeployment")
        .addBpmnModel("mainProcess.bpmn20.xml", mainBpmnModel).deploy();
    
    Map<String, Object> variables = new HashMap<String, Object>();
    variables.put("var1", "String test value");
    variables.put("var2", true);
    variables.put("var3", 12345);
    variables.put("var4", 67890);

    ProcessInstance mainProcessInstance = runtimeService.startProcessInstanceByKey("mainProcess", variables);

    HistoricActivityInstanceQuery activityInstanceQuery = historyService.createHistoricActivityInstanceQuery();
    activityInstanceQuery.processInstanceId(mainProcessInstance.getId());
    activityInstanceQuery.activityId("childProcessCall");
    HistoricActivityInstance activityInstance = activityInstanceQuery.singleResult();
    String calledInstanceId = activityInstance.getCalledProcessInstanceId();

    HistoricVariableInstanceQuery variableInstanceQuery = historyService.createHistoricVariableInstanceQuery();
    variableInstanceQuery.processInstanceId(calledInstanceId);
    List<HistoricVariableInstance> variableInstances = variableInstanceQuery.list();

    assertEquals(0, variableInstances.size());
  }

  private void suspendProcessDefinitions(Deployment childDeployment) {
    List<ProcessDefinition> childProcessDefinitionList = repositoryService.createProcessDefinitionQuery().deploymentId(childDeployment.getId()).list();

    for (ProcessDefinition processDefinition : childProcessDefinitionList) {
      repositoryService.suspendProcessDefinitionById(processDefinition.getId());
    }
  }

  protected void tearDown() throws Exception {
    for (Deployment deployment : repositoryService.createDeploymentQuery().list()) {
      repositoryService.deleteDeployment(deployment.getId(), true);
    }
    super.tearDown();
  }


  protected BpmnModel loadBPMNModel(String bpmnModelFilePath) throws Exception {
    InputStream xmlStream = this.getClass().getClassLoader().getResourceAsStream(bpmnModelFilePath);
    StreamSource xmlSource = new InputStreamSource(xmlStream);
    BpmnModel bpmnModel = new BpmnXMLConverter().convertToBpmnModel(xmlSource, false, false, processEngineConfiguration.getXmlEncoding());
    return bpmnModel;
  }


}
!@#$%
20190526_171417,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.event.timer;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventListener;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.test.Deployment;

/**
 * @author Saeid Mirzaei
 * Test case for ACT-4066
 */

public class StartTimerEventRepeatWithoutN extends PluggableActivitiTestCase {

	protected long counter = 0;
	protected StartEventListener startEventListener;
	
	class StartEventListener implements ActivitiEventListener {

		@Override
		public void onEvent(ActivitiEvent event) {
			if (event.getType().equals(ActivitiEventType.TIMER_FIRED)) {
				counter++;
			}
		}

		@Override
		public boolean isFailOnException() {
			return false;
		}
		
	}

	@Override
	protected void setUp() throws Exception {
		super.setUp();
		
		startEventListener = new StartEventListener();
		processEngineConfiguration.getEventDispatcher().addEventListener(startEventListener);
	}
	
	

	@Override
  protected void tearDown() throws Exception {
	  processEngineConfiguration.getEventDispatcher().removeEventListener(startEventListener);
    super.tearDown();
  }



  @Deployment
	public void testStartTimerEventRepeatWithoutN() {
		counter = 0;
		
		try {
			waitForJobExecutorToProcessAllJobs(5500, 500);
			fail("job is finished sooner than expected");
		} catch (ActivitiException e) {
			assertTrue(e.getMessage().startsWith("time limit"));
			assertTrue(counter >= 2);
		}
	}

}
!@#$%
20190526_171417,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.bpmn.event.timer;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventListener;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.test.Deployment;

/**
 * @author Saeid Mirzaei
 * Test case for ACT-4066
 */

public class StartTimerEventRepeatWithoutN extends PluggableActivitiTestCase {

	protected long counter = 0;
	protected StartEventListener startEventListener;
	
	class StartEventListener implements ActivitiEventListener {

		@Override
		public void onEvent(ActivitiEvent event) {
			if (event.getType().equals(ActivitiEventType.TIMER_FIRED)) {
				counter++;
			}
		}

		@Override
		public boolean isFailOnException() {
			return false;
		}
		
	}

	@Override
	protected void setUp() throws Exception {
		super.setUp();
		
		startEventListener = new StartEventListener();
		processEngineConfiguration.getEventDispatcher().addEventListener(startEventListener);
	}
	
	

	@Override
  protected void tearDown() throws Exception {
	  processEngineConfiguration.getEventDispatcher().removeEventListener(startEventListener);
    super.tearDown();
  }



  @Deployment
	public void testStartTimerEventRepeatWithoutN() {
		counter = 0;
		
		try {
			waitForJobExecutorToProcessAllJobs(5500, 500);
			fail("job is finished sooner than expected");
		} catch (ActivitiException e) {
			assertTrue(e.getMessage().startsWith("time limit"));
			assertTrue(counter >= 2);
		}
	}

}
!@#$%
20190526_171420,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.bpmn.event.timer;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.runtime.TimerJobQuery;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

public class IntermediateTimerEventTest extends PluggableActivitiTestCase {

  @Deployment
  public void testCatchingTimerEvent() throws Exception {

    // Set the clock fixed
    Date startTime = new Date();

    // After process start, there should be timer created
    ProcessInstance pi = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample");
    TimerJobQuery jobQuery = managementService.createTimerJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());

    // After setting the clock to time '50minutes and 5 seconds', the second timer should fire
    processEngineConfiguration.getClock().setCurrentTime(new Date(startTime.getTime() + ((50 * 60 * 1000) + 5000)));
    waitForJobExecutorToProcessAllJobs(5000L, 25L);

    assertEquals(0, jobQuery.count());
    assertProcessEnded(pi.getProcessInstanceId());

  }

  @Deployment
  public void testTimerEventWithStartAndDuration() throws Exception {

    Calendar testStartCal = new GregorianCalendar(2016, 0, 1, 10, 0, 0);
    Date testStartTime = testStartCal.getTime();
    processEngineConfiguration.getClock().setCurrentTime(testStartTime);

    ProcessInstance pi = runtimeService.startProcessInstanceByKey("timerEventWithStartAndDuration");
    List<Task> tasks = taskService.createTaskQuery().list();
    assertEquals(1, tasks.size());
    Task task = tasks.get(0);
    assertEquals("Task A", task.getName());

    TimerJobQuery jobQuery = managementService.createTimerJobQuery().processInstanceId(pi.getId());
    assertEquals(0, jobQuery.count());

    Date startDate = new Date();
    runtimeService.setVariable(pi.getId(), "StartDate", startDate);
    taskService.complete(task.getId());

    jobQuery = managementService.createTimerJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());

    processEngineConfiguration.getClock().setCurrentTime(new Date(startDate.getTime() + 7000L));

    jobQuery = managementService.createTimerJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());
    jobQuery = managementService.createTimerJobQuery().processInstanceId(pi.getId()).executable();
    assertEquals(0, jobQuery.count());

    processEngineConfiguration.getClock().setCurrentTime(new Date(startDate.getTime() + 11000L));
    waitForJobExecutorToProcessAllJobs(15000L, 25L);

    jobQuery = managementService.createTimerJobQuery().processInstanceId(pi.getId());
    assertEquals(0, jobQuery.count());

    tasks = taskService.createTaskQuery().list();
    assertEquals(1, tasks.size());
    task = tasks.get(0);
    assertEquals("Task B", task.getName());
    taskService.complete(task.getId());

    assertProcessEnded(pi.getProcessInstanceId());
    
    processEngineConfiguration.getClock().reset();
  }

  @Deployment
  public void testExpression() {
    // Set the clock fixed
    HashMap<String, Object> variables1 = new HashMap<String, Object>();
    variables1.put("dueDate", new Date());

    HashMap<String, Object> variables2 = new HashMap<String, Object>();
    variables2.put("dueDate", new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(new Date()));

    // After process start, there should be timer created
    ProcessInstance pi1 = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample", variables1);
    ProcessInstance pi2 = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample", variables2);

    assertEquals(1, managementService.createTimerJobQuery().processInstanceId(pi1.getId()).count());
    assertEquals(1, managementService.createTimerJobQuery().processInstanceId(pi2.getId()).count());

    // After setting the clock to one second in the future the timers should fire
    List<Job> jobs = managementService.createTimerJobQuery().executable().list();
    assertEquals(2, jobs.size());
    for (Job job : jobs) {
      managementService.moveTimerToExecutableJob(job.getId());
      managementService.executeJob(job.getId());
    }

    assertEquals(0, managementService.createTimerJobQuery().processInstanceId(pi1.getId()).count());
    assertEquals(0, managementService.createTimerJobQuery().processInstanceId(pi2.getId()).count());

    assertProcessEnded(pi1.getProcessInstanceId());
    assertProcessEnded(pi2.getProcessInstanceId());
  }

  @Deployment
  public void testLoop() {
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testLoop");

    // After looping 3 times, the process should end
    for (int i = 0; i < 3; i++) {
      Job timer = managementService.createTimerJobQuery().singleResult();
      managementService.moveTimerToExecutableJob(timer.getId());
      managementService.executeJob(timer.getId());
    }

    assertProcessEnded(processInstance.getId());
  }

  @Deployment
  public void testLoopWithCycle() {
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testLoop");

    // After looping 3 times, the process should end. Cycle should NOT repeat itself
    for (int i = 0; i < 3; i++) {
      Job timer = managementService.createTimerJobQuery().singleResult();
      managementService.moveTimerToExecutableJob(timer.getId());
      managementService.executeJob(timer.getId());
    }

    assertProcessEnded(processInstance.getId());
  }

}
!@#$%
20190526_171420,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.bpmn.event.timer;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.runtime.JobQuery;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

public class IntermediateTimerEventTest extends PluggableActivitiTestCase {

  @Deployment
  public void testCatchingTimerEvent() throws Exception {

    // Set the clock fixed
    Date startTime = new Date();

    // After process start, there should be timer created
    ProcessInstance pi = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample");
    JobQuery jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());

    // After setting the clock to time '50minutes and 5 seconds', the second timer should fire
    processEngineConfiguration.getClock().setCurrentTime(new Date(startTime.getTime() + ((50 * 60 * 1000) + 5000)));
    waitForJobExecutorToProcessAllJobs(5000L, 25L);

    assertEquals(0, jobQuery.count());
    assertProcessEnded(pi.getProcessInstanceId());

  }

  @Deployment
  public void testTimerEventWithStartAndDuration() throws Exception {

    Date testStartTime = new Date();
    processEngineConfiguration.getClock().setCurrentTime(testStartTime);

    ProcessInstance pi = runtimeService.startProcessInstanceByKey("timerEventWithStartAndDuration");
    List<Task> tasks = taskService.createTaskQuery().list();
    assertEquals(1, tasks.size());
    Task task = tasks.get(0);
    assertEquals("Task A", task.getName());

    JobQuery jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(0, jobQuery.count());

    Date startDate = new Date();
    runtimeService.setVariable(pi.getId(), "StartDate", startDate);
    taskService.complete(task.getId());

    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());

    processEngineConfiguration.getClock().setCurrentTime(new Date(startDate.getTime() + 7000L));

    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());
    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId()).executable();
    assertEquals(0, jobQuery.count());

    processEngineConfiguration.getClock().setCurrentTime(new Date(startDate.getTime() + 11000L));
    waitForJobExecutorToProcessAllJobs(15000L, 25L);

    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(0, jobQuery.count());

    tasks = taskService.createTaskQuery().list();
    assertEquals(1, tasks.size());
    task = tasks.get(0);
    assertEquals("Task B", task.getName());
    taskService.complete(task.getId());

    assertProcessEnded(pi.getProcessInstanceId());
  }

  @Deployment
  public void testExpression() {
    // Set the clock fixed
    HashMap<String, Object> variables1 = new HashMap<String, Object>();
    variables1.put("dueDate", new Date());

    HashMap<String, Object> variables2 = new HashMap<String, Object>();
    variables2.put("dueDate", new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(new Date()));

    // After process start, there should be timer created
    ProcessInstance pi1 = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample", variables1);
    ProcessInstance pi2 = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample", variables2);

    assertEquals(1, managementService.createJobQuery().processInstanceId(pi1.getId()).count());
    assertEquals(1, managementService.createJobQuery().processInstanceId(pi2.getId()).count());

    // After setting the clock to one second in the future the timers should fire
    List<Job> jobs = managementService.createJobQuery().executable().list();
    assertEquals(2, jobs.size());
    for (Job job : jobs) {
      managementService.executeJob(job.getId());
    }

    assertEquals(0, managementService.createJobQuery().processInstanceId(pi1.getId()).count());
    assertEquals(0, managementService.createJobQuery().processInstanceId(pi2.getId()).count());

    assertProcessEnded(pi1.getProcessInstanceId());
    assertProcessEnded(pi2.getProcessInstanceId());
  }

  @Deployment
  public void testLoop() {
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testLoop");

    // After looping 3 times, the process should end
    for (int i = 0; i < 3; i++) {
      Job timer = managementService.createJobQuery().singleResult();
      managementService.executeJob(timer.getId());
    }

    assertProcessEnded(processInstance.getId());
  }

  @Deployment
  public void testLoopWithCycle() {
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testLoop");

    // After looping 3 times, the process should end. Cycle should NOT repeat itself
    for (int i = 0; i < 3; i++) {
      Job timer = managementService.createJobQuery().singleResult();
      managementService.executeJob(timer.getId());
    }

    assertProcessEnded(processInstance.getId());
  }

}
!@#$%
20190526_171420,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.bpmn.event.timer;

import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.runtime.JobQuery;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

public class IntermediateTimerEventTest extends PluggableActivitiTestCase {

  @Deployment
  public void testCatchingTimerEvent() throws Exception {

    // Set the clock fixed
    Date startTime = new Date();

    // After process start, there should be timer created
    ProcessInstance pi = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample");
    JobQuery jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());

    // After setting the clock to time '50minutes and 5 seconds', the second timer should fire
    processEngineConfiguration.getClock().setCurrentTime(new Date(startTime.getTime() + ((50 * 60 * 1000) + 5000)));
    waitForJobExecutorToProcessAllJobs(5000L, 25L);

    assertEquals(0, jobQuery.count());
    assertProcessEnded(pi.getProcessInstanceId());
  }

  @Deployment
  public void testTimerEventWithStartAndDuration() throws Exception {

    Date testStartTime = new Date();
    processEngineConfiguration.getClock().setCurrentTime(testStartTime);

    ProcessInstance pi = runtimeService.startProcessInstanceByKey("timerEventWithStartAndDuration");
    List<Task> tasks = taskService.createTaskQuery().list();
    assertEquals(1, tasks.size());
    Task task = tasks.get(0);
    assertEquals("Task A", task.getName());

    JobQuery jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(0, jobQuery.count());

    Date startDate = new Date();
    runtimeService.setVariable(pi.getId(), "StartDate", startDate);
    taskService.complete(task.getId());

    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());

    processEngineConfiguration.getClock().setCurrentTime(new Date(startDate.getTime() + 7000L));

    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(1, jobQuery.count());
    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId()).executable();
    assertEquals(0, jobQuery.count());

    processEngineConfiguration.getClock().setCurrentTime(new Date(startDate.getTime() + 11000L));
    waitForJobExecutorToProcessAllJobs(15000L, 25L);

    jobQuery = managementService.createJobQuery().processInstanceId(pi.getId());
    assertEquals(0, jobQuery.count());

    tasks = taskService.createTaskQuery().list();
    assertEquals(1, tasks.size());
    task = tasks.get(0);
    assertEquals("Task B", task.getName());
    taskService.complete(task.getId());

    assertProcessEnded(pi.getProcessInstanceId());
  }

  @Deployment
  public void testExpression() {
    // Set the clock fixed
    HashMap<String, Object> variables1 = new HashMap<String, Object>();
    variables1.put("dueDate", new Date());

    HashMap<String, Object> variables2 = new HashMap<String, Object>();
    variables2.put("dueDate", new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").format(new Date()));

    // After process start, there should be timer created
    ProcessInstance pi1 = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample", variables1);
    ProcessInstance pi2 = runtimeService.startProcessInstanceByKey("intermediateTimerEventExample", variables2);

    assertEquals(1, managementService.createJobQuery().processInstanceId(pi1.getId()).count());
    assertEquals(1, managementService.createJobQuery().processInstanceId(pi2.getId()).count());

    // After setting the clock to one second in the future the timers should fire
    List<Job> jobs = managementService.createJobQuery().executable().list();
    assertEquals(2, jobs.size());
    for (Job job : jobs) {
      managementService.executeJob(job.getId());
    }

    assertEquals(0, managementService.createJobQuery().processInstanceId(pi1.getId()).count());
    assertEquals(0, managementService.createJobQuery().processInstanceId(pi2.getId()).count());

    assertProcessEnded(pi1.getProcessInstanceId());
    assertProcessEnded(pi2.getProcessInstanceId());
  }

  @Deployment
  public void testLoop() {
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testLoop");

    // After looping 3 times, the process should end
    for (int i = 0; i < 3; i++) {
      Job timer = managementService.createJobQuery().singleResult();
      managementService.executeJob(timer.getId());
    }

    assertProcessEnded(processInstance.getId());
  }

  @Deployment
  public void testLoopWithCycle() {
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testLoop");

    // After looping 3 times, the process should end. Cycle should NOT repeat itself
    for (int i = 0; i < 3; i++) {
      Job timer = managementService.createJobQuery().singleResult();
      managementService.executeJob(timer.getId());
    }

    assertProcessEnded(processInstance.getId());
  }

}
!@#$%
20190526_171441,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.task;

import java.util.Date;
import java.util.List;

import org.activiti.engine.history.HistoricTaskInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author Joram Barrez
 */
public class TaskDueDateTest extends PluggableActivitiTestCase {

  @Override
  protected void tearDown() throws Exception {

    for (Task task : taskService.createTaskQuery().list()) {
      taskService.deleteTask(task.getId(), true);
    }

    super.tearDown();
  }

  /**
   * See https://activiti.atlassian.net/browse/ACT-2089
   */
  public void testDueDateSortingWithNulls() {
    Date now = processEngineConfiguration.getClock().getCurrentTime();

    // 4 tasks with a due date
    createTask("task0", new Date(now.getTime() + (4L * 7L * 24L * 60L * 60L * 1000L))); // 4 weeks in future
    createTask("task1", new Date(now.getTime() + (2 * 24L * 60L * 60L * 1000L))); // 2 days in future
    createTask("task2", new Date(now.getTime() + (7L * 24L * 60L * 60L * 1000L))); // 1 week in future
    createTask("task3", new Date(now.getTime() + (24L * 60L * 60L * 1000L))); // 1 day in future

    // 2 tasks without a due date
    createTask("task4", null);
    createTask("task5", null);

    assertEquals(6, taskService.createTaskQuery().count());

    // Sorting on due date asc should put the nulls at the end
    List<Task> tasks = taskService.createTaskQuery().orderByDueDateNullsLast().asc().list();

    for (int i = 0; i < 4; i++) {
      assertNotNull(tasks.get(i).getDueDate());
    }

    assertEquals("task3", tasks.get(0).getName());
    assertEquals("task1", tasks.get(1).getName());
    assertEquals("task2", tasks.get(2).getName());
    assertEquals("task0", tasks.get(3).getName());
    assertNull(tasks.get(4).getDueDate());
    assertNull(tasks.get(5).getDueDate());

    // The same, but now desc
    tasks = taskService.createTaskQuery().orderByDueDateNullsLast().desc().list();

    for (int i = 0; i < 4; i++) {
      assertNotNull(tasks.get(i).getDueDate());
    }

    assertEquals("task0", tasks.get(0).getName());
    assertEquals("task2", tasks.get(1).getName());
    assertEquals("task1", tasks.get(2).getName());
    assertEquals("task3", tasks.get(3).getName());
    assertNull(tasks.get(4).getDueDate());
    assertNull(tasks.get(5).getDueDate());

    // The same but now nulls first
    tasks = taskService.createTaskQuery().orderByDueDateNullsFirst().asc().list();

    assertNull(tasks.get(0).getDueDate());
    assertNull(tasks.get(1).getDueDate());
    assertEquals("task3", tasks.get(2).getName());
    assertEquals("task1", tasks.get(3).getName());
    assertEquals("task2", tasks.get(4).getName());
    assertEquals("task0", tasks.get(5).getName());

    // And now desc
    tasks = taskService.createTaskQuery().orderByDueDateNullsFirst().desc().list();

    assertNull(tasks.get(0).getDueDate());
    assertNull(tasks.get(1).getDueDate());
    assertEquals("task0", tasks.get(2).getName());
    assertEquals("task2", tasks.get(3).getName());
    assertEquals("task1", tasks.get(4).getName());
    assertEquals("task3", tasks.get(5).getName());

    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.AUDIT)) {
      // And now the same, but for history!
      List<HistoricTaskInstance> historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsLast().asc().list();

      for (int i = 0; i < 4; i++) {
        assertNotNull(historicTasks.get(i).getDueDate());
      }

      assertEquals("task3", historicTasks.get(0).getName());
      assertEquals("task1", historicTasks.get(1).getName());
      assertEquals("task2", historicTasks.get(2).getName());
      assertEquals("task0", historicTasks.get(3).getName());
      assertNull(historicTasks.get(4).getDueDate());
      assertNull(historicTasks.get(5).getDueDate());

      // The same, but now desc
      historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsLast().desc().list();

      for (int i = 0; i < 4; i++) {
        assertNotNull(historicTasks.get(i).getDueDate());
      }

      assertEquals("task0", historicTasks.get(0).getName());
      assertEquals("task2", historicTasks.get(1).getName());
      assertEquals("task1", historicTasks.get(2).getName());
      assertEquals("task3", historicTasks.get(3).getName());
      assertNull(historicTasks.get(4).getDueDate());
      assertNull(historicTasks.get(5).getDueDate());

      // The same but now nulls first
      historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsFirst().asc().list();

      assertNull(historicTasks.get(0).getDueDate());
      assertNull(historicTasks.get(1).getDueDate());
      assertEquals("task3", historicTasks.get(2).getName());
      assertEquals("task1", historicTasks.get(3).getName());
      assertEquals("task2", historicTasks.get(4).getName());
      assertEquals("task0", historicTasks.get(5).getName());

      // And now desc
      historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsFirst().desc().list();

      assertNull(historicTasks.get(0).getDueDate());
      assertNull(historicTasks.get(1).getDueDate());
      assertEquals("task0", historicTasks.get(2).getName());
      assertEquals("task2", historicTasks.get(3).getName());
      assertEquals("task1", historicTasks.get(4).getName());
      assertEquals("task3", historicTasks.get(5).getName());
    }
  }

  private Task createTask(String name, Date dueDate) {
    Task task = taskService.newTask();
    task.setName(name);
    task.setDueDate(dueDate);
    taskService.saveTask(task);
    return task;
  }

}
!@#$%
20190526_171441,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.task;

import java.util.Date;
import java.util.List;

import org.activiti.engine.history.HistoricTaskInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author Joram Barrez
 */
public class TaskDueDateTest extends PluggableActivitiTestCase {
	
	@Override
	protected void tearDown() throws Exception {
		
		for (Task task : taskService.createTaskQuery().list()) {
			taskService.deleteTask(task.getId(), true);
		}
		
	  super.tearDown();
	}

	 /**
   * See http://jira.codehaus.org/browse/ACT-2089
   */
  public void testDueDateSortingWithNulls() {
  	Date now = processEngineConfiguration.getClock().getCurrentTime();
  	
  	// 4 tasks with a due date
  	createTask("task0", new Date(now.getTime() + (4L * 7L * 24L * 60L * 60L * 1000L))); // 4 weeks in future
  	createTask("task1", new Date(now.getTime() + (2 * 24L * 60L * 60L * 1000L))); // 2 days in future
  	createTask("task2", new Date(now.getTime() + (7L * 24L * 60L * 60L * 1000L))); // 1 week in future
  	createTask("task3", new Date(now.getTime() + (24L * 60L * 60L * 1000L))); // 1 day in future
  	
  	// 2 tasks without a due date
  	createTask("task4", null);
  	createTask("task5", null);
  	
  	assertEquals(6, taskService.createTaskQuery().count());
  	
  	// Sorting on due date asc should put the nulls at the end
  	List<Task> tasks = taskService.createTaskQuery().orderByDueDateNullsLast().asc().list();
  	
  	for (int i=0; i<4; i++) {
  		assertNotNull(tasks.get(i).getDueDate());
  	}
  	
  	assertEquals("task3", tasks.get(0).getName());
  	assertEquals("task1", tasks.get(1).getName());
  	assertEquals("task2", tasks.get(2).getName());
  	assertEquals("task0", tasks.get(3).getName());
  	assertNull(tasks.get(4).getDueDate());
  	assertNull(tasks.get(5).getDueDate());
  	
  	// The same, but now desc
  	tasks = taskService.createTaskQuery().orderByDueDateNullsLast().desc().list();
  	
  	for (int i=0; i<4; i++) {
  		assertNotNull(tasks.get(i).getDueDate());
  	}
  	
  	assertEquals("task0", tasks.get(0).getName());
  	assertEquals("task2", tasks.get(1).getName());
  	assertEquals("task1", tasks.get(2).getName());
  	assertEquals("task3", tasks.get(3).getName());
  	assertNull(tasks.get(4).getDueDate());
  	assertNull(tasks.get(5).getDueDate());
  	
  	// The same but now nulls first
  	tasks = taskService.createTaskQuery().orderByDueDateNullsFirst().asc().list();
   	
   	assertNull(tasks.get(0).getDueDate());
   	assertNull(tasks.get(1).getDueDate());
   	assertEquals("task3", tasks.get(2).getName());
   	assertEquals("task1", tasks.get(3).getName());
   	assertEquals("task2", tasks.get(4).getName());
   	assertEquals("task0", tasks.get(5).getName());
   	
   	// And now desc
   	tasks = taskService.createTaskQuery().orderByDueDateNullsFirst().desc().list();
  	
  	assertNull(tasks.get(0).getDueDate());
  	assertNull(tasks.get(1).getDueDate());
  	assertEquals("task0", tasks.get(2).getName());
  	assertEquals("task2", tasks.get(3).getName());
  	assertEquals("task1", tasks.get(4).getName());
  	assertEquals("task3", tasks.get(5).getName());
  	
  	if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.AUDIT)) {
    	// And now the same, but for history!
    	List<HistoricTaskInstance> historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsLast().asc().list();
    	
    	for (int i=0; i<4; i++) {
    		assertNotNull(historicTasks.get(i).getDueDate());
    	}
    	
    	assertEquals("task3", historicTasks.get(0).getName());
    	assertEquals("task1", historicTasks.get(1).getName());
    	assertEquals("task2", historicTasks.get(2).getName());
    	assertEquals("task0", historicTasks.get(3).getName());
    	assertNull(historicTasks.get(4).getDueDate());
    	assertNull(historicTasks.get(5).getDueDate());
    	
    	// The same, but now desc
    	historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsLast().desc().list();
    	
    	for (int i=0; i<4; i++) {
    		assertNotNull(historicTasks.get(i).getDueDate());
    	}
    	
    	assertEquals("task0", historicTasks.get(0).getName());
    	assertEquals("task2", historicTasks.get(1).getName());
    	assertEquals("task1", historicTasks.get(2).getName());
    	assertEquals("task3", historicTasks.get(3).getName());
    	assertNull(historicTasks.get(4).getDueDate());
    	assertNull(historicTasks.get(5).getDueDate());
    	
    	// The same but now nulls first
    	historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsFirst().asc().list();
     	
     	assertNull(historicTasks.get(0).getDueDate());
     	assertNull(historicTasks.get(1).getDueDate());
     	assertEquals("task3", historicTasks.get(2).getName());
     	assertEquals("task1", historicTasks.get(3).getName());
     	assertEquals("task2", historicTasks.get(4).getName());
     	assertEquals("task0", historicTasks.get(5).getName());
     	
     	// And now desc
     	historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsFirst().desc().list();
    	
    	assertNull(historicTasks.get(0).getDueDate());
    	assertNull(historicTasks.get(1).getDueDate());
    	assertEquals("task0", historicTasks.get(2).getName());
    	assertEquals("task2", historicTasks.get(3).getName());
    	assertEquals("task1", historicTasks.get(4).getName());
    	assertEquals("task3", historicTasks.get(5).getName());
  	}
  }
  
  private Task createTask(String name, Date dueDate) {
  	Task task = taskService.newTask();
  	task.setName(name);
  	task.setDueDate(dueDate);
  	taskService.saveTask(task);
  	return task;
  }

}
!@#$%
20190526_171441,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.task;

import java.util.Date;
import java.util.List;

import org.activiti.engine.history.HistoricTaskInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.task.Task;

/**
 * @author Joram Barrez
 */
public class TaskDueDateTest extends PluggableActivitiTestCase {
	
	@Override
	protected void tearDown() throws Exception {
		
		for (Task task : taskService.createTaskQuery().list()) {
			taskService.deleteTask(task.getId(), true);
		}
		
	  super.tearDown();
	}

	 /**
   * See https://activiti.atlassian.net/browse/ACT-2089
   */
  public void testDueDateSortingWithNulls() {
  	Date now = processEngineConfiguration.getClock().getCurrentTime();
  	
  	// 4 tasks with a due date
  	createTask("task0", new Date(now.getTime() + (4L * 7L * 24L * 60L * 60L * 1000L))); // 4 weeks in future
  	createTask("task1", new Date(now.getTime() + (2 * 24L * 60L * 60L * 1000L))); // 2 days in future
  	createTask("task2", new Date(now.getTime() + (7L * 24L * 60L * 60L * 1000L))); // 1 week in future
  	createTask("task3", new Date(now.getTime() + (24L * 60L * 60L * 1000L))); // 1 day in future
  	
  	// 2 tasks without a due date
  	createTask("task4", null);
  	createTask("task5", null);
  	
  	assertEquals(6, taskService.createTaskQuery().count());
  	
  	// Sorting on due date asc should put the nulls at the end
  	List<Task> tasks = taskService.createTaskQuery().orderByDueDateNullsLast().asc().list();
  	
  	for (int i=0; i<4; i++) {
  		assertNotNull(tasks.get(i).getDueDate());
  	}
  	
  	assertEquals("task3", tasks.get(0).getName());
  	assertEquals("task1", tasks.get(1).getName());
  	assertEquals("task2", tasks.get(2).getName());
  	assertEquals("task0", tasks.get(3).getName());
  	assertNull(tasks.get(4).getDueDate());
  	assertNull(tasks.get(5).getDueDate());
  	
  	// The same, but now desc
  	tasks = taskService.createTaskQuery().orderByDueDateNullsLast().desc().list();
  	
  	for (int i=0; i<4; i++) {
  		assertNotNull(tasks.get(i).getDueDate());
  	}
  	
  	assertEquals("task0", tasks.get(0).getName());
  	assertEquals("task2", tasks.get(1).getName());
  	assertEquals("task1", tasks.get(2).getName());
  	assertEquals("task3", tasks.get(3).getName());
  	assertNull(tasks.get(4).getDueDate());
  	assertNull(tasks.get(5).getDueDate());
  	
  	// The same but now nulls first
  	tasks = taskService.createTaskQuery().orderByDueDateNullsFirst().asc().list();
   	
   	assertNull(tasks.get(0).getDueDate());
   	assertNull(tasks.get(1).getDueDate());
   	assertEquals("task3", tasks.get(2).getName());
   	assertEquals("task1", tasks.get(3).getName());
   	assertEquals("task2", tasks.get(4).getName());
   	assertEquals("task0", tasks.get(5).getName());
   	
   	// And now desc
   	tasks = taskService.createTaskQuery().orderByDueDateNullsFirst().desc().list();
  	
  	assertNull(tasks.get(0).getDueDate());
  	assertNull(tasks.get(1).getDueDate());
  	assertEquals("task0", tasks.get(2).getName());
  	assertEquals("task2", tasks.get(3).getName());
  	assertEquals("task1", tasks.get(4).getName());
  	assertEquals("task3", tasks.get(5).getName());
  	
  	if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.AUDIT)) {
    	// And now the same, but for history!
    	List<HistoricTaskInstance> historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsLast().asc().list();
    	
    	for (int i=0; i<4; i++) {
    		assertNotNull(historicTasks.get(i).getDueDate());
    	}
    	
    	assertEquals("task3", historicTasks.get(0).getName());
    	assertEquals("task1", historicTasks.get(1).getName());
    	assertEquals("task2", historicTasks.get(2).getName());
    	assertEquals("task0", historicTasks.get(3).getName());
    	assertNull(historicTasks.get(4).getDueDate());
    	assertNull(historicTasks.get(5).getDueDate());
    	
    	// The same, but now desc
    	historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsLast().desc().list();
    	
    	for (int i=0; i<4; i++) {
    		assertNotNull(historicTasks.get(i).getDueDate());
    	}
    	
    	assertEquals("task0", historicTasks.get(0).getName());
    	assertEquals("task2", historicTasks.get(1).getName());
    	assertEquals("task1", historicTasks.get(2).getName());
    	assertEquals("task3", historicTasks.get(3).getName());
    	assertNull(historicTasks.get(4).getDueDate());
    	assertNull(historicTasks.get(5).getDueDate());
    	
    	// The same but now nulls first
    	historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsFirst().asc().list();
     	
     	assertNull(historicTasks.get(0).getDueDate());
     	assertNull(historicTasks.get(1).getDueDate());
     	assertEquals("task3", historicTasks.get(2).getName());
     	assertEquals("task1", historicTasks.get(3).getName());
     	assertEquals("task2", historicTasks.get(4).getName());
     	assertEquals("task0", historicTasks.get(5).getName());
     	
     	// And now desc
     	historicTasks = historyService.createHistoricTaskInstanceQuery().orderByDueDateNullsFirst().desc().list();
    	
    	assertNull(historicTasks.get(0).getDueDate());
    	assertNull(historicTasks.get(1).getDueDate());
    	assertEquals("task0", historicTasks.get(2).getName());
    	assertEquals("task2", historicTasks.get(3).getName());
    	assertEquals("task1", historicTasks.get(4).getName());
    	assertEquals("task3", historicTasks.get(5).getName());
  	}
  }
  
  private Task createTask(String name, Date dueDate) {
  	Task task = taskService.newTask();
  	task.setName(name);
  	task.setDueDate(dueDate);
  	taskService.saveTask(task);
  	return task;
  }

}
!@#$%
20190526_171456,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.api.repository;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.ActivitiIllegalArgumentException;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.repository.ProcessDefinitionQuery;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * @author Joram Barrez
 */
public class ProcessDefinitionQueryTest extends PluggableActivitiTestCase {

  private String deploymentOneId;
  private String deploymentTwoId;

  @Override
  protected void setUp() throws Exception {
    deploymentOneId = repositoryService.createDeployment().name("org/activiti/engine/test/repository/one.bpmn20.xml").addClasspathResource("org/activiti/engine/test/repository/one.bpmn20.xml")
        .addClasspathResource("org/activiti/engine/test/repository/two.bpmn20.xml").deploy().getId();

    deploymentTwoId = repositoryService.createDeployment().name("org/activiti/engine/test/repository/one.bpmn20.xml").addClasspathResource("org/activiti/engine/test/repository/one.bpmn20.xml")
        .deploy().getId();

    super.setUp();
  }

  @Override
  protected void tearDown() throws Exception {
    super.tearDown();
    repositoryService.deleteDeployment(deploymentOneId, true);
    repositoryService.deleteDeployment(deploymentTwoId, true);
  }

  public void testProcessDefinitionProperties() {
    List<ProcessDefinition> processDefinitions = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionName().asc().orderByProcessDefinitionVersion().asc()
        .orderByProcessDefinitionCategory().asc().list();

    ProcessDefinition processDefinition = processDefinitions.get(0);
    assertEquals("one", processDefinition.getKey());
    assertEquals("One", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("one:1"));
    assertEquals("Examples", processDefinition.getCategory());

    processDefinition = processDefinitions.get(1);
    assertEquals("one", processDefinition.getKey());
    assertEquals("One", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("one:2"));
    assertEquals("Examples", processDefinition.getCategory());

    processDefinition = processDefinitions.get(2);
    assertEquals("two", processDefinition.getKey());
    assertEquals("Two", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("two:1"));
    assertEquals("Examples2", processDefinition.getCategory());
  }

  public void testQueryByDeploymentId() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().deploymentId(deploymentOneId);
    verifyQueryResults(query, 2);
  }

  public void testQueryByInvalidDeploymentId() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().deploymentId("invalid");
    verifyQueryResults(query, 0);

    try {
      repositoryService.createProcessDefinitionQuery().deploymentId(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {
    }
  }

  public void testQueryByName() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionName("Two");
    verifyQueryResults(query, 1);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionName("One");
    verifyQueryResults(query, 2);
  }

  public void testQueryByInvalidName() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionName("invalid");
    verifyQueryResults(query, 0);

    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionName(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {
    }
  }

  public void testQueryByNameLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("%w%");
    verifyQueryResults(query, 1);
  }

  public void testQueryByInvalidNameLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("%invalid%");
    verifyQueryResults(query, 0);
  }

  public void testQueryByKey() {
    // process one
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one");
    verifyQueryResults(query, 2);

    // process two
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("two");
    verifyQueryResults(query, 1);
  }

  public void testQueryByInvalidKey() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("invalid");
    verifyQueryResults(query, 0);

    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionKey(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {
    }
  }

  public void testQueryByKeyLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike("%o%");
    verifyQueryResults(query, 3);
  }

  public void testQueryByInvalidKeyLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike("%invalid%");
    verifyQueryResults(query, 0);

    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {
    }
  }

  public void testQueryByCategory() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionCategory("Examples");
    verifyQueryResults(query, 2);
  }

  public void testQueryByCategoryLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionCategoryLike("%Example%");
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionCategoryLike("%amples2");
    verifyQueryResults(query, 1);
  }

  public void testQueryByVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(2);
    verifyQueryResults(query, 1);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(1);
    verifyQueryResults(query, 2);
  }

  public void testQueryByInvalidVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(3);
    verifyQueryResults(query, 0);

    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(-1).list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {
    }

    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(null).list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {
    }
  }

  public void testQueryByKeyAndVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(1);
    verifyQueryResults(query, 1);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(2);
    verifyQueryResults(query, 1);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(3);
    verifyQueryResults(query, 0);
  }

  public void testQueryByLatest() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().latestVersion();
    verifyQueryResults(query, 2);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").latestVersion();
    verifyQueryResults(query, 1);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("two").latestVersion();
    verifyQueryResults(query, 1);
  }

  public void testQuerySorting() {

    // asc

    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionId().asc();
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().orderByDeploymentId().asc();
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().asc();
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().asc();
    verifyQueryResults(query, 3);

    // desc

    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionId().desc();
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().orderByDeploymentId().desc();
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().desc();
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().desc();
    verifyQueryResults(query, 3);

    // Typical use case
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().asc().orderByProcessDefinitionVersion().desc();
    List<ProcessDefinition> processDefinitions = query.list();
    assertEquals(3, processDefinitions.size());

    assertEquals("one", processDefinitions.get(0).getKey());
    assertEquals(2, processDefinitions.get(0).getVersion());
    assertEquals("one", processDefinitions.get(1).getKey());
    assertEquals(1, processDefinitions.get(1).getVersion());
    assertEquals("two", processDefinitions.get(2).getKey());
    assertEquals(1, processDefinitions.get(2).getVersion());
  }

  private void verifyQueryResults(ProcessDefinitionQuery query, int countExpected) {
    assertEquals(countExpected, query.list().size());
    assertEquals(countExpected, query.count());

    if (countExpected == 1) {
      assertNotNull(query.singleResult());
    } else if (countExpected > 1) {
      verifySingleResultFails(query);
    } else if (countExpected == 0) {
      assertNull(query.singleResult());
    }
  }

  private void verifySingleResultFails(ProcessDefinitionQuery query) {
    try {
      query.singleResult();
      fail();
    } catch (ActivitiException e) {
    }
  }

  public void testQueryByMessageSubscription() {
    Deployment deployment = repositoryService.createDeployment().addClasspathResource("org/activiti/engine/test/api/repository/processWithNewBookingMessage.bpmn20.xml")
        .addClasspathResource("org/activiti/engine/test/api/repository/processWithNewInvoiceMessage.bpmn20.xml").deploy();

    assertEquals(1, repositoryService.createProcessDefinitionQuery().messageEventSubscriptionName("newInvoiceMessage").count());

    assertEquals(1, repositoryService.createProcessDefinitionQuery().messageEventSubscriptionName("newBookingMessage").count());

    assertEquals(0, repositoryService.createProcessDefinitionQuery().messageEventSubscriptionName("bogus").count());

    repositoryService.deleteDeployment(deployment.getId());
  }

  public void testNativeQuery() {
    assertEquals("ACT_RE_PROCDEF", managementService.getTableName(ProcessDefinition.class));
    assertEquals("ACT_RE_PROCDEF", managementService.getTableName(ProcessDefinitionEntity.class));
    String tableName = managementService.getTableName(ProcessDefinition.class);
    String baseQuerySql = "SELECT * FROM " + tableName;

    assertEquals(3, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).list().size());

    assertEquals(3, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql + " where KEY_ like #{key}").parameter("key", "%o%").list().size());

    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql + " where NAME_ = #{name}").parameter("name", "One").list().size());

    // paging
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).listPage(0, 2).size());
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).listPage(1, 3).size());
  }
  
  public void testQueryByProcessDefinitionIds() {
  	List<ProcessDefinition> processDefinitions = repositoryService.createProcessDefinitionQuery().list();
  	Set<String> ids = new HashSet<String>();
  	for (ProcessDefinition processDefinition : processDefinitions) {
  		ids.add(processDefinition.getId());
  	}
  	
  	List<ProcessDefinition> queryResults = repositoryService.createProcessDefinitionQuery().processDefinitionIds(ids).list();
  	assertEquals(queryResults.size(), ids.size());
  	for (ProcessDefinition processDefinition : queryResults) {
  		assertTrue(ids.contains(processDefinition.getId()));
  	}
  }
  
}
!@#$%
20190526_171456,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.api.repository;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.ActivitiIllegalArgumentException;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.repository.ProcessDefinitionQuery;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


/**
 * @author Joram Barrez
 */
public class ProcessDefinitionQueryTest extends PluggableActivitiTestCase {
  
  private String deploymentOneId;
  private String deploymentTwoId;
  
  @Override
  protected void setUp() throws Exception {
    deploymentOneId = repositoryService
      .createDeployment()
      .name("org/activiti/engine/test/repository/one.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/repository/one.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/repository/two.bpmn20.xml")
      .deploy()
      .getId();

    deploymentTwoId = repositoryService
      .createDeployment()
      .name("org/activiti/engine/test/repository/one.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/repository/one.bpmn20.xml")
      .deploy()
      .getId();
    
    super.setUp();
  }
  
  @Override
  protected void tearDown() throws Exception {
    super.tearDown();
    repositoryService.deleteDeployment(deploymentOneId, true);
    repositoryService.deleteDeployment(deploymentTwoId, true);
  }
  
  public void testProcessDefinitionProperties() {
    List<ProcessDefinition> processDefinitions = repositoryService
      .createProcessDefinitionQuery()
      .orderByProcessDefinitionName().asc()
      .orderByProcessDefinitionVersion().asc()
      .orderByProcessDefinitionCategory().asc()
      .list();
    
    ProcessDefinition processDefinition = processDefinitions.get(0);
    assertEquals("one", processDefinition.getKey());
    assertEquals("One", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("one:1"));
    assertEquals("Examples", processDefinition.getCategory());

    processDefinition = processDefinitions.get(1);
    assertEquals("one", processDefinition.getKey());
    assertEquals("One", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("one:2"));
    assertEquals("Examples", processDefinition.getCategory());

    processDefinition = processDefinitions.get(2);
    assertEquals("two", processDefinition.getKey());
    assertEquals("Two", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("two:1"));
    assertEquals("Examples2", processDefinition.getCategory());
  }
  
  public void testQueryByDeploymentId() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().deploymentId(deploymentOneId);
    verifyQueryResults(query, 2);
  }
  
  public void testQueryByInvalidDeploymentId() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().deploymentId("invalid");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().deploymentId(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByName() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionName("Two");
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionName("One");
    verifyQueryResults(query, 2);
  }
  
  public void testQueryByInvalidName() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionName("invalid");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionName(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByNameLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("%w%");
    verifyQueryResults(query, 1);
  }
  
  public void testQueryByInvalidNameLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("%invalid%");
    verifyQueryResults(query, 0);
  }
  
  public void testQueryByKey() {
    // process one    
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one");
    verifyQueryResults(query, 2);
    
    // process two
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("two");
    verifyQueryResults(query, 1);
  }
  
  public void testQueryByInvalidKey() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("invalid");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionKey(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByKeyLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike("%o%");
    verifyQueryResults(query, 3);
  }
  
  public void testQueryByInvalidKeyLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike("%invalid%");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }

  public void testQueryByCategory() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionCategory("Examples");
    verifyQueryResults(query, 2);
  }

  public void testQueryByCategoryLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionCategoryLike("%Example%");
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionCategoryLike("%amples2");
    verifyQueryResults(query, 1);
  } 

  public void testQueryByVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(2);
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(1);
    verifyQueryResults(query, 2);
  }
  
  public void testQueryByInvalidVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(3);
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(-1).list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(null).list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByKeyAndVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(1);
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(2);
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(3);
    verifyQueryResults(query, 0);
  }
  
  public void testQueryByLatest() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().latestVersion();
    verifyQueryResults(query, 2);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").latestVersion();
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("two").latestVersion();
    verifyQueryResults(query, 1);
  }
  
  public void testInvalidUsageOfLatest() {
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionId("test").latestVersion().list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionName("test").latestVersion().list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("test").latestVersion().list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(1).latestVersion().list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
    
    try {
      repositoryService.createProcessDefinitionQuery().deploymentId("test").latestVersion().list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQuerySorting() {
    
    // asc 
    
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionId().asc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByDeploymentId().asc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().asc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().asc();
    verifyQueryResults(query, 3);
    
    // desc
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionId().desc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByDeploymentId().desc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().desc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().desc();
    verifyQueryResults(query, 3);
    
    // Typical use case
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().asc().orderByProcessDefinitionVersion().desc();
    List<ProcessDefinition> processDefinitions = query.list();
    assertEquals(3, processDefinitions.size());
    
    assertEquals("one", processDefinitions.get(0).getKey());
    assertEquals(2, processDefinitions.get(0).getVersion());
    assertEquals("one", processDefinitions.get(1).getKey());
    assertEquals(1, processDefinitions.get(1).getVersion());
    assertEquals("two", processDefinitions.get(2).getKey());
    assertEquals(1, processDefinitions.get(2).getVersion());
  }
  
  private void verifyQueryResults(ProcessDefinitionQuery query, int countExpected) {
    assertEquals(countExpected, query.list().size());
    assertEquals(countExpected, query.count());
    
    if (countExpected == 1) {
      assertNotNull(query.singleResult());
    } else if (countExpected > 1){
      verifySingleResultFails(query);
    } else if (countExpected == 0) {
      assertNull(query.singleResult());
    }
  }
  
  private void verifySingleResultFails(ProcessDefinitionQuery query) {
    try {
      query.singleResult();
      fail();
    } catch (ActivitiException e) {}
  }
  
  public void testQueryByMessageSubscription() {
    Deployment deployment = repositoryService.createDeployment()
      .addClasspathResource("org/activiti/engine/test/api/repository/processWithNewBookingMessage.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/api/repository/processWithNewInvoiceMessage.bpmn20.xml")
    .deploy();
    
    assertEquals(1,repositoryService.createProcessDefinitionQuery()
      .messageEventSubscriptionName("newInvoiceMessage")
      .count());
    
    assertEquals(1,repositoryService.createProcessDefinitionQuery()
      .messageEventSubscriptionName("newBookingMessage")
      .count());
    
    assertEquals(0,repositoryService.createProcessDefinitionQuery()
      .messageEventSubscriptionName("bogus")
      .count());
    
    repositoryService.deleteDeployment(deployment.getId());
  }

  public void testNativeQuery() {
    assertEquals("ACT_RE_PROCDEF", managementService.getTableName(ProcessDefinition.class));
    assertEquals("ACT_RE_PROCDEF", managementService.getTableName(ProcessDefinitionEntity.class));
    String tableName = managementService.getTableName(ProcessDefinition.class);
    String baseQuerySql = "SELECT * FROM " + tableName;

    assertEquals(3, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).list().size());

    assertEquals(3, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql + " where KEY_ like #{key}")
        .parameter("key", "%o%").list().size());
    
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql + " where NAME_ = #{name}")
        .parameter("name", "One").list().size());

    // paging
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).listPage(0, 2).size());
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).listPage(1, 3).size());
  }
  
  public void testQueryByProcessDefinitionIds() {
  	List<ProcessDefinition> processDefinitions = repositoryService.createProcessDefinitionQuery().list();
  	Set<String> ids = new HashSet<String>();
  	for (ProcessDefinition processDefinition : processDefinitions) {
  		ids.add(processDefinition.getId());
  	}
  	
  	List<ProcessDefinition> queryResults = repositoryService.createProcessDefinitionQuery().processDefinitionIds(ids).list();
  	assertEquals(queryResults.size(), ids.size());
  	for (ProcessDefinition processDefinition : queryResults) {
  		assertTrue(ids.contains(processDefinition.getId()));
  	}
  }
  
}
!@#$%
20190526_171456,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.test.api.repository;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.ActivitiIllegalArgumentException;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.repository.ProcessDefinitionQuery;

import java.util.HashSet;
import java.util.List;
import java.util.Set;


/**
 * @author Joram Barrez
 */
public class ProcessDefinitionQueryTest extends PluggableActivitiTestCase {
  
  private String deploymentOneId;
  private String deploymentTwoId;
  
  @Override
  protected void setUp() throws Exception {
    deploymentOneId = repositoryService
      .createDeployment()
      .name("org/activiti/engine/test/repository/one.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/repository/one.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/repository/two.bpmn20.xml")
      .deploy()
      .getId();

    deploymentTwoId = repositoryService
      .createDeployment()
      .name("org/activiti/engine/test/repository/one.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/repository/one.bpmn20.xml")
      .deploy()
      .getId();
    
    super.setUp();
  }
  
  @Override
  protected void tearDown() throws Exception {
    super.tearDown();
    repositoryService.deleteDeployment(deploymentOneId, true);
    repositoryService.deleteDeployment(deploymentTwoId, true);
  }
  
  public void testProcessDefinitionProperties() {
    List<ProcessDefinition> processDefinitions = repositoryService
      .createProcessDefinitionQuery()
      .orderByProcessDefinitionName().asc()
      .orderByProcessDefinitionVersion().asc()
      .orderByProcessDefinitionCategory().asc()
      .list();
    
    ProcessDefinition processDefinition = processDefinitions.get(0);
    assertEquals("one", processDefinition.getKey());
    assertEquals("One", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("one:1"));
    assertEquals("Examples", processDefinition.getCategory());

    processDefinition = processDefinitions.get(1);
    assertEquals("one", processDefinition.getKey());
    assertEquals("One", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("one:2"));
    assertEquals("Examples", processDefinition.getCategory());

    processDefinition = processDefinitions.get(2);
    assertEquals("two", processDefinition.getKey());
    assertEquals("Two", processDefinition.getName());
    assertTrue(processDefinition.getId().startsWith("two:1"));
    assertEquals("Examples2", processDefinition.getCategory());
  }
  
  public void testQueryByDeploymentId() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().deploymentId(deploymentOneId);
    verifyQueryResults(query, 2);
  }
  
  public void testQueryByInvalidDeploymentId() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().deploymentId("invalid");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().deploymentId(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByName() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionName("Two");
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionName("One");
    verifyQueryResults(query, 2);
  }
  
  public void testQueryByInvalidName() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionName("invalid");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionName(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByNameLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("%w%");
    verifyQueryResults(query, 1);
  }
  
  public void testQueryByInvalidNameLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionNameLike("%invalid%");
    verifyQueryResults(query, 0);
  }
  
  public void testQueryByKey() {
    // process one    
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one");
    verifyQueryResults(query, 2);
    
    // process two
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("two");
    verifyQueryResults(query, 1);
  }
  
  public void testQueryByInvalidKey() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("invalid");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionKey(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByKeyLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike("%o%");
    verifyQueryResults(query, 3);
  }
  
  public void testQueryByInvalidKeyLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike("%invalid%");
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionKeyLike(null);
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }

  public void testQueryByCategory() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionCategory("Examples");
    verifyQueryResults(query, 2);
  }

  public void testQueryByCategoryLike() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionCategoryLike("%Example%");
    verifyQueryResults(query, 3);

    query = repositoryService.createProcessDefinitionQuery().processDefinitionCategoryLike("%amples2");
    verifyQueryResults(query, 1);
  } 

  public void testQueryByVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(2);
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(1);
    verifyQueryResults(query, 2);
  }
  
  public void testQueryByInvalidVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionVersion(3);
    verifyQueryResults(query, 0);
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(-1).list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
    
    try {
      repositoryService.createProcessDefinitionQuery().processDefinitionVersion(null).list();
      fail();
    } catch (ActivitiIllegalArgumentException e) {}
  }
  
  public void testQueryByKeyAndVersion() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(1);
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(2);
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").processDefinitionVersion(3);
    verifyQueryResults(query, 0);
  }
  
  public void testQueryByLatest() {
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().latestVersion();
    verifyQueryResults(query, 2);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("one").latestVersion();
    verifyQueryResults(query, 1);
    
    query = repositoryService.createProcessDefinitionQuery().processDefinitionKey("two").latestVersion();
    verifyQueryResults(query, 1);
  }
  
  public void testQuerySorting() {
    
    // asc 
    
    ProcessDefinitionQuery query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionId().asc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByDeploymentId().asc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().asc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().asc();
    verifyQueryResults(query, 3);
    
    // desc
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionId().desc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByDeploymentId().desc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().desc();
    verifyQueryResults(query, 3);
    
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionVersion().desc();
    verifyQueryResults(query, 3);
    
    // Typical use case
    query = repositoryService.createProcessDefinitionQuery().orderByProcessDefinitionKey().asc().orderByProcessDefinitionVersion().desc();
    List<ProcessDefinition> processDefinitions = query.list();
    assertEquals(3, processDefinitions.size());
    
    assertEquals("one", processDefinitions.get(0).getKey());
    assertEquals(2, processDefinitions.get(0).getVersion());
    assertEquals("one", processDefinitions.get(1).getKey());
    assertEquals(1, processDefinitions.get(1).getVersion());
    assertEquals("two", processDefinitions.get(2).getKey());
    assertEquals(1, processDefinitions.get(2).getVersion());
  }
  
  private void verifyQueryResults(ProcessDefinitionQuery query, int countExpected) {
    assertEquals(countExpected, query.list().size());
    assertEquals(countExpected, query.count());
    
    if (countExpected == 1) {
      assertNotNull(query.singleResult());
    } else if (countExpected > 1){
      verifySingleResultFails(query);
    } else if (countExpected == 0) {
      assertNull(query.singleResult());
    }
  }
  
  private void verifySingleResultFails(ProcessDefinitionQuery query) {
    try {
      query.singleResult();
      fail();
    } catch (ActivitiException e) {}
  }
  
  public void testQueryByMessageSubscription() {
    Deployment deployment = repositoryService.createDeployment()
      .addClasspathResource("org/activiti/engine/test/api/repository/processWithNewBookingMessage.bpmn20.xml")
      .addClasspathResource("org/activiti/engine/test/api/repository/processWithNewInvoiceMessage.bpmn20.xml")
    .deploy();
    
    assertEquals(1,repositoryService.createProcessDefinitionQuery()
      .messageEventSubscriptionName("newInvoiceMessage")
      .count());
    
    assertEquals(1,repositoryService.createProcessDefinitionQuery()
      .messageEventSubscriptionName("newBookingMessage")
      .count());
    
    assertEquals(0,repositoryService.createProcessDefinitionQuery()
      .messageEventSubscriptionName("bogus")
      .count());
    
    repositoryService.deleteDeployment(deployment.getId());
  }

  public void testNativeQuery() {
    assertEquals("ACT_RE_PROCDEF", managementService.getTableName(ProcessDefinition.class));
    assertEquals("ACT_RE_PROCDEF", managementService.getTableName(ProcessDefinitionEntity.class));
    String tableName = managementService.getTableName(ProcessDefinition.class);
    String baseQuerySql = "SELECT * FROM " + tableName;

    assertEquals(3, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).list().size());

    assertEquals(3, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql + " where KEY_ like #{key}")
        .parameter("key", "%o%").list().size());
    
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql + " where NAME_ = #{name}")
        .parameter("name", "One").list().size());

    // paging
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).listPage(0, 2).size());
    assertEquals(2, repositoryService.createNativeProcessDefinitionQuery().sql(baseQuerySql).listPage(1, 3).size());
  }
  
  public void testQueryByProcessDefinitionIds() {
  	List<ProcessDefinition> processDefinitions = repositoryService.createProcessDefinitionQuery().list();
  	Set<String> ids = new HashSet<String>();
  	for (ProcessDefinition processDefinition : processDefinitions) {
  		ids.add(processDefinition.getId());
  	}
  	
  	List<ProcessDefinition> queryResults = repositoryService.createProcessDefinitionQuery().processDefinitionIds(ids).list();
  	assertEquals(queryResults.size(), ids.size());
  	for (ProcessDefinition processDefinition : queryResults) {
  		assertTrue(ids.contains(processDefinition.getId()));
  	}
  }
  
}
!@#$%
20190526_171507,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.event.EventLogEntry;
import org.activiti.engine.impl.persistence.entity.EventLogEntryEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

/**
 * Test variables delete events with storing events {@link EventLogEntryEntity}.
 * 
 * @author Bassam Al-Sarori
 */
public class VariableEventsStoreTest extends PluggableActivitiTestCase {

  private TestVariableEventListenerStore listener;

  @Deployment(resources = {"org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml"})
  public void testStartEndProcessInstanceVariableEvents() throws Exception {
    Map<String, Object> variables = new HashMap<String, Object>();
    variables.put("var1", "value1");
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess", variables);

    assertEquals(1, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_CREATED, listener.getEventsReceived().get(0).getType());
    assertEquals(1, managementService.getEventLogEntries(null, null).size());

    Task task = taskService.createTaskQuery().processInstanceId( processInstance.getId()).singleResult();
    taskService.complete(task.getId());

    assertEquals(2, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_DELETED, listener.getEventsReceived().get(1).getType());
    assertEquals(2, managementService.getEventLogEntries(null, null).size());

  }

  public void testTaskInstanceVariableEvents() throws Exception {
    Task task = taskService.newTask();
    taskService.saveTask(task);

    taskService.setVariableLocal(task.getId(), "myVar", "value");

    assertEquals(1, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_CREATED, listener.getEventsReceived().get(0).getType());
    assertEquals(1, managementService.getEventLogEntries(null, null).size());

    taskService.removeVariableLocal(task.getId(), "myVar");

    assertEquals(2, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_DELETED, listener.getEventsReceived().get(1).getType());
    assertEquals(2, managementService.getEventLogEntries(null, null).size());

    // bulk insert delete var test
    Map<String, String> vars = new HashMap<String, String>();
    vars.put("myVar", "value");
    vars.put("myVar2", "value");
    taskService.setVariablesLocal(task.getId(), vars);
    taskService.removeVariablesLocal(task.getId(), Arrays.asList("myVar", "myVar2"));

    assertEquals(6, listener.getEventsReceived().size());
    assertEquals(6, managementService.getEventLogEntries(null, null).size());

    taskService.complete(task.getId());
    historyService.deleteHistoricTaskInstance(task.getId());

  }

  @Override
  protected void initializeServices() {
    super.initializeServices();

    listener = new TestVariableEventListenerStore();
    processEngineConfiguration.getEventDispatcher().addEventListener(listener);
  }

  @Override
  protected void tearDown() throws Exception {
    super.tearDown();

    if (listener != null) {
      listener.clearEventsReceived();
      processEngineConfiguration.getEventDispatcher().removeEventListener(listener);

      // cleanup
      for (EventLogEntry eventLogEntry : managementService.getEventLogEntries(null, null)) {
        managementService.deleteEventLogEntry(eventLogEntry.getLogNumber());
      }
    }
  }
}
!@#$%
20190526_171507,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.event.EventLogEntry;
import org.activiti.engine.impl.persistence.entity.EventLogEntryEntity;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

/**
 * Test variables delete events with storing events {@link EventLogEntryEntity}.
 * 
 * @author Bassam Al-Sarori
 */
public class VariableEventsStoreTest extends PluggableActivitiTestCase {

  private TestVariableEventListenerStore listener;

  @Deployment(resources = {"org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml"})
  public void testStartEndProcessInstanceVariableEvents() throws Exception {
    Map<String, Object> variables = new HashMap<String, Object>();
    variables.put("var1", "value1");
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess", variables);

    assertEquals(1, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_CREATED, listener.getEventsReceived().get(0).getType());
    assertEquals(1, managementService.getEventLogEntries(null, null).size());

    Task task = taskService.createTaskQuery().processInstanceId( processInstance.getId()).singleResult();
    taskService.complete(task.getId());

    assertEquals(2, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_DELETED, listener.getEventsReceived().get(1).getType());
    assertEquals(2, managementService.getEventLogEntries(null, null).size());

  }


  public void testTaskInstanceVariableEvents() throws Exception {
    Task task = taskService.newTask();
    taskService.saveTask(task);

    taskService.setVariableLocal(task.getId(), "myVar", "value");

    assertEquals(1, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_CREATED, listener.getEventsReceived().get(0).getType());
    assertEquals(1, managementService.getEventLogEntries(null, null).size());

    taskService.removeVariableLocal(task.getId(), "myVar");

    assertEquals(2, listener.getEventsReceived().size());
    assertEquals(ActivitiEventType.VARIABLE_DELETED, listener.getEventsReceived().get(1).getType());
    assertEquals(2, managementService.getEventLogEntries(null, null).size());

    // bulk insert delete var test
    Map<String, String> vars = new HashMap<String, String>();
    vars.put("myVar", "value");
    vars.put("myVar2", "value");
    taskService.setVariablesLocal(task.getId(), vars);
    taskService.removeVariablesLocal(task.getId(), Arrays.asList("myVar", "myVar2"));

    assertEquals(6, listener.getEventsReceived().size());
    assertEquals(6, managementService.getEventLogEntries(null, null).size());

    taskService.complete(task.getId());
    historyService.deleteHistoricTaskInstance(task.getId());

  }

  @Override
  protected void initializeServices() {
    super.initializeServices();

    listener = new TestVariableEventListenerStore();
    processEngineConfiguration.getEventDispatcher().addEventListener(listener);
  }

  @Override
  protected void tearDown() throws Exception {
    super.tearDown();

    if (listener != null) {
      listener.clearEventsReceived();
      processEngineConfiguration.getEventDispatcher().removeEventListener(listener);

      // cleanup
      for (EventLogEntry eventLogEntry : managementService.getEventLogEntries(null, null)) {
        managementService.deleteEventLogEntry(eventLogEntry.getLogNumber());
      }
    }
  }
}
!@#$%
20190526_171514,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.util.List;

import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.history.HistoricActivityInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.test.Deployment;

/**
 * Test case for all {@link ActivitiEvent}s related to activities.
 * 
 * @author Frederik Heremans
 * @author Joram Barrez
 */
public class HistoricActivityEventsTest extends PluggableActivitiTestCase {

  private TestHistoricActivityEventListener listener;

  @Override
  protected void setUp() throws Exception {
    super.setUp();

    this.listener = new TestHistoricActivityEventListener();
    processEngineConfiguration.getEventDispatcher().addEventListener(listener);
  }

  @Override
  protected void tearDown() throws Exception {

    if (listener != null) {
      listener.clearEventsReceived();
      processEngineConfiguration.getEventDispatcher().removeEventListener(listener);
    }

    super.tearDown();
  }

  /**
   * Test added to assert the historic activity instance event
   */
  @Deployment
  public void testHistoricActivityEventDispatched() {
    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {

      ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("TestActivityEvents");
      assertNotNull(processInstance);

      for (int i = 0; i < 2; i++) {
        taskService.complete(taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult().getId());
      }

      List<ActivitiEvent> events = listener.getEventsReceived();

      // Process instance start
      assertEquals(ActivitiEventType.HISTORIC_PROCESS_INSTANCE_CREATED, events.get(0).getType());

      // main start
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(1).getType());
      assertEquals("mainStart", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(1)).getEntity()).getActivityId()));

      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(2).getType());
      assertEquals("mainStart", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(2)).getEntity()).getActivityId()));
      assertNotNull("mainStart", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(2)).getEntity()).getEndTime()));

      // Subprocess start
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(3).getType());
      assertEquals("subProcess", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(3)).getEntity()).getActivityId()));

      // subProcessStart
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(4).getType());
      assertEquals("subProcessStart", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(4)).getEntity()).getActivityId()));

      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(5).getType());
      assertEquals("subProcessStart", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(5)).getEntity()).getActivityId()));
      assertNotNull("subProcessStart", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(5)).getEntity()).getEndTime()));

      // Task a
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(6).getType());
      assertEquals("a", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(6)).getEntity()).getActivityId()));

      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(7).getType());
      assertEquals("a", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(7)).getEntity()).getActivityId()));
      assertNotNull("a", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(7)).getEntity()).getEndTime()));

      // Task b
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(8).getType());
      assertEquals("b", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(8)).getEntity()).getActivityId()));

      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(9).getType());
      assertEquals("b", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(9)).getEntity()).getActivityId()));
      assertNotNull("b", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(9)).getEntity()).getEndTime()));

      // subProcessEnd
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(10).getType());
      assertEquals("subprocessEnd", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(10)).getEntity()).getActivityId()));

      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(11).getType());
      assertEquals("subprocessEnd", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(11)).getEntity()).getActivityId()));
      assertNotNull("subprocessEnd", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(11)).getEntity()).getEndTime()));

      // subProcess end
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(12).getType());
      assertEquals("subProcess", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(12)).getEntity()).getActivityId()));
      assertNotNull("subProcess", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(12)).getEntity()).getEndTime()));

      // main end
      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(13).getType());
      assertEquals("mainEnd", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(13)).getEntity()).getActivityId()));

      assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(14).getType());
      assertEquals("mainEnd", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(14)).getEntity()).getActivityId()));
      assertNotNull("mainEnd", (((HistoricActivityInstance) ((ActivitiEntityEvent) events.get(14)).getEntity()).getEndTime()));

      // Process instance end
      assertEquals(ActivitiEventType.HISTORIC_PROCESS_INSTANCE_ENDED, events.get(15).getType());

    }
  }

}
!@#$%
20190526_171514,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.util.List;

import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.history.HistoricActivityInstance;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.test.Deployment;

/**
 * Test case for all {@link ActivitiEvent}s related to activities.
 * 
 * @author Frederik Heremans
 * @author Joram Barrez
 */
public class HistoricActivityEventsTest extends PluggableActivitiTestCase {

  private TestHistoricActivityEventListener listener;

  @Override
  protected void setUp() throws Exception {
    super.setUp();

    this.listener = new TestHistoricActivityEventListener();
    processEngineConfiguration.getEventDispatcher().addEventListener(listener);
  }

  @Override
  protected void tearDown() throws Exception {

    if (listener != null) {
      listener.clearEventsReceived();
      processEngineConfiguration.getEventDispatcher().removeEventListener(listener);
    }

    super.tearDown();
  }

  /**
   * Test added to assert the historic activity instance event
   */
  @Deployment
  public void testHistoricActivityEventDispatched() {
    
    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
    
  	 ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("TestActivityEvents");
     assertNotNull(processInstance);

     for (int i=0; i<2; i++) {
    	 taskService.complete(taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult().getId());
     }
     
     List<ActivitiEvent> events = listener.getEventsReceived();
     
     // Process instance start
     assertEquals(ActivitiEventType.HISTORIC_PROCESS_INSTANCE_CREATED, events.get(0).getType());
     
     // main start
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(1).getType());
     assertEquals("mainStart",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(1)).getEntity()).getActivityId()));
     
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(2).getType());
     assertEquals("mainStart",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(2)).getEntity()).getActivityId()));
     assertNotNull("mainStart",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(2)).getEntity()).getEndTime()));
     
     // Subprocess start
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(3).getType());
     assertEquals("subProcess",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(3)).getEntity()).getActivityId()));
     
     // subProcessStart
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(4).getType());
     assertEquals("subProcessStart",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(4)).getEntity()).getActivityId()));
     
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(5).getType());
     assertEquals("subProcessStart",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(5)).getEntity()).getActivityId()));
     assertNotNull("subProcessStart",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(5)).getEntity()).getEndTime()));
     
     // Task a
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(6).getType());
     assertEquals("a",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(6)).getEntity()).getActivityId()));
     
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(7).getType());
     assertEquals("a",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(7)).getEntity()).getActivityId()));
     assertNotNull("a",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(7)).getEntity()).getEndTime()));
     
     // Task b
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(8).getType());
     assertEquals("b",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(8)).getEntity()).getActivityId()));
     
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(9).getType());
     assertEquals("b",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(9)).getEntity()).getActivityId()));
     assertNotNull("b",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(9)).getEntity()).getEndTime()));
     
     // subProcessEnd
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(10).getType());
     assertEquals("subprocessEnd",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(10)).getEntity()).getActivityId()));
     
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(11).getType());
     assertEquals("subprocessEnd",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(11)).getEntity()).getActivityId()));
     assertNotNull("subprocessEnd",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(11)).getEntity()).getEndTime()));
     
     // subProcess end
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(12).getType());
     assertEquals("subProcess",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(12)).getEntity()).getActivityId()));
     assertNotNull("subProcess",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(12)).getEntity()).getEndTime()));
     
     // main end
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_CREATED, events.get(13).getType());
     assertEquals("mainEnd",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(13)).getEntity()).getActivityId()));
     
     assertEquals(ActivitiEventType.HISTORIC_ACTIVITY_INSTANCE_ENDED, events.get(14).getType());
     assertEquals("mainEnd",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(14)).getEntity()).getActivityId()));
     assertNotNull("mainEnd",  ( ( (HistoricActivityInstance) ((ActivitiEntityEvent) events.get(14)).getEntity()).getEndTime()));
     
     // Process instance end
     assertEquals(ActivitiEventType.HISTORIC_PROCESS_INSTANCE_ENDED, events.get(15).getType());
     
    }
  }

}
!@#$%
20190526_171518,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.io.ByteArrayInputStream;

import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.identity.Authentication;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Attachment;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

/**
 * Test case for all {@link ActivitiEvent}s related to attachments.
 * 
 * @author Frederik Heremans
 */
public class AttachmentEventsTest extends PluggableActivitiTestCase {

  private TestActivitiEntityEventListener listener;

  /**
   * Test create, update and delete events of attachments on a task/process.
   */
  @Deployment(resources = { "org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml" })
  public void testAttachmentEntityEvents() throws Exception {

    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
      ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess");

      Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
      assertNotNull(task);

      // Create link-attachment
      Attachment attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", "http://activiti.org");
      assertNull(attachment.getUserId());
      assertEquals(2, listener.getEventsReceived().size());
      ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
      assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
      assertEquals(processInstance.getId(), event.getProcessInstanceId());
      assertEquals(processInstance.getId(), event.getExecutionId());
      assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
      Attachment attachmentFromEvent = (Attachment) event.getEntity();
      assertEquals(attachment.getId(), attachmentFromEvent.getId());
      event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
      assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
      assertEquals(processInstance.getId(), event.getProcessInstanceId());
      assertEquals(processInstance.getId(), event.getExecutionId());
      assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
      attachmentFromEvent = (Attachment) event.getEntity();
      assertEquals(attachment.getId(), attachmentFromEvent.getId());
      listener.clearEventsReceived();

      // Create binary attachment
      Authentication.setAuthenticatedUserId("testuser");
      attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", new ByteArrayInputStream("test".getBytes()));
      assertNotNull(attachment.getUserId());
      assertEquals("testuser", attachment.getUserId());
      assertEquals(2, listener.getEventsReceived().size());
      event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
      assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
      assertEquals(processInstance.getId(), event.getProcessInstanceId());
      assertEquals(processInstance.getId(), event.getExecutionId());
      assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
      attachmentFromEvent = (Attachment) event.getEntity();
      assertEquals(attachment.getId(), attachmentFromEvent.getId());

      event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
      assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
      listener.clearEventsReceived();

      // Update attachment
      attachment = taskService.getAttachment(attachment.getId());
      attachment.setDescription("Description");
      taskService.saveAttachment(attachment);

      assertEquals(1, listener.getEventsReceived().size());
      event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
      assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());
      assertEquals(processInstance.getId(), event.getProcessInstanceId());
      assertEquals(processInstance.getId(), event.getExecutionId());
      assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
      attachmentFromEvent = (Attachment) event.getEntity();
      assertEquals(attachment.getId(), attachmentFromEvent.getId());
      assertEquals("Description", attachmentFromEvent.getDescription());
      listener.clearEventsReceived();

      // Finally, delete attachment
      taskService.deleteAttachment(attachment.getId());
      assertEquals(1, listener.getEventsReceived().size());
      event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
      assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
      assertEquals(processInstance.getId(), event.getProcessInstanceId());
      assertEquals(processInstance.getId(), event.getExecutionId());
      assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
      attachmentFromEvent = (Attachment) event.getEntity();
      assertEquals(attachment.getId(), attachmentFromEvent.getId());
    }
  }

  /**
   * Test create, update and delete events of users.
   */
  public void testAttachmentEntityEventsStandaloneTask() throws Exception {
    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
      Task task = null;
      try {
        task = taskService.newTask();
        taskService.saveTask(task);
        assertNotNull(task);

        // Create link-attachment
        Attachment attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", "http://activiti.org");
        assertEquals(2, listener.getEventsReceived().size());
        ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
        assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
        assertNull(event.getProcessInstanceId());
        assertNull(event.getExecutionId());
        assertNull(event.getProcessDefinitionId());
        Attachment attachmentFromEvent = (Attachment) event.getEntity();
        assertEquals(attachment.getId(), attachmentFromEvent.getId());
        event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
        assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
        listener.clearEventsReceived();

        // Create binary attachment
        attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", new ByteArrayInputStream("test".getBytes()));
        assertEquals(2, listener.getEventsReceived().size());
        event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
        assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
        assertNull(event.getProcessInstanceId());
        assertNull(event.getExecutionId());
        assertNull(event.getProcessDefinitionId());
        attachmentFromEvent = (Attachment) event.getEntity();
        assertEquals(attachment.getId(), attachmentFromEvent.getId());

        event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
        assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
        listener.clearEventsReceived();

        // Update attachment
        attachment = taskService.getAttachment(attachment.getId());
        attachment.setDescription("Description");
        taskService.saveAttachment(attachment);

        assertEquals(1, listener.getEventsReceived().size());
        event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
        assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());
        assertNull(event.getProcessInstanceId());
        assertNull(event.getExecutionId());
        assertNull(event.getProcessDefinitionId());
        attachmentFromEvent = (Attachment) event.getEntity();
        assertEquals(attachment.getId(), attachmentFromEvent.getId());
        assertEquals("Description", attachmentFromEvent.getDescription());
        listener.clearEventsReceived();

        // Finally, delete attachment
        taskService.deleteAttachment(attachment.getId());
        assertEquals(1, listener.getEventsReceived().size());
        event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
        assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
        assertNull(event.getProcessInstanceId());
        assertNull(event.getExecutionId());
        assertNull(event.getProcessDefinitionId());
        attachmentFromEvent = (Attachment) event.getEntity();
        assertEquals(attachment.getId(), attachmentFromEvent.getId());

      } finally {
        if (task != null && task.getId() != null) {
          taskService.deleteTask(task.getId());
          historyService.deleteHistoricTaskInstance(task.getId());
        }
      }
    }
  }

  public void testAttachmentEntityEventsOnHistoricTaskDelete() throws Exception {
    if (processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
      Task task = null;
      try {
        task = taskService.newTask();
        taskService.saveTask(task);
        assertNotNull(task);

        // Create link-attachment
        Attachment attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", "http://activiti.org");
        listener.clearEventsReceived();

        // Delete task and historic task
        taskService.deleteTask(task.getId());
        historyService.deleteHistoricTaskInstance(task.getId());

        assertEquals(1, listener.getEventsReceived().size());
        ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
        assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
        assertNull(event.getProcessInstanceId());
        assertNull(event.getExecutionId());
        assertNull(event.getProcessDefinitionId());
        Attachment attachmentFromEvent = (Attachment) event.getEntity();
        assertEquals(attachment.getId(), attachmentFromEvent.getId());

      } finally {
        if (task != null && task.getId() != null) {
          taskService.deleteTask(task.getId());
          historyService.deleteHistoricTaskInstance(task.getId());
        }
      }
    }
  }

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    listener = new TestActivitiEntityEventListener(Attachment.class);
    processEngineConfiguration.getEventDispatcher().addEventListener(listener);
  }

  @Override
  protected void tearDown() throws Exception {
    super.tearDown();

    if (listener != null) {
      processEngineConfiguration.getEventDispatcher().removeEventListener(listener);
    }
  }
}
!@#$%
20190526_171518,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.io.ByteArrayInputStream;

import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.identity.Authentication;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Attachment;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

/**
 * Test case for all {@link ActivitiEvent}s related to attachments.
 * 
 * @author Frederik Heremans
 */
public class AttachmentEventsTest extends PluggableActivitiTestCase {

	private TestActivitiEntityEventListener listener;

	/**
	 * Test create, update and delete events of attachments on a task/process.
	 */
	@Deployment(resources = { "org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml" })
	public void testAttachmentEntityEvents() throws Exception {
		
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess");
			
			Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
			assertNotNull(task);
			
			// Create link-attachment
			Attachment attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", "http://activiti.org");
			assertNull(attachment.getUserId());
			assertEquals(2, listener.getEventsReceived().size());
			ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			Attachment attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
			assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			listener.clearEventsReceived();
			
			// Create binary attachment
			Authentication.setAuthenticatedUserId("testuser");
			attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", new ByteArrayInputStream("test".getBytes()));
			assertNotNull(attachment.getUserId());
			assertEquals("testuser", attachment.getUserId());
			assertEquals(2, listener.getEventsReceived().size());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
			assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
			listener.clearEventsReceived();
			
			// Update attachment
			attachment = taskService.getAttachment(attachment.getId());
			attachment.setDescription("Description");
			taskService.saveAttachment(attachment);
			
			assertEquals(1, listener.getEventsReceived().size());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			assertEquals("Description", attachmentFromEvent.getDescription());
			listener.clearEventsReceived();
			
			// Finally, delete attachment
			taskService.deleteAttachment(attachment.getId());
			assertEquals(1, listener.getEventsReceived().size());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
		}
	}
	
	/**
	 * Test create, update and delete events of users.
	 */
	public void testAttachmentEntityEventsStandaloneTask() throws Exception {
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			Task task = null;
			try {
				task = taskService.newTask();
				taskService.saveTask(task);
				assertNotNull(task);
				
				// Create link-attachment
				Attachment attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", "http://activiti.org");
				assertEquals(2, listener.getEventsReceived().size());
				ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				Attachment attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
				assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
				listener.clearEventsReceived();
				
				// Create binary attachment
				attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", new ByteArrayInputStream("test".getBytes()));
				assertEquals(2, listener.getEventsReceived().size());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
				assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
				listener.clearEventsReceived();
				
				// Update attachment
				attachment = taskService.getAttachment(attachment.getId());
				attachment.setDescription("Description");
				taskService.saveAttachment(attachment);
				
				assertEquals(1, listener.getEventsReceived().size());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				assertEquals("Description", attachmentFromEvent.getDescription());
				listener.clearEventsReceived();
				
				// Finally, delete attachment
				taskService.deleteAttachment(attachment.getId());
				assertEquals(1, listener.getEventsReceived().size());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				
			} finally {
				if(task != null && task.getId() != null) {
					taskService.deleteTask(task.getId());
					historyService.deleteHistoricTaskInstance(task.getId());
				}
			}
		}
	}
	
	public void testAttachmentEntityEventsOnHistoricTaskDelete() throws Exception {
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			Task task = null;
			try {
				task = taskService.newTask();
				taskService.saveTask(task);
				assertNotNull(task);
				
				// Create link-attachment
				Attachment attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", "http://activiti.org");
				listener.clearEventsReceived();
				
				// Delete task and historic task
				taskService.deleteTask(task.getId());
				historyService.deleteHistoricTaskInstance(task.getId());
				
				assertEquals(1, listener.getEventsReceived().size());
				ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				Attachment attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				
			} finally {
				if(task != null && task.getId() != null) {
					taskService.deleteTask(task.getId());
					historyService.deleteHistoricTaskInstance(task.getId());
				}
			}
		}
	}

	@Override
	protected void setUp() throws Exception {
		super.setUp();
		listener = new TestActivitiEntityEventListener(Attachment.class);
		processEngineConfiguration.getEventDispatcher().addEventListener(listener);
	}

	@Override
	protected void tearDown() throws Exception {
		super.tearDown();

		if (listener != null) {
			processEngineConfiguration.getEventDispatcher().removeEventListener(listener);
		}
	}
}
!@#$%
20190526_171518,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.test.api.event;

import java.io.ByteArrayInputStream;

import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.identity.Authentication;
import org.activiti.engine.impl.test.PluggableActivitiTestCase;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Attachment;
import org.activiti.engine.task.Task;
import org.activiti.engine.test.Deployment;

/**
 * Test case for all {@link ActivitiEvent}s related to attachments.
 * 
 * @author Frederik Heremans
 */
public class AttachmentEventsTest extends PluggableActivitiTestCase {

	private TestActivitiEntityEventListener listener;

	/**
	 * Test create, update and delete events of attachments on a task/process.
	 */
	@Deployment(resources = { "org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml" })
	public void testAttachmentEntityEvents() throws Exception {
		
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess");
			
			Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
			assertNotNull(task);
			
			// Create link-attachment
			Attachment attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", "http://activiti.org");
			assertNull(attachment.getUserId());
			assertEquals(2, listener.getEventsReceived().size());
			ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			Attachment attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
			assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			listener.clearEventsReceived();
			
			// Create binary attachment
			Authentication.setAuthenticatedUserId("testuser");
			attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", new ByteArrayInputStream("test".getBytes()));
			assertNotNull(attachment.getUserId());
			assertEquals("testuser", attachment.getUserId());
			assertEquals(2, listener.getEventsReceived().size());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
			assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
			listener.clearEventsReceived();
			
			// Update attachment
			attachment = taskService.getAttachment(attachment.getId());
			attachment.setDescription("Description");
			taskService.saveAttachment(attachment);
			
			assertEquals(1, listener.getEventsReceived().size());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
			assertEquals("Description", attachmentFromEvent.getDescription());
			listener.clearEventsReceived();
			
			// Finally, delete attachment
			taskService.deleteAttachment(attachment.getId());
			assertEquals(1, listener.getEventsReceived().size());
			event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
		}
	}
	
	/**
	 * Test create, update and delete events of users.
	 */
	public void testAttachmentEntityEventsStandaloneTask() throws Exception {
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			Task task = null;
			try {
				task = taskService.newTask();
				taskService.saveTask(task);
				assertNotNull(task);
				
				// Create link-attachment
				Attachment attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", "http://activiti.org");
				assertEquals(2, listener.getEventsReceived().size());
				ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				Attachment attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
				assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
				listener.clearEventsReceived();
				
				// Create binary attachment
				attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", new ByteArrayInputStream("test".getBytes()));
				assertEquals(2, listener.getEventsReceived().size());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_CREATED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(1);
				assertEquals(ActivitiEventType.ENTITY_INITIALIZED, event.getType());
				listener.clearEventsReceived();
				
				// Update attachment
				attachment = taskService.getAttachment(attachment.getId());
				attachment.setDescription("Description");
				taskService.saveAttachment(attachment);
				
				assertEquals(1, listener.getEventsReceived().size());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_UPDATED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				assertEquals("Description", attachmentFromEvent.getDescription());
				listener.clearEventsReceived();
				
				// Finally, delete attachment
				taskService.deleteAttachment(attachment.getId());
				assertEquals(1, listener.getEventsReceived().size());
				event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				
			} finally {
				if(task != null && task.getId() != null) {
					taskService.deleteTask(task.getId());
					historyService.deleteHistoricTaskInstance(task.getId());
				}
			}
		}
	}
	
	@Deployment(resources = { "org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml" })
	public void testAttachmentEntityEventsOnHistoricProcessInstanceDelete() throws Exception {
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess");
			
			// Create link-attachment
			Attachment attachment = taskService.createAttachment("test", null, processInstance.getId(), "attachment name", "description", "http://activiti.org");
			listener.clearEventsReceived();
			
			runtimeService.deleteProcessInstance(processInstance.getId(), null);
			historyService.deleteHistoricProcessInstance(processInstance.getId());
			
			assertEquals(1, listener.getEventsReceived().size());
			ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			Attachment attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
		}
	}
	
	public void testAttachmentEntityEventsOnHistoricTaskDelete() throws Exception {
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			Task task = null;
			try {
				task = taskService.newTask();
				taskService.saveTask(task);
				assertNotNull(task);
				
				// Create link-attachment
				Attachment attachment = taskService.createAttachment("test", task.getId(), null, "attachment name", "description", "http://activiti.org");
				listener.clearEventsReceived();
				
				// Delete task and historic task
				taskService.deleteTask(task.getId());
				historyService.deleteHistoricTaskInstance(task.getId());
				
				assertEquals(1, listener.getEventsReceived().size());
				ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
				assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
				assertNull(event.getProcessInstanceId());
				assertNull(event.getExecutionId());
				assertNull(event.getProcessDefinitionId());
				Attachment attachmentFromEvent = (Attachment) event.getEntity();
				assertEquals(attachment.getId(), attachmentFromEvent.getId());
				
			} finally {
				if(task != null && task.getId() != null) {
					taskService.deleteTask(task.getId());
					historyService.deleteHistoricTaskInstance(task.getId());
				}
			}
		}
	}

	@Deployment(resources = { "org/activiti/engine/test/api/runtime/oneTaskProcess.bpmn20.xml" })
	public void testAttachmentEntityEventsOnHistoricTaskDeleteInProcessInstance() throws Exception {
		if(processEngineConfiguration.getHistoryLevel().isAtLeast(HistoryLevel.ACTIVITY)) {
			ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("oneTaskProcess");
			
			Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();
			assertNotNull(task);
			
			// Create link-attachment
			Attachment attachment = taskService.createAttachment("test", task.getId(), processInstance.getId(), "attachment name", "description", "http://activiti.org");
			listener.clearEventsReceived();
			
			runtimeService.deleteProcessInstance(processInstance.getId(), null);
			historyService.deleteHistoricProcessInstance(processInstance.getId());
			
			assertEquals(1, listener.getEventsReceived().size());
			ActivitiEntityEvent event = (ActivitiEntityEvent) listener.getEventsReceived().get(0);
			assertEquals(ActivitiEventType.ENTITY_DELETED, event.getType());
			assertEquals(processInstance.getId(), event.getProcessInstanceId());
			assertEquals(processInstance.getId(), event.getExecutionId());
			assertEquals(processInstance.getProcessDefinitionId(), event.getProcessDefinitionId());
			Attachment attachmentFromEvent = (Attachment) event.getEntity();
			assertEquals(attachment.getId(), attachmentFromEvent.getId());
		}
	}
	
	@Override
	protected void setUp() throws Exception {
		super.setUp();
		listener = new TestActivitiEntityEventListener(Attachment.class);
		processEngineConfiguration.getEventDispatcher().addEventListener(listener);
	}

	@Override
	protected void tearDown() throws Exception {
		super.tearDown();

		if (listener != null) {
			processEngineConfiguration.getEventDispatcher().removeEventListener(listener);
		}
	}
}
!@#$%
20190526_171544,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.scripting;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.script.Bindings;
import javax.script.SimpleScriptContext;

import org.activiti.engine.delegate.VariableScope;

/**
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class ScriptBindings implements Bindings {

  /**
   * The script engine implementations put some key/value pairs into the binding. 
   * This list contains those keys, such that they wouldn't be stored as process variable.
   * 
   * This list contains the keywords for JUEL, Javascript and Groovy.
   */
  protected static final Set<String> UNSTORED_KEYS = 
    new HashSet<String>(Arrays.asList("out", "out:print", "lang:import", "context", "elcontext", "print", "println", "nashorn.global"));

  protected List<Resolver> scriptResolvers;
  protected VariableScope variableScope;
  protected Bindings defaultBindings;
  protected boolean storeScriptVariables = true; // By default everything is stored (backwards compatibility)

  public ScriptBindings(List<Resolver> scriptResolvers, VariableScope variableScope) {
    this.scriptResolvers = scriptResolvers;
    this.variableScope = variableScope;
    this.defaultBindings = new SimpleScriptContext().getBindings(SimpleScriptContext.ENGINE_SCOPE);
  }

  public ScriptBindings(List<Resolver> scriptResolvers, VariableScope variableScope, boolean storeScriptVariables) {
    this(scriptResolvers, variableScope);
    this.storeScriptVariables = storeScriptVariables;
  }

  public boolean containsKey(Object key) {
    for (Resolver scriptResolver : scriptResolvers) {
      if (scriptResolver.containsKey(key)) {
        return true;
      }
    }
    return defaultBindings.containsKey(key);
  }

  public Object get(Object key) {
    for (Resolver scriptResolver : scriptResolvers) {
      if (scriptResolver.containsKey(key)) {
        return scriptResolver.get(key);
      }
    }
    return defaultBindings.get(key);
  }

  public Object put(String name, Object value) {
    if (storeScriptVariables) {
      Object oldValue = null;
      if (!UNSTORED_KEYS.contains(name)) {
        oldValue = variableScope.getVariable(name);
        variableScope.setVariable(name, value);
        return oldValue;
      }
    }
    return defaultBindings.put(name, value);
  }

  public Set<Map.Entry<String, Object>> entrySet() {
    return variableScope.getVariables().entrySet();
  }

  public Set<String> keySet() {
    return variableScope.getVariables().keySet();
  }

  public int size() {
    return variableScope.getVariables().size();
  }

  public Collection<Object> values() {
    return variableScope.getVariables().values();
  }

  public void putAll(Map<? extends String, ? extends Object> toMerge) {
    throw new UnsupportedOperationException();
  }

  public Object remove(Object key) {
    if (UNSTORED_KEYS.contains(key)) {
      return null;
    }
    return defaultBindings.remove(key);
  }

  public void clear() {
    throw new UnsupportedOperationException();
  }

  public boolean containsValue(Object value) {
    throw new UnsupportedOperationException();
  }

  public boolean isEmpty() {
    throw new UnsupportedOperationException();
  }
  
  public void addUnstoredKey(String unstoredKey) {
  	UNSTORED_KEYS.add(unstoredKey);
  }
  
}
!@#$%
20190526_171544,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.scripting;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.script.Bindings;
import javax.script.SimpleScriptContext;

import org.activiti.engine.delegate.VariableScope;


/**
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class ScriptBindings implements Bindings {

  /**
   * The script engine implementations put some key/value pairs into the binding.
   * This list contains those keys, such that they wouldn't be stored as process variable.
   * 
   * This list contains the keywords for JUEL, Javascript and Groovy.
   */
  protected static final Set<String> UNSTORED_KEYS = 
    new HashSet<String>(Arrays.asList("out", "out:print", "lang:import", "context", "elcontext", "print", "println"));

  protected List<Resolver> scriptResolvers;
  protected VariableScope variableScope;
  protected Bindings defaultBindings;
  protected boolean storeScriptVariables = true; // By default everything is stored (backwards compatibility) 
  
  public ScriptBindings(List<Resolver> scriptResolvers, VariableScope variableScope) {
    this.scriptResolvers = scriptResolvers;
    this.variableScope = variableScope;
    this.defaultBindings = new SimpleScriptContext().getBindings(SimpleScriptContext.ENGINE_SCOPE);
  }
  
  public ScriptBindings(List<Resolver> scriptResolvers, VariableScope variableScope, boolean storeScriptVariables) {
    this(scriptResolvers, variableScope);
    this.storeScriptVariables = storeScriptVariables;
  }

  public boolean containsKey(Object key) {
    for (Resolver scriptResolver: scriptResolvers) {
      if (scriptResolver.containsKey(key)) {
        return true;
      }
    }
    return defaultBindings.containsKey(key);
  }

  public Object get(Object key) {
    for (Resolver scriptResolver: scriptResolvers) {
      if (scriptResolver.containsKey(key)) {
        return scriptResolver.get(key);
      }
    }
    return defaultBindings.get(key);
  }

  public Object put(String name, Object value) {
    if (storeScriptVariables) {
      Object oldValue = null;
      if (!UNSTORED_KEYS.contains(name)) {
        oldValue = variableScope.getVariable(name);
        variableScope.setVariable(name, value);
        return oldValue;
      }
    }
    return defaultBindings.put(name, value);
  }

  public Set<Map.Entry<String, Object>> entrySet() {
    return variableScope.getVariables().entrySet();
  }

  public Set<String> keySet() {
    return variableScope.getVariables().keySet();
  }

  public int size() {
    return variableScope.getVariables().size();
  }

  public Collection<Object> values() {
    return variableScope.getVariables().values();
  }

  public void putAll(Map< ? extends String, ? extends Object> toMerge) {
    throw new UnsupportedOperationException();
  }

  public Object remove(Object key) {
    if (UNSTORED_KEYS.contains(key)) {
      return null;
    }
    return defaultBindings.remove(key);
  }

  public void clear() {
    throw new UnsupportedOperationException();
  }

  public boolean containsValue(Object value) {
    throw new UnsupportedOperationException();
  }

  public boolean isEmpty() {
    throw new UnsupportedOperationException();
  }
}
!@#$%
20190526_171544,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.scripting;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.script.Bindings;
import javax.script.SimpleScriptContext;

import org.activiti.engine.delegate.VariableScope;


/**
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class ScriptBindings implements Bindings {

  /**
   * The script engine implementations put some key/value pairs into the binding.
   * This list contains those keys, such that they wouldn't be stored as process variable.
   * 
   * This list contains the keywords for JUEL, Javascript and Groovy.
   */
  protected static final Set<String> UNSTORED_KEYS = 
    new HashSet<String>(Arrays.asList("out", "out:print", "lang:import", "context", "elcontext", "print", "println", "nashorn.global"));

  protected List<Resolver> scriptResolvers;
  protected VariableScope variableScope;
  protected Bindings defaultBindings;
  protected boolean storeScriptVariables = true; // By default everything is stored (backwards compatibility) 
  
  public ScriptBindings(List<Resolver> scriptResolvers, VariableScope variableScope) {
    this.scriptResolvers = scriptResolvers;
    this.variableScope = variableScope;
    this.defaultBindings = new SimpleScriptContext().getBindings(SimpleScriptContext.ENGINE_SCOPE);
  }
  
  public ScriptBindings(List<Resolver> scriptResolvers, VariableScope variableScope, boolean storeScriptVariables) {
    this(scriptResolvers, variableScope);
    this.storeScriptVariables = storeScriptVariables;
  }

  public boolean containsKey(Object key) {
    for (Resolver scriptResolver: scriptResolvers) {
      if (scriptResolver.containsKey(key)) {
        return true;
      }
    }
    return defaultBindings.containsKey(key);
  }

  public Object get(Object key) {
    for (Resolver scriptResolver: scriptResolvers) {
      if (scriptResolver.containsKey(key)) {
        return scriptResolver.get(key);
      }
    }
    return defaultBindings.get(key);
  }

  public Object put(String name, Object value) {
    if (storeScriptVariables) {
      Object oldValue = null;
      if (!UNSTORED_KEYS.contains(name)) {
        oldValue = variableScope.getVariable(name);
        variableScope.setVariable(name, value);
        return oldValue;
      }
    }
    return defaultBindings.put(name, value);
  }

  public Set<Map.Entry<String, Object>> entrySet() {
    return variableScope.getVariables().entrySet();
  }

  public Set<String> keySet() {
    return variableScope.getVariables().keySet();
  }

  public int size() {
    return variableScope.getVariables().size();
  }

  public Collection<Object> values() {
    return variableScope.getVariables().values();
  }

  public void putAll(Map< ? extends String, ? extends Object> toMerge) {
    throw new UnsupportedOperationException();
  }

  public Object remove(Object key) {
    if (UNSTORED_KEYS.contains(key)) {
      return null;
    }
    return defaultBindings.remove(key);
  }

  public void clear() {
    throw new UnsupportedOperationException();
  }

  public boolean containsValue(Object value) {
    throw new UnsupportedOperationException();
  }

  public boolean isEmpty() {
    throw new UnsupportedOperationException();
  }
  
  public void addUnstoredKey(String unstoredKey) {
  	UNSTORED_KEYS.add(unstoredKey);
  }
  
}
!@#$%
20190526_171558,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.persistence.entity;

import java.util.List;
import java.util.Map;

import org.activiti.engine.impl.TablePageQueryImpl;
import org.activiti.engine.management.TableMetaData;
import org.activiti.engine.management.TablePage;

/**
 * @author Joram Barrez
 */
public interface TableDataManager {

  Map<String, Long> getTableCount();

  List<String> getTablesPresentInDatabase();

  TablePage getTablePage(TablePageQueryImpl tablePageQuery, int firstResult, int maxResults);

  String getTableName(Class<?> entityClass, boolean withPrefix);

  TableMetaData getTableMetaData(String tableName);

}
!@#$%
20190526_171558,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.persistence.entity;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.history.HistoricActivityInstance;
import org.activiti.engine.history.HistoricDetail;
import org.activiti.engine.history.HistoricFormProperty;
import org.activiti.engine.history.HistoricProcessInstance;
import org.activiti.engine.history.HistoricTaskInstance;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.history.HistoricVariableUpdate;
import org.activiti.engine.identity.Group;
import org.activiti.engine.identity.User;
import org.activiti.engine.impl.TablePageQueryImpl;
import org.activiti.engine.impl.db.PersistentObject;
import org.activiti.engine.impl.persistence.AbstractManager;
import org.activiti.engine.management.TableMetaData;
import org.activiti.engine.management.TablePage;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.Model;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.Execution;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.apache.ibatis.session.RowBounds;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * @author Tom Baeyens
 */
public class TableDataManager extends AbstractManager {
  
  private static Logger log = LoggerFactory.getLogger(TableDataManager.class);
  
  public static Map<Class<?>, String> apiTypeToTableNameMap = new HashMap<Class<?>, String>();
  public static Map<Class<? extends PersistentObject>, String> persistentObjectToTableNameMap = new HashMap<Class<? extends PersistentObject>, String>();
  
  static {
    // runtime
    persistentObjectToTableNameMap.put(TaskEntity.class, "ACT_RU_TASK");
    persistentObjectToTableNameMap.put(ExecutionEntity.class, "ACT_RU_EXECUTION");
    persistentObjectToTableNameMap.put(IdentityLinkEntity.class, "ACT_RU_IDENTITYLINK");
    persistentObjectToTableNameMap.put(VariableInstanceEntity.class, "ACT_RU_VARIABLE");
    
    persistentObjectToTableNameMap.put(JobEntity.class, "ACT_RU_JOB");
    persistentObjectToTableNameMap.put(MessageEntity.class, "ACT_RU_JOB");
    persistentObjectToTableNameMap.put(TimerEntity.class, "ACT_RU_JOB");
    
    persistentObjectToTableNameMap.put(EventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");
    persistentObjectToTableNameMap.put(CompensateEventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");    
    persistentObjectToTableNameMap.put(MessageEventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");    
    persistentObjectToTableNameMap.put(SignalEventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");
        
    // repository
    persistentObjectToTableNameMap.put(DeploymentEntity.class, "ACT_RE_DEPLOYMENT");
    persistentObjectToTableNameMap.put(ProcessDefinitionEntity.class, "ACT_RE_PROCDEF");
    persistentObjectToTableNameMap.put(ModelEntity.class, "ACT_RE_MODEL");
    
    // history
    persistentObjectToTableNameMap.put(CommentEntity.class, "ACT_HI_COMMENT");
    
    persistentObjectToTableNameMap.put(HistoricActivityInstanceEntity.class, "ACT_HI_ACTINST");
    persistentObjectToTableNameMap.put(AttachmentEntity.class, "ACT_HI_ATTACHMEN");
    persistentObjectToTableNameMap.put(HistoricProcessInstanceEntity.class, "ACT_HI_PROCINST");
    persistentObjectToTableNameMap.put(HistoricVariableInstanceEntity.class, "ACT_HI_VARINST");
    persistentObjectToTableNameMap.put(HistoricTaskInstanceEntity.class, "ACT_HI_TASKINST");
    persistentObjectToTableNameMap.put(HistoricIdentityLinkEntity.class, "ACT_HI_IDENTITYLINK");
    
    // a couple of stuff goes to the same table
    persistentObjectToTableNameMap.put(HistoricDetailAssignmentEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricDetailTransitionInstanceEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricFormPropertyEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricDetailVariableInstanceUpdateEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricDetailEntity.class, "ACT_HI_DETAIL");
    
    
    // Identity module
    persistentObjectToTableNameMap.put(GroupEntity.class, "ACT_ID_GROUP");
    persistentObjectToTableNameMap.put(MembershipEntity.class, "ACT_ID_MEMBERSHIP");
    persistentObjectToTableNameMap.put(UserEntity.class, "ACT_ID_USER");
    persistentObjectToTableNameMap.put(IdentityInfoEntity.class, "ACT_ID_INFO");
    
    // general
    persistentObjectToTableNameMap.put(PropertyEntity.class, "ACT_GE_PROPERTY");
    persistentObjectToTableNameMap.put(ByteArrayEntity.class, "ACT_GE_BYTEARRAY");
    persistentObjectToTableNameMap.put(ResourceEntity.class, "ACT_GE_BYTEARRAY");
    
    // and now the map for the API types (does not cover all cases)
    apiTypeToTableNameMap.put(Task.class, "ACT_RU_TASK");
    apiTypeToTableNameMap.put(Execution.class, "ACT_RU_EXECUTION");
    apiTypeToTableNameMap.put(ProcessInstance.class, "ACT_RU_EXECUTION");
    apiTypeToTableNameMap.put(ProcessDefinition.class, "ACT_RE_PROCDEF");
    apiTypeToTableNameMap.put(Deployment.class, "ACT_RE_DEPLOYMENT");    
    apiTypeToTableNameMap.put(Job.class, "ACT_RU_JOB");
    apiTypeToTableNameMap.put(Model.class, "ACT_RE_MODEL");
    
    // history
    apiTypeToTableNameMap.put(HistoricProcessInstance.class, "ACT_HI_PROCINST");
    apiTypeToTableNameMap.put(HistoricActivityInstance.class, "ACT_HI_ACTINST");
    apiTypeToTableNameMap.put(HistoricDetail.class, "ACT_HI_DETAIL");
    apiTypeToTableNameMap.put(HistoricVariableUpdate.class, "ACT_HI_DETAIL");
    apiTypeToTableNameMap.put(HistoricFormProperty.class, "ACT_HI_DETAIL");
    apiTypeToTableNameMap.put(HistoricTaskInstance.class, "ACT_HI_TASKINST");        
    apiTypeToTableNameMap.put(HistoricVariableInstance.class, "ACT_HI_VARINST");

    // identity
    apiTypeToTableNameMap.put(Group.class, "ACT_ID_GROUP");
    apiTypeToTableNameMap.put(User.class, "ACT_ID_USER");

    // TODO: Identity skipped for the moment as no SQL injection is provided here
  }

  public Map<String, Long> getTableCount() {
    Map<String, Long> tableCount = new HashMap<String, Long>();
    try {
      for (String tableName: getTablesPresentInDatabase()) {
        tableCount.put(tableName, getTableCount(tableName));
      }
      log.debug("Number of rows per activiti table: {}", tableCount);
    } catch (Exception e) {
      throw new ActivitiException("couldn't get table counts", e);
    }
    return tableCount;
  }

  public List<String> getTablesPresentInDatabase() {
    List<String> tableNames = new ArrayList<String>();
    Connection connection = null;
    try {
      connection = getDbSqlSession().getSqlSession().getConnection();
      DatabaseMetaData databaseMetaData = connection.getMetaData();
      ResultSet tables = null;
      try {
        log.debug("retrieving activiti tables from jdbc metadata");
        String databaseTablePrefix = getDbSqlSession().getDbSqlSessionFactory().getDatabaseTablePrefix();
        String tableNameFilter = databaseTablePrefix+"ACT_%";
        if ("postgres".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          tableNameFilter = databaseTablePrefix+"act_%";
        }
        if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          tableNameFilter = databaseTablePrefix+"ACT" + databaseMetaData.getSearchStringEscape() + "_%";
        }
        tables = databaseMetaData.getTables(null, null, tableNameFilter, getDbSqlSession().JDBC_METADATA_TABLE_TYPES);
        while (tables.next()) {
          String tableName = tables.getString("TABLE_NAME");
          tableName = tableName.toUpperCase();
          tableNames.add(tableName);
          log.debug("  retrieved activiti table name {}", tableName);
        }
      } finally {
        tables.close();
      }
    } catch (Exception e) {
      throw new ActivitiException("couldn't get activiti table names using metadata: "+e.getMessage(), e); 
    }
    return tableNames;
  }

  protected long getTableCount(String tableName) {
    log.debug("selecting table count for {}", tableName);
    Long count = (Long) getDbSqlSession().selectOne("selectTableCount",
            Collections.singletonMap("tableName", tableName));
    return count;
  }

  @SuppressWarnings("unchecked")
  public TablePage getTablePage(TablePageQueryImpl tablePageQuery, int firstResult, int maxResults) {

    TablePage tablePage = new TablePage();

    @SuppressWarnings("rawtypes")
    List tableData = getDbSqlSession().getSqlSession()
      .selectList("selectTableData", tablePageQuery, new RowBounds(firstResult, maxResults));

    tablePage.setTableName(tablePageQuery.getTableName());
    tablePage.setTotal(getTableCount(tablePageQuery.getTableName()));
    tablePage.setRows((List<Map<String,Object>>)tableData);
    tablePage.setFirstResult(firstResult);
    
    return tablePage;
  }
  
  public String getTableName(Class<?> entityClass, boolean withPrefix) {
    String databaseTablePrefix = getDbSqlSession().getDbSqlSessionFactory().getDatabaseTablePrefix();
    String tableName = null;
    
    if (PersistentObject.class.isAssignableFrom(entityClass)) {
      tableName = persistentObjectToTableNameMap.get(entityClass);
    }
    else {
      tableName = apiTypeToTableNameMap.get(entityClass);
    }
    if (withPrefix) {
      return databaseTablePrefix + tableName;
    }
    else {
      return tableName;
    }
  }

  public TableMetaData getTableMetaData(String tableName) {
    TableMetaData result = new TableMetaData();
    try {
      result.setTableName(tableName);
      DatabaseMetaData metaData = getDbSqlSession()
        .getSqlSession()
        .getConnection()
        .getMetaData();

      if ("postgres".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
        tableName = tableName.toLowerCase();
      }

      ResultSet resultSet = metaData.getColumns(null, null, tableName, null);
      while(resultSet.next()) {
        String name = resultSet.getString("COLUMN_NAME").toUpperCase();
        String type = resultSet.getString("TYPE_NAME").toUpperCase();
        result.addColumnMetaData(name, type);
      }
      
    } catch (SQLException e) {
      throw new ActivitiException("Could not retrieve database metadata: " + e.getMessage());
    }

    if(result.getColumnNames().isEmpty()) {
      // According to API, when a table doesn't exist, null should be returned
      result = null;
    }
    return result;
  }

}
!@#$%
20190526_171558,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.persistence.entity;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.history.HistoricActivityInstance;
import org.activiti.engine.history.HistoricDetail;
import org.activiti.engine.history.HistoricFormProperty;
import org.activiti.engine.history.HistoricProcessInstance;
import org.activiti.engine.history.HistoricTaskInstance;
import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.history.HistoricVariableUpdate;
import org.activiti.engine.identity.Group;
import org.activiti.engine.identity.User;
import org.activiti.engine.impl.TablePageQueryImpl;
import org.activiti.engine.impl.db.PersistentObject;
import org.activiti.engine.impl.persistence.AbstractManager;
import org.activiti.engine.management.TableMetaData;
import org.activiti.engine.management.TablePage;
import org.activiti.engine.repository.Deployment;
import org.activiti.engine.repository.Model;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.Execution;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.runtime.ProcessInstance;
import org.activiti.engine.task.Task;
import org.apache.ibatis.session.RowBounds;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * @author Tom Baeyens
 */
public class TableDataManager extends AbstractManager {
  
  private static Logger log = LoggerFactory.getLogger(TableDataManager.class);
  
  public static Map<Class<?>, String> apiTypeToTableNameMap = new HashMap<Class<?>, String>();
  public static Map<Class<? extends PersistentObject>, String> persistentObjectToTableNameMap = new HashMap<Class<? extends PersistentObject>, String>();
  
  static {
    // runtime
    persistentObjectToTableNameMap.put(TaskEntity.class, "ACT_RU_TASK");
    persistentObjectToTableNameMap.put(ExecutionEntity.class, "ACT_RU_EXECUTION");
    persistentObjectToTableNameMap.put(IdentityLinkEntity.class, "ACT_RU_IDENTITYLINK");
    persistentObjectToTableNameMap.put(VariableInstanceEntity.class, "ACT_RU_VARIABLE");
    
    persistentObjectToTableNameMap.put(JobEntity.class, "ACT_RU_JOB");
    persistentObjectToTableNameMap.put(MessageEntity.class, "ACT_RU_JOB");
    persistentObjectToTableNameMap.put(TimerEntity.class, "ACT_RU_JOB");
    
    persistentObjectToTableNameMap.put(EventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");
    persistentObjectToTableNameMap.put(CompensateEventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");    
    persistentObjectToTableNameMap.put(MessageEventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");    
    persistentObjectToTableNameMap.put(SignalEventSubscriptionEntity.class, "ACT_RU_EVENT_SUBSCR");
        
    // repository
    persistentObjectToTableNameMap.put(DeploymentEntity.class, "ACT_RE_DEPLOYMENT");
    persistentObjectToTableNameMap.put(ProcessDefinitionEntity.class, "ACT_RE_PROCDEF");
    persistentObjectToTableNameMap.put(ModelEntity.class, "ACT_RE_MODEL");
    
    // history
    persistentObjectToTableNameMap.put(CommentEntity.class, "ACT_HI_COMMENT");
    
    persistentObjectToTableNameMap.put(HistoricActivityInstanceEntity.class, "ACT_HI_ACTINST");
    persistentObjectToTableNameMap.put(AttachmentEntity.class, "ACT_HI_ATTACHMEN");
    persistentObjectToTableNameMap.put(HistoricProcessInstanceEntity.class, "ACT_HI_PROCINST");
    persistentObjectToTableNameMap.put(HistoricVariableInstanceEntity.class, "ACT_HI_VARINST");
    persistentObjectToTableNameMap.put(HistoricTaskInstanceEntity.class, "ACT_HI_TASKINST");
    persistentObjectToTableNameMap.put(HistoricIdentityLinkEntity.class, "ACT_HI_IDENTITYLINK");
    
    // a couple of stuff goes to the same table
    persistentObjectToTableNameMap.put(HistoricDetailAssignmentEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricDetailTransitionInstanceEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricFormPropertyEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricDetailVariableInstanceUpdateEntity.class, "ACT_HI_DETAIL");
    persistentObjectToTableNameMap.put(HistoricDetailEntity.class, "ACT_HI_DETAIL");
    
    
    // Identity module
    persistentObjectToTableNameMap.put(GroupEntity.class, "ACT_ID_GROUP");
    persistentObjectToTableNameMap.put(MembershipEntity.class, "ACT_ID_MEMBERSHIP");
    persistentObjectToTableNameMap.put(UserEntity.class, "ACT_ID_USER");
    persistentObjectToTableNameMap.put(IdentityInfoEntity.class, "ACT_ID_INFO");
    
    // general
    persistentObjectToTableNameMap.put(PropertyEntity.class, "ACT_GE_PROPERTY");
    persistentObjectToTableNameMap.put(ByteArrayEntity.class, "ACT_GE_BYTEARRAY");
    persistentObjectToTableNameMap.put(ResourceEntity.class, "ACT_GE_BYTEARRAY");
    
    // and now the map for the API types (does not cover all cases)
    apiTypeToTableNameMap.put(Task.class, "ACT_RU_TASK");
    apiTypeToTableNameMap.put(Execution.class, "ACT_RU_EXECUTION");
    apiTypeToTableNameMap.put(ProcessInstance.class, "ACT_RU_EXECUTION");
    apiTypeToTableNameMap.put(ProcessDefinition.class, "ACT_RE_PROCDEF");
    apiTypeToTableNameMap.put(Deployment.class, "ACT_RE_DEPLOYMENT");    
    apiTypeToTableNameMap.put(Job.class, "ACT_RU_JOB");
    apiTypeToTableNameMap.put(Model.class, "ACT_RE_MODEL");
    
    // history
    apiTypeToTableNameMap.put(HistoricProcessInstance.class, "ACT_HI_PROCINST");
    apiTypeToTableNameMap.put(HistoricActivityInstance.class, "ACT_HI_ACTINST");
    apiTypeToTableNameMap.put(HistoricDetail.class, "ACT_HI_DETAIL");
    apiTypeToTableNameMap.put(HistoricVariableUpdate.class, "ACT_HI_DETAIL");
    apiTypeToTableNameMap.put(HistoricFormProperty.class, "ACT_HI_DETAIL");
    apiTypeToTableNameMap.put(HistoricTaskInstance.class, "ACT_HI_TASKINST");        
    apiTypeToTableNameMap.put(HistoricVariableInstance.class, "ACT_HI_VARINST");

    // identity
    apiTypeToTableNameMap.put(Group.class, "ACT_ID_GROUP");
    apiTypeToTableNameMap.put(User.class, "ACT_ID_USER");

    // TODO: Identity skipped for the moment as no SQL injection is provided here
  }

  public Map<String, Long> getTableCount() {
    Map<String, Long> tableCount = new HashMap<String, Long>();
    try {
      for (String tableName: getTablesPresentInDatabase()) {
        tableCount.put(tableName, getTableCount(tableName));
      }
      log.debug("Number of rows per activiti table: {}", tableCount);
    } catch (Exception e) {
      throw new ActivitiException("couldn't get table counts", e);
    }
    return tableCount;
  }

  public List<String> getTablesPresentInDatabase() {
    List<String> tableNames = new ArrayList<String>();
    Connection connection = null;
    try {
      connection = getDbSqlSession().getSqlSession().getConnection();
      DatabaseMetaData databaseMetaData = connection.getMetaData();
      ResultSet tables = null;
      try {
        log.debug("retrieving activiti tables from jdbc metadata");
        String databaseTablePrefix = getDbSqlSession().getDbSqlSessionFactory().getDatabaseTablePrefix();
        String tableNameFilter = databaseTablePrefix+"ACT_%";
        if ("postgres".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          tableNameFilter = databaseTablePrefix+"act\\_%";
        }
        if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          tableNameFilter = databaseTablePrefix+"ACT" + databaseMetaData.getSearchStringEscape() + "_%";
        }
        
        String catalog = null;
        if (getProcessEngineConfiguration().getDatabaseCatalog() != null && getProcessEngineConfiguration().getDatabaseCatalog().length() > 0) {
          catalog = getProcessEngineConfiguration().getDatabaseCatalog();
        }
        
        String schema = null;
        if (getProcessEngineConfiguration().getDatabaseSchema() != null && getProcessEngineConfiguration().getDatabaseSchema().length() > 0) {
          if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
            schema = getProcessEngineConfiguration().getDatabaseSchema().toUpperCase();
          } else {
            schema = getProcessEngineConfiguration().getDatabaseSchema();
          }
        }
        
        tables = databaseMetaData.getTables(catalog, schema, tableNameFilter, getDbSqlSession().JDBC_METADATA_TABLE_TYPES);
        while (tables.next()) {
          String tableName = tables.getString("TABLE_NAME");
          tableName = tableName.toUpperCase();
          tableNames.add(tableName);
          log.debug("  retrieved activiti table name {}", tableName);
        }
      } finally {
        tables.close();
      }
    } catch (Exception e) {
      throw new ActivitiException("couldn't get activiti table names using metadata: "+e.getMessage(), e); 
    }
    return tableNames;
  }

  protected long getTableCount(String tableName) {
    log.debug("selecting table count for {}", tableName);
    Long count = (Long) getDbSqlSession().selectOne("selectTableCount",
            Collections.singletonMap("tableName", tableName));
    return count;
  }

  @SuppressWarnings("unchecked")
  public TablePage getTablePage(TablePageQueryImpl tablePageQuery, int firstResult, int maxResults) {

    TablePage tablePage = new TablePage();

    @SuppressWarnings("rawtypes")
    List tableData = getDbSqlSession().getSqlSession()
      .selectList("selectTableData", tablePageQuery, new RowBounds(firstResult, maxResults));

    tablePage.setTableName(tablePageQuery.getTableName());
    tablePage.setTotal(getTableCount(tablePageQuery.getTableName()));
    tablePage.setRows((List<Map<String,Object>>)tableData);
    tablePage.setFirstResult(firstResult);
    
    return tablePage;
  }
  
  public String getTableName(Class<?> entityClass, boolean withPrefix) {
    String databaseTablePrefix = getDbSqlSession().getDbSqlSessionFactory().getDatabaseTablePrefix();
    String tableName = null;
    
    if (PersistentObject.class.isAssignableFrom(entityClass)) {
      tableName = persistentObjectToTableNameMap.get(entityClass);
    }
    else {
      tableName = apiTypeToTableNameMap.get(entityClass);
    }
    if (withPrefix) {
      return databaseTablePrefix + tableName;
    }
    else {
      return tableName;
    }
  }

  public TableMetaData getTableMetaData(String tableName) {
    TableMetaData result = new TableMetaData();
    try {
      result.setTableName(tableName);
      DatabaseMetaData metaData = getDbSqlSession()
        .getSqlSession()
        .getConnection()
        .getMetaData();

      if ("postgres".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
        tableName = tableName.toLowerCase();
      }
      
      String catalog = null;
      if (getProcessEngineConfiguration().getDatabaseCatalog() != null && getProcessEngineConfiguration().getDatabaseCatalog().length() > 0) {
        catalog = getProcessEngineConfiguration().getDatabaseCatalog();
      }
      
      String schema = null;
      if (getProcessEngineConfiguration().getDatabaseSchema() != null && getProcessEngineConfiguration().getDatabaseSchema().length() > 0) {
        if ("oracle".equals(getDbSqlSession().getDbSqlSessionFactory().getDatabaseType())) {
          schema = getProcessEngineConfiguration().getDatabaseSchema().toUpperCase();
        } else {
          schema = getProcessEngineConfiguration().getDatabaseSchema();
        }
      }

      ResultSet resultSet = metaData.getColumns(catalog, schema, tableName, null);
      while(resultSet.next()) {
        boolean wrongSchema = false;
        if (schema != null && schema.length() > 0) {
          for (int i = 0; i < resultSet.getMetaData().getColumnCount(); i++) {
            String columnName = resultSet.getMetaData().getColumnName(i+1);
            if ("TABLE_SCHEM".equalsIgnoreCase(columnName) || "TABLE_SCHEMA".equalsIgnoreCase(columnName)) {
              if (schema.equalsIgnoreCase(resultSet.getString(resultSet.getMetaData().getColumnName(i+1))) == false) {
                wrongSchema = true;
              }
              break;
            }
          }
        }
        
        if (wrongSchema == false) {
          String name = resultSet.getString("COLUMN_NAME").toUpperCase();
          String type = resultSet.getString("TYPE_NAME").toUpperCase();
          result.addColumnMetaData(name, type);
        }
      }
      
    } catch (SQLException e) {
      throw new ActivitiException("Could not retrieve database metadata: " + e.getMessage());
    }

    if(result.getColumnNames().isEmpty()) {
      // According to API, when a table doesn't exist, null should be returned
      result = null;
    }
    return result;
  }

}
!@#$%
20190526_171606,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.persistence.entity;

import java.util.Date;

import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.impl.db.HasRevision;
import org.activiti.engine.impl.variable.ValueFields;
import org.activiti.engine.impl.variable.VariableType;

/**
 * @author Christian Lipphardt (camunda)
 * @author Joram Barrez
 */
public interface HistoricVariableInstanceEntity extends ValueFields, HistoricVariableInstance, Entity, HasRevision {

  VariableType getVariableType();

  void setName(String name);

  void setVariableType(VariableType variableType);

  void setProcessInstanceId(String processInstanceId);

  void setTaskId(String taskId);

  void setCreateTime(Date createTime);

  void setLastUpdatedTime(Date lastUpdatedTime);

  String getExecutionId();

  void setExecutionId(String executionId);

  ByteArrayRef getByteArrayRef();
  
}
!@#$%
20190526_171606,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.persistence.entity;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;

import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.db.BulkDeleteable;
import org.activiti.engine.impl.db.HasRevision;
import org.activiti.engine.impl.db.PersistentObject;
import org.activiti.engine.impl.variable.ValueFields;
import org.activiti.engine.impl.variable.VariableType;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Christian Lipphardt (camunda)
 * @author Joram Barrez
 */
public class HistoricVariableInstanceEntity implements ValueFields, HistoricVariableInstance, PersistentObject, HasRevision, BulkDeleteable, Serializable {

  private static final long serialVersionUID = 1L;

  protected String id;
  protected int revision;

  protected String name;
  protected VariableType variableType;

  protected String processInstanceId;
  protected String executionId;
  protected String taskId;
  
  protected Date createTime;
  protected Date lastUpdatedTime;
  
  protected Long longValue;
  protected Double doubleValue;
  protected String textValue;
  protected String textValue2;
  protected final ByteArrayRef byteArrayRef = new ByteArrayRef();

  protected Object cachedValue;

  // Default constructor for SQL mapping
  protected HistoricVariableInstanceEntity() {
  }

  public static HistoricVariableInstanceEntity copyAndInsert(VariableInstanceEntity variableInstance) {
    HistoricVariableInstanceEntity historicVariableInstance = new HistoricVariableInstanceEntity();
    historicVariableInstance.id = variableInstance.getId();
    historicVariableInstance.processInstanceId = variableInstance.getProcessInstanceId();
    historicVariableInstance.executionId = variableInstance.getExecutionId();
    historicVariableInstance.taskId = variableInstance.getTaskId();
    historicVariableInstance.revision = variableInstance.getRevision();
    historicVariableInstance.name = variableInstance.getName();
    historicVariableInstance.variableType = variableInstance.getType();
    
    historicVariableInstance.copyValue(variableInstance);
    
    Date time = Context.getProcessEngineConfiguration().getClock().getCurrentTime();
    historicVariableInstance.setCreateTime(time);
    historicVariableInstance.setLastUpdatedTime(time);
    
    Context.getCommandContext()
      .getDbSqlSession()
      .insert(historicVariableInstance);
    
    return historicVariableInstance;
  }
  
  public void copyValue(VariableInstanceEntity variableInstance) {
    this.textValue = variableInstance.getTextValue();
    this.textValue2 = variableInstance.getTextValue2();
    this.doubleValue = variableInstance.getDoubleValue();
    this.longValue = variableInstance.getLongValue();
    
    this.variableType = variableInstance.getType();
    if (variableInstance.getByteArrayValueId()!=null) {
      setByteArrayValue(variableInstance.getByteArrayValue().getBytes());
    }
    
    this.lastUpdatedTime = Context.getProcessEngineConfiguration().getClock().getCurrentTime();
  }

  public void delete() {
    Context
      .getCommandContext()
      .getDbSqlSession()
      .delete(this);
    
    byteArrayRef.delete();
  }

  public Object getPersistentState() {
  	HashMap<String, Object> persistentState = new HashMap<String, Object>();
  	
  	persistentState.put("textValue", textValue);
  	persistentState.put("textValue2", textValue2);
  	persistentState.put("doubleValue", doubleValue);
  	persistentState.put("longValue", longValue);
  	persistentState.put("byteArrayRef", byteArrayRef.getId());
  	
  	persistentState.put("createTime", createTime);
  	persistentState.put("lastUpdatedTime", lastUpdatedTime);
  	
  	return persistentState;
  }
  
  public int getRevisionNext() {
    return revision+1;
  }

  public Object getValue() {
    if (!variableType.isCachable() || cachedValue == null) {
      cachedValue = variableType.getValue(this);
    }
    return cachedValue;
  }
  
  // byte array value /////////////////////////////////////////////////////////
  
  @Override
  public byte[] getBytes() {
    return byteArrayRef.getBytes();
  }

  @Override
  public void setBytes(byte[] bytes) {
    byteArrayRef.setValue("hist.var-" + name, bytes);
  }
  
  @Override @Deprecated
  public ByteArrayEntity getByteArrayValue() {
    return byteArrayRef.getEntity();
  }
  
  @Override @Deprecated
  public String getByteArrayValueId() {
    return byteArrayRef.getId();
  }

  @Override @Deprecated
  public void setByteArrayValue(byte[] bytes) {
    setBytes(bytes);
  }

  // getters and setters //////////////////////////////////////////////////////

  public String getId() {
    return id;
  }
  
  public void setId(String id) {
    this.id = id;
  }

  public String getVariableTypeName() {
    return (variableType != null ? variableType.getTypeName() : null);
  }

  public String getVariableName() {
    return name;
  }

  public VariableType getVariableType() {
    return variableType;
  }

  public int getRevision() {
    return revision;
  }

  public void setRevision(int revision) {
    this.revision = revision;
  }

  public String getName() {
    return name;
  }

  public Long getLongValue() {
    return longValue;
  }

  public void setLongValue(Long longValue) {
    this.longValue = longValue;
  }

  public Double getDoubleValue() {
    return doubleValue;
  }

  public void setDoubleValue(Double doubleValue) {
    this.doubleValue = doubleValue;
  }

  public String getTextValue() {
    return textValue;
  }

  public void setTextValue(String textValue) {
    this.textValue = textValue;
  }

  public String getTextValue2() {
    return textValue2;
  }

  public void setTextValue2(String textValue2) {
    this.textValue2 = textValue2;
  }

  public Object getCachedValue() {
    return cachedValue;
  }

  public void setCachedValue(Object cachedValue) {
    this.cachedValue = cachedValue;
  }

  public void setVariableType(VariableType variableType) {
    this.variableType = variableType;
  }

  public void setProcessInstanceId(String processInstanceId) {
    this.processInstanceId = processInstanceId;
  }

  public String getProcessInstanceId() {
    return processInstanceId;
  }

  public String getTaskId() {
    return taskId;
  }

  public void setTaskId(String taskId) {
    this.taskId = taskId;
  }
  
  public Date getCreateTime() {
		return createTime;
	}

	public void setCreateTime(Date createTime) {
		this.createTime = createTime;
	}

	public Date getLastUpdatedTime() {
		return lastUpdatedTime;
	}

	public void setLastUpdatedTime(Date lastUpdatedTime) {
		this.lastUpdatedTime = lastUpdatedTime;
	}

	public String getExecutionId() {
    return executionId;
  }
  
  public void setExecutionId(String executionId) {
    this.executionId = executionId;
  }
  
  public Date getTime() {
    return getCreateTime();
  }

  // common methods  //////////////////////////////////////////////////////////

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("HistoricVariableInstanceEntity[");
    sb.append("id=").append(id);
    sb.append(", name=").append(name);
    sb.append(", revision=").append(revision);
    sb.append(", type=").append(variableType != null ? variableType.getTypeName() : "null");
    if (longValue != null) {
      sb.append(", longValue=").append(longValue);
    }
    if (doubleValue != null) {
      sb.append(", doubleValue=").append(doubleValue);
    }
    if (textValue != null) {
      sb.append(", textValue=").append(StringUtils.abbreviate(textValue, 40));
    }
    if (textValue2 != null) {
      sb.append(", textValue2=").append(StringUtils.abbreviate(textValue2, 40));
    }
    if (byteArrayRef.getId() != null) {
      sb.append(", byteArrayValueId=").append(byteArrayRef.getId());
    }
    sb.append("]");
    return sb.toString();
  }
  
}
!@#$%
20190526_171606,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.persistence.entity;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;

import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.db.BulkDeleteable;
import org.activiti.engine.impl.db.HasRevision;
import org.activiti.engine.impl.db.PersistentObject;
import org.activiti.engine.impl.variable.ValueFields;
import org.activiti.engine.impl.variable.VariableType;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Christian Lipphardt (camunda)
 * @author Joram Barrez
 */
public class HistoricVariableInstanceEntity implements ValueFields, HistoricVariableInstance, PersistentObject, HasRevision, BulkDeleteable, Serializable {

  private static final long serialVersionUID = 1L;

  protected String id;
  protected int revision;

  protected String name;
  protected VariableType variableType;

  protected String processInstanceId;
  protected String executionId;
  protected String taskId;
  
  protected Date createTime;
  protected Date lastUpdatedTime;
  
  protected Long longValue;
  protected Double doubleValue;
  protected String textValue;
  protected String textValue2;
  protected final ByteArrayRef byteArrayRef = new ByteArrayRef();

  protected Object cachedValue;

  // Default constructor for SQL mapping
  protected HistoricVariableInstanceEntity() {
  }

  public static HistoricVariableInstanceEntity copyAndInsert(VariableInstanceEntity variableInstance) {
    HistoricVariableInstanceEntity historicVariableInstance = new HistoricVariableInstanceEntity();
    historicVariableInstance.id = variableInstance.getId();
    historicVariableInstance.processInstanceId = variableInstance.getProcessInstanceId();
    historicVariableInstance.executionId = variableInstance.getExecutionId();
    historicVariableInstance.taskId = variableInstance.getTaskId();
    historicVariableInstance.revision = variableInstance.getRevision();
    historicVariableInstance.name = variableInstance.getName();
    historicVariableInstance.variableType = variableInstance.getType();
    
    historicVariableInstance.copyValue(variableInstance);
    
    Date time = Context.getProcessEngineConfiguration().getClock().getCurrentTime();
    historicVariableInstance.setCreateTime(time);
    historicVariableInstance.setLastUpdatedTime(time);
    
    Context.getCommandContext()
      .getDbSqlSession()
      .insert(historicVariableInstance);
    
    return historicVariableInstance;
  }
  
  public void copyValue(VariableInstanceEntity variableInstance) {
    this.textValue = variableInstance.getTextValue();
    this.textValue2 = variableInstance.getTextValue2();
    this.doubleValue = variableInstance.getDoubleValue();
    this.longValue = variableInstance.getLongValue();
    
    this.variableType = variableInstance.getType();
    if (variableInstance.getByteArrayValueId()!=null) {
      setByteArrayValue(variableInstance.getByteArrayValue().getBytes());
    }
    
    this.lastUpdatedTime = Context.getProcessEngineConfiguration().getClock().getCurrentTime();
  }

  public void delete() {
    Context
      .getCommandContext()
      .getDbSqlSession()
      .delete(this);
    
    byteArrayRef.delete();
  }

  public Object getPersistentState() {
  	HashMap<String, Object> persistentState = new HashMap<String, Object>();
  	
  	persistentState.put("textValue", textValue);
  	persistentState.put("textValue2", textValue2);
  	persistentState.put("doubleValue", doubleValue);
  	persistentState.put("longValue", longValue);
  	persistentState.put("byteArrayRef", byteArrayRef.getId());
  	persistentState.put("createTime", createTime);
  	persistentState.put("lastUpdatedTime", lastUpdatedTime);
  	
  	return persistentState;
  }
  
  public int getRevisionNext() {
    return revision+1;
  }

  public Object getValue() {
    if (!variableType.isCachable() || cachedValue == null) {
      cachedValue = variableType.getValue(this);
    }
    return cachedValue;
  }
  
  // byte array value /////////////////////////////////////////////////////////
  
  @Override
  public byte[] getBytes() {
    return byteArrayRef.getBytes();
  }

  @Override
  public void setBytes(byte[] bytes) {
    byteArrayRef.setValue("hist.var-" + name, bytes);
  }
  
  @Override @Deprecated
  public ByteArrayEntity getByteArrayValue() {
    return byteArrayRef.getEntity();
  }
  
  @Override @Deprecated
  public String getByteArrayValueId() {
    return byteArrayRef.getId();
  }

  @Override @Deprecated
  public void setByteArrayValue(byte[] bytes) {
    setBytes(bytes);
  }

  // getters and setters //////////////////////////////////////////////////////

  public String getId() {
    return id;
  }
  
  public void setId(String id) {
    this.id = id;
  }

  public String getVariableTypeName() {
    return (variableType != null ? variableType.getTypeName() : null);
  }

  public String getVariableName() {
    return name;
  }

  public VariableType getVariableType() {
    return variableType;
  }

  public int getRevision() {
    return revision;
  }

  public void setRevision(int revision) {
    this.revision = revision;
  }

  public String getName() {
    return name;
  }

  public Long getLongValue() {
    return longValue;
  }

  public void setLongValue(Long longValue) {
    this.longValue = longValue;
  }

  public Double getDoubleValue() {
    return doubleValue;
  }

  public void setDoubleValue(Double doubleValue) {
    this.doubleValue = doubleValue;
  }

  public String getTextValue() {
    return textValue;
  }

  public void setTextValue(String textValue) {
    this.textValue = textValue;
  }

  public String getTextValue2() {
    return textValue2;
  }

  public void setTextValue2(String textValue2) {
    this.textValue2 = textValue2;
  }

  public Object getCachedValue() {
    return cachedValue;
  }

  public void setCachedValue(Object cachedValue) {
    this.cachedValue = cachedValue;
  }

  public void setVariableType(VariableType variableType) {
    this.variableType = variableType;
  }

  public void setProcessInstanceId(String processInstanceId) {
    this.processInstanceId = processInstanceId;
  }

  public String getProcessInstanceId() {
    return processInstanceId;
  }

  public String getTaskId() {
    return taskId;
  }

  public void setTaskId(String taskId) {
    this.taskId = taskId;
  }
  
  public Date getCreateTime() {
		return createTime;
	}

	public void setCreateTime(Date createTime) {
		this.createTime = createTime;
	}

	public Date getLastUpdatedTime() {
		return lastUpdatedTime;
	}

	public void setLastUpdatedTime(Date lastUpdatedTime) {
		this.lastUpdatedTime = lastUpdatedTime;
	}

	public String getExecutionId() {
    return executionId;
  }
  
  public void setExecutionId(String executionId) {
    this.executionId = executionId;
  }
  
  public Date getTime() {
    return getCreateTime();
  }

  // common methods  //////////////////////////////////////////////////////////

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("HistoricVariableInstanceEntity[");
    sb.append("id=").append(id);
    sb.append(", name=").append(name);
    sb.append(", revision=").append(revision);
    sb.append(", type=").append(variableType != null ? variableType.getTypeName() : "null");
    if (longValue != null) {
      sb.append(", longValue=").append(longValue);
    }
    if (doubleValue != null) {
      sb.append(", doubleValue=").append(doubleValue);
    }
    if (textValue != null) {
      sb.append(", textValue=").append(StringUtils.abbreviate(textValue, 40));
    }
    if (textValue2 != null) {
      sb.append(", textValue2=").append(StringUtils.abbreviate(textValue2, 40));
    }
    if (byteArrayRef.getId() != null) {
      sb.append(", byteArrayValueId=").append(byteArrayRef.getId());
    }
    sb.append("]");
    return sb.toString();
  }
  
}
!@#$%
20190526_171621,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.persistence.deploy;

import com.fasterxml.jackson.databind.node.ObjectNode;

/**
 * @author Tijs Rademakers
 */
public class ProcessDefinitionInfoCacheObject {
  
  protected String id;
  protected int revision;
  protected ObjectNode infoNode;
  
  public String getId() {
    return id;
  }
  
  public void setId(String id) {
    this.id = id;
  }
  
  public int getRevision() {
    return revision;
  }
  
  public void setRevision(int revision) {
    this.revision = revision;
  }
  
  public ObjectNode getInfoNode() {
    return infoNode;
  }
  
  public void setInfoNode(ObjectNode infoNode) {
    this.infoNode = infoNode;
  }
}
!@#$%
20190526_171621,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.persistence.deploy;

import com.fasterxml.jackson.databind.node.ObjectNode;

/**
 * @author Tijs Rademakers
 */
public class ProcessDefinitionInfoCacheObject {
  
  protected String id;
  protected int revision;
  protected ObjectNode infoNode;
  
  public String getId() {
    return id;
  }
  
  public void setId(String id) {
    this.id = id;
  }
  
  public int getRevision() {
    return revision;
  }
  
  public void setRevision(int revision) {
    this.revision = revision;
  }
  
  public ObjectNode getInfoNode() {
    return infoNode;
  }
  
  public void setInfoNode(ObjectNode infoNode) {
    this.infoNode = infoNode;
  }
}
!@#$%
20190526_171631,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.engine.impl.interceptor;

import org.activiti.engine.impl.cfg.TransactionPropagation;

/**
 * Configuration settings for the command interceptor chain.
 * 
 * Instances of this class are immutable, and thus thread- and share-safe.
 * 
 * @author Marcus Klimstra (CGI)
 */
public class CommandConfig {

  private boolean contextReusePossible;
  private TransactionPropagation propagation;

  public CommandConfig() {
    this.contextReusePossible = true;
    this.propagation = TransactionPropagation.REQUIRED;
  }

  public CommandConfig(boolean contextReusePossible) {
    this.contextReusePossible = contextReusePossible;
    this.propagation = TransactionPropagation.REQUIRED;
  }
  
  public CommandConfig(boolean contextReusePossible, TransactionPropagation transactionPropagation) {
    this.contextReusePossible = contextReusePossible;
    this.propagation = transactionPropagation;
  }

  protected CommandConfig(CommandConfig commandConfig) {
    this.contextReusePossible = commandConfig.contextReusePossible;
    this.propagation = commandConfig.propagation;
  }

  public boolean isContextReusePossible() {
    return contextReusePossible;
  }

  public TransactionPropagation getTransactionPropagation() {
    return propagation;
  }

  public CommandConfig setContextReusePossible(boolean contextReusePossible) {
    CommandConfig config = new CommandConfig(this);
    config.contextReusePossible = contextReusePossible;
    return config;
  }

  public CommandConfig transactionRequired() {
    CommandConfig config = new CommandConfig(this);
    config.propagation = TransactionPropagation.REQUIRED;
    return config;
  }

  public CommandConfig transactionRequiresNew() {
    CommandConfig config = new CommandConfig();
    config.contextReusePossible = false;
    config.propagation = TransactionPropagation.REQUIRES_NEW;
    return config;
  }

  public CommandConfig transactionNotSupported() {
    CommandConfig config = new CommandConfig();
    config.contextReusePossible = false;
    config.propagation = TransactionPropagation.NOT_SUPPORTED;
    return config;
  }
}
!@#$%
20190526_171631,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.engine.impl.interceptor;

import org.activiti.engine.impl.cfg.TransactionPropagation;

/**
 * Configuration settings for the command interceptor chain.
 * 
 * Instances of this class are immutable, and thus thread- and share-safe.
 * 
 * @author Marcus Klimstra (CGI)
 */
public class CommandConfig {

  private boolean contextReusePossible;
  private TransactionPropagation propagation;
  
  public CommandConfig() {
    this.contextReusePossible = true;
    this.propagation = TransactionPropagation.REQUIRED;
  }
  
  public CommandConfig(boolean contextReusePossible) {
    this.contextReusePossible = contextReusePossible;
    this.propagation = TransactionPropagation.REQUIRED;
  }
  
  protected CommandConfig(CommandConfig commandConfig) {
    this.contextReusePossible = commandConfig.contextReusePossible;
    this.propagation = commandConfig.propagation;
  }

  public boolean isContextReusePossible() {
    return contextReusePossible;
  }
  
  public TransactionPropagation getTransactionPropagation() {
    return propagation;
  }

  public CommandConfig setContextReusePossible(boolean contextReusePossible) {
    CommandConfig config = new CommandConfig(this);
    config.contextReusePossible = contextReusePossible;
    return config;
  }
  
  public CommandConfig transactionRequired() {
    CommandConfig config = new CommandConfig(this);
    config.propagation = TransactionPropagation.REQUIRED;
    return config;
  }

  public CommandConfig transactionRequiresNew() {
    CommandConfig config = new CommandConfig();
    config.contextReusePossible = false;
    config.propagation = TransactionPropagation.REQUIRES_NEW;
    return config;
  }

  public CommandConfig transactionNotSupported() {
    CommandConfig config = new CommandConfig();
    config.contextReusePossible = false;
    config.propagation = TransactionPropagation.NOT_SUPPORTED;
    return config;
  }
}
!@#$%
20190526_171631,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.engine.impl.interceptor;

import org.activiti.engine.impl.cfg.TransactionPropagation;

/**
 * Configuration settings for the command interceptor chain.
 * 
 * Instances of this class are immutable, and thus thread- and share-safe.
 * 
 * @author Marcus Klimstra (CGI)
 */
public class CommandConfig {

  private boolean contextReusePossible;
  private TransactionPropagation propagation;
  
  public CommandConfig() {
    this.contextReusePossible = true;
    this.propagation = TransactionPropagation.REQUIRED;
  }
  
  public CommandConfig(boolean contextReusePossible) {
    this.contextReusePossible = contextReusePossible;
    this.propagation = TransactionPropagation.REQUIRED;
  }
  
  public CommandConfig(boolean contextReusePossible, TransactionPropagation transactionPropagation) {
    this.contextReusePossible = contextReusePossible;
    this.propagation = transactionPropagation;
  }
  
  protected CommandConfig(CommandConfig commandConfig) {
    this.contextReusePossible = commandConfig.contextReusePossible;
    this.propagation = commandConfig.propagation;
  }

  public boolean isContextReusePossible() {
    return contextReusePossible;
  }
  
  public TransactionPropagation getTransactionPropagation() {
    return propagation;
  }

  public CommandConfig setContextReusePossible(boolean contextReusePossible) {
    CommandConfig config = new CommandConfig(this);
    config.contextReusePossible = contextReusePossible;
    return config;
  }
  
  public CommandConfig transactionRequired() {
    CommandConfig config = new CommandConfig(this);
    config.propagation = TransactionPropagation.REQUIRED;
    return config;
  }

  public CommandConfig transactionRequiresNew() {
    CommandConfig config = new CommandConfig();
    config.contextReusePossible = false;
    config.propagation = TransactionPropagation.REQUIRES_NEW;
    return config;
  }

  public CommandConfig transactionNotSupported() {
    CommandConfig config = new CommandConfig();
    config.contextReusePossible = false;
    config.propagation = TransactionPropagation.NOT_SUPPORTED;
    return config;
  }
}
!@#$%
20190526_171645,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.engine.impl.db;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.activiti.engine.impl.persistence.entity.AttachmentEntityImpl;
import org.activiti.engine.impl.persistence.entity.ByteArrayEntityImpl;
import org.activiti.engine.impl.persistence.entity.CommentEntityImpl;
import org.activiti.engine.impl.persistence.entity.CompensateEventSubscriptionEntityImpl;
import org.activiti.engine.impl.persistence.entity.DeadLetterJobEntityImpl;
import org.activiti.engine.impl.persistence.entity.DeploymentEntityImpl;
import org.activiti.engine.impl.persistence.entity.Entity;
import org.activiti.engine.impl.persistence.entity.EventLogEntryEntityImpl;
import org.activiti.engine.impl.persistence.entity.EventSubscriptionEntityImpl;
import org.activiti.engine.impl.persistence.entity.ExecutionEntityImpl;
import org.activiti.engine.impl.persistence.entity.GroupEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricActivityInstanceEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricDetailAssignmentEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricDetailEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricDetailTransitionInstanceEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricDetailVariableInstanceUpdateEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricFormPropertyEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricIdentityLinkEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricScopeInstanceEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricTaskInstanceEntityImpl;
import org.activiti.engine.impl.persistence.entity.HistoricVariableInstanceEntityImpl;
import org.activiti.engine.impl.persistence.entity.IdentityInfoEntityImpl;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntityImpl;
import org.activiti.engine.impl.persistence.entity.JobEntityImpl;
import org.activiti.engine.impl.persistence.entity.MembershipEntityImpl;
import org.activiti.engine.impl.persistence.entity.MessageEventSubscriptionEntityImpl;
import org.activiti.engine.impl.persistence.entity.ModelEntityImpl;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntityImpl;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionInfoEntityImpl;
import org.activiti.engine.impl.persistence.entity.PropertyEntityImpl;
import org.activiti.engine.impl.persistence.entity.ResourceEntityImpl;
import org.activiti.engine.impl.persistence.entity.SignalEventSubscriptionEntityImpl;
import org.activiti.engine.impl.persistence.entity.SuspendedJobEntityImpl;
import org.activiti.engine.impl.persistence.entity.TaskEntityImpl;
import org.activiti.engine.impl.persistence.entity.TimerJobEntityImpl;
import org.activiti.engine.impl.persistence.entity.UserEntityImpl;
import org.activiti.engine.impl.persistence.entity.VariableInstanceEntityImpl;


/**
 * Maintains a list of all the entities in order of dependency.
 */
public class EntityDependencyOrder {
	
	public static List<Class<? extends Entity>> DELETE_ORDER = new ArrayList<Class<? extends Entity>>();
	public static List<Class<? extends Entity>> INSERT_ORDER = new ArrayList<Class<? extends Entity>>();
	
	static {
		
		/*
		 * In the comments below:
		 * 
		 * 'FK to X' : X should be BELOW the entity
		 * 
		 * 'FK from X': X should be ABOVE the entity
		 * 
		 */
	
		/* No FK */
		DELETE_ORDER.add(PropertyEntityImpl.class);
		
		/* No FK */
		DELETE_ORDER.add(AttachmentEntityImpl.class);
		
		/* No FK */
		DELETE_ORDER.add(CommentEntityImpl.class);
		
		/* No FK */
		DELETE_ORDER.add(EventLogEntryEntityImpl.class);
		
		/*
		 * FK to Deployment
		 * FK to ByteArray 
		 */
		DELETE_ORDER.add(ModelEntityImpl.class); 
		
		/*
		 * FK to ByteArray
		 */
		DELETE_ORDER.add(JobEntityImpl.class);
		DELETE_ORDER.add(TimerJobEntityImpl.class);
		DELETE_ORDER.add(SuspendedJobEntityImpl.class);
		DELETE_ORDER.add(DeadLetterJobEntityImpl.class);
		
		/*
		 * FK to ByteArray
		 * FK to Exeution
		 */
		DELETE_ORDER.add(VariableInstanceEntityImpl.class);
		
		/* 
		 * FK to ByteArray
		 * FK to ProcessDefinition
		 */
		DELETE_ORDER.add(ProcessDefinitionInfoEntityImpl.class);
		
		/*
		 * FK from ModelEntity
		 * FK from JobEntity
		 * FK from VariableInstanceEntity
		 * 
		 * FK to DeploymentEntity
		 */
		DELETE_ORDER.add(ByteArrayEntityImpl.class);
		
		/*
		 * FK from ModelEntity
		 * FK from JobEntity
		 * FK from VariableInstanceEntity
		 * 
		 * FK to DeploymentEntity
		 */
		DELETE_ORDER.add(ResourceEntityImpl.class);
		
		/*
		 * FK from ByteArray
		 */
		DELETE_ORDER.add(DeploymentEntityImpl.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(EventSubscriptionEntityImpl.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(CompensateEventSubscriptionEntityImpl.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(MessageEventSubscriptionEntityImpl.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(SignalEventSubscriptionEntityImpl.class);
		
		
		/*
		 * FK to process definition
		 * FK to Execution
		 * FK to Task
		 */
		DELETE_ORDER.add(IdentityLinkEntityImpl.class);
		
		/*
		 * FK from IdentityLink
		 * 
		 * FK to Execution
		 * FK to process definition
		 */
		DELETE_ORDER.add(TaskEntityImpl.class);
		
		/*
		 * FK from VariableInstance 
		 * FK from EventSubscription
		 * FK from IdentityLink
		 * FK from Task
		 * 
		 * FK to ProcessDefinition
		 */
		DELETE_ORDER.add(ExecutionEntityImpl.class);
		
		/*
		 * FK from Task
		 * FK from IdentityLink
		 * FK from execution
		 */
		DELETE_ORDER.add(ProcessDefinitionEntityImpl.class);
		
		/*
	   * FK to User
	   * FK to Group
	   */
		DELETE_ORDER.add(MembershipEntityImpl.class);
		
		/*
		 * Fk from Membership
		 */
		DELETE_ORDER.add(UserEntityImpl.class);
	  
	  /*
	   * FK from Membership
	   */
		DELETE_ORDER.add(GroupEntityImpl.class);
	  
	  
	  // History entities have no FK's
	  
		DELETE_ORDER.add(HistoricIdentityLinkEntityImpl.class);
	  
		DELETE_ORDER.add(IdentityInfoEntityImpl.class);
	  
		DELETE_ORDER.add(HistoricActivityInstanceEntityImpl.class);
		DELETE_ORDER.add(HistoricProcessInstanceEntityImpl.class);
		DELETE_ORDER.add(HistoricTaskInstanceEntityImpl.class);
		DELETE_ORDER.add(HistoricScopeInstanceEntityImpl.class);
	  
		DELETE_ORDER.add(HistoricVariableInstanceEntityImpl.class);
	  
		DELETE_ORDER.add(HistoricDetailAssignmentEntityImpl.class);
		DELETE_ORDER.add(HistoricDetailTransitionInstanceEntityImpl.class);
		DELETE_ORDER.add(HistoricDetailVariableInstanceUpdateEntityImpl.class);
		DELETE_ORDER.add(HistoricFormPropertyEntityImpl.class);
		DELETE_ORDER.add(HistoricDetailEntityImpl.class);
		
		INSERT_ORDER = new ArrayList<Class<? extends Entity>>(DELETE_ORDER);
		Collections.reverse(INSERT_ORDER);

	}

}
!@#$%
20190526_171645,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.engine.impl.db;

import org.activiti.engine.impl.persistence.entity.ByteArrayEntity;
import org.activiti.engine.impl.persistence.entity.DeploymentEntity;
import org.activiti.engine.impl.persistence.entity.EventSubscriptionEntity;
import org.activiti.engine.impl.persistence.entity.ExecutionEntity;
import org.activiti.engine.impl.persistence.entity.GroupEntity;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity;
import org.activiti.engine.impl.persistence.entity.JobEntity;
import org.activiti.engine.impl.persistence.entity.MembershipEntity;
import org.activiti.engine.impl.persistence.entity.ModelEntity;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
import org.activiti.engine.impl.persistence.entity.TaskEntity;
import org.activiti.engine.impl.persistence.entity.UserEntity;
import org.activiti.engine.impl.persistence.entity.VariableInstanceEntity;

/**
 * Maintains a list of all the entities in order of dependency.
 * For eg. If ByteArray.java will appear before VariableInstance.java,
 *      since VariableInstance has ByteArray.id as FK
 */
public enum EntityDependencyOrder {
  DeploymentEntity(DeploymentEntity.class),
  ByteArrayEntity(ByteArrayEntity.class),
  ModelEntity(ModelEntity.class),
  UserEntity(UserEntity.class),
  GroupEntity(GroupEntity.class),
  MembershipEntity(MembershipEntity.class),
  ProcessDefinitionEntity(ProcessDefinitionEntity.class),
  ExecutionEntity(ExecutionEntity.class),
  EventSubscriptionEntity(EventSubscriptionEntity.class),
  TaskEntity(TaskEntity.class),
  IdentityLinkEntity(IdentityLinkEntity.class),
  JobEntity(JobEntity.class),
  VariableInstanceEntity(VariableInstanceEntity.class);

  private Class<? extends PersistentObject> clazz;

  private EntityDependencyOrder(Class<? extends PersistentObject> clazz) {
    this.clazz = clazz;
  }

  public Class<? extends PersistentObject> getClazz() {
    return clazz;
  }

}
!@#$%
20190526_171645,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.engine.impl.db;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.activiti.engine.impl.persistence.entity.AttachmentEntity;
import org.activiti.engine.impl.persistence.entity.ByteArrayEntity;
import org.activiti.engine.impl.persistence.entity.CommentEntity;
import org.activiti.engine.impl.persistence.entity.CompensateEventSubscriptionEntity;
import org.activiti.engine.impl.persistence.entity.DeploymentEntity;
import org.activiti.engine.impl.persistence.entity.EventLogEntryEntity;
import org.activiti.engine.impl.persistence.entity.EventSubscriptionEntity;
import org.activiti.engine.impl.persistence.entity.ExecutionEntity;
import org.activiti.engine.impl.persistence.entity.GroupEntity;
import org.activiti.engine.impl.persistence.entity.HistoricActivityInstanceEntity;
import org.activiti.engine.impl.persistence.entity.HistoricDetailAssignmentEntity;
import org.activiti.engine.impl.persistence.entity.HistoricDetailEntity;
import org.activiti.engine.impl.persistence.entity.HistoricDetailTransitionInstanceEntity;
import org.activiti.engine.impl.persistence.entity.HistoricDetailVariableInstanceUpdateEntity;
import org.activiti.engine.impl.persistence.entity.HistoricFormPropertyEntity;
import org.activiti.engine.impl.persistence.entity.HistoricIdentityLinkEntity;
import org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntity;
import org.activiti.engine.impl.persistence.entity.HistoricScopeInstanceEntity;
import org.activiti.engine.impl.persistence.entity.HistoricTaskInstanceEntity;
import org.activiti.engine.impl.persistence.entity.HistoricVariableInstanceEntity;
import org.activiti.engine.impl.persistence.entity.IdentityInfoEntity;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity;
import org.activiti.engine.impl.persistence.entity.JobEntity;
import org.activiti.engine.impl.persistence.entity.MembershipEntity;
import org.activiti.engine.impl.persistence.entity.MessageEntity;
import org.activiti.engine.impl.persistence.entity.MessageEventSubscriptionEntity;
import org.activiti.engine.impl.persistence.entity.ModelEntity;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
import org.activiti.engine.impl.persistence.entity.PropertyEntity;
import org.activiti.engine.impl.persistence.entity.ResourceEntity;
import org.activiti.engine.impl.persistence.entity.SignalEventSubscriptionEntity;
import org.activiti.engine.impl.persistence.entity.TaskEntity;
import org.activiti.engine.impl.persistence.entity.TimerEntity;
import org.activiti.engine.impl.persistence.entity.UserEntity;
import org.activiti.engine.impl.persistence.entity.VariableInstanceEntity;


/**
 * Maintains a list of all the entities in order of dependency.
 */
public class EntityDependencyOrder {
	
	public static List<Class<? extends PersistentObject>> DELETE_ORDER = new ArrayList<Class<? extends PersistentObject>>();
	public static List<Class<? extends PersistentObject>> INSERT_ORDER = new ArrayList<Class<? extends PersistentObject>>();
	
	static {
		
		/*
		 * In the comments below:
		 * 
		 * 'FK to X' : X should be BELOW the entity
		 * 
		 * 'FK from X': X should be ABOVE the entity
		 * 
		 */
	
		/* No FK */
		DELETE_ORDER.add(PropertyEntity.class);
		
		/* No FK */
		DELETE_ORDER.add(AttachmentEntity.class);
		
		/* No FK */
		DELETE_ORDER.add(CommentEntity.class);
		
		/* No FK */
		DELETE_ORDER.add(EventLogEntryEntity.class);
		
		/*
		 * FK to Deployment
		 * FK to ByteArray 
		 */
		DELETE_ORDER.add(ModelEntity.class); 
		
		/* Subclass of JobEntity */
		DELETE_ORDER.add(MessageEntity.class);
		
		/* Subclass of TimerEntity */
		DELETE_ORDER.add(TimerEntity.class);
		
		/*
		 * FK to ByteArray
		 */
		DELETE_ORDER.add(JobEntity.class);
		
		/*
		 * FK to ByteArray
		 * FK to Exeution
		 */
		DELETE_ORDER.add(VariableInstanceEntity.class);
		
		/*
		 * FK from ModelEntity
		 * FK from JobEntity
		 * FK from VariableInstanceEntity
		 * 
		 * FK to DeploymentEntity
		 */
		DELETE_ORDER.add(ByteArrayEntity.class);
		
		/*
		 * FK from ModelEntity
		 * FK from JobEntity
		 * FK from VariableInstanceEntity
		 * 
		 * FK to DeploymentEntity
		 */
		DELETE_ORDER.add(ResourceEntity.class);
		
		/*
		 * FK from ByteArray
		 */
		DELETE_ORDER.add(DeploymentEntity.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(EventSubscriptionEntity.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(CompensateEventSubscriptionEntity.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(MessageEventSubscriptionEntity.class);
		
		/*
		 * FK to Execution
		 */
		DELETE_ORDER.add(SignalEventSubscriptionEntity.class);
		
		
		/*
		 * FK to process definition
		 * FK to Execution
		 * FK to Task
		 */
		DELETE_ORDER.add(IdentityLinkEntity.class);
		
		/*
		 * FK from IdentityLink
		 * 
		 * FK to Execution
		 * FK to process definition
		 */
		DELETE_ORDER.add(TaskEntity.class);
		
		/*
		 * FK from VariableInstance 
		 * FK from EventSubscription
		 * FK from IdentityLink
		 * FK from Task
		 * 
		 * FK to ProcessDefinition
		 */
		DELETE_ORDER.add(ExecutionEntity.class);
		
		/*
		 * FK from Task
		 * FK from IdentityLink
		 * FK from execution
		 */
		DELETE_ORDER.add(ProcessDefinitionEntity.class);
		
		/*
	   * FK to User
	   * FK to Group
	   */
		DELETE_ORDER.add(MembershipEntity.class);
		
		/*
		 * Fk from Membership
		 */
		DELETE_ORDER.add(UserEntity.class);
	  
	  /*
	   * FK from Membership
	   */
		DELETE_ORDER.add(GroupEntity.class);
	  
	  
	  // History entities have no FK's
	  
		DELETE_ORDER.add(HistoricIdentityLinkEntity.class);
	  
		DELETE_ORDER.add(IdentityInfoEntity.class);
	  
		DELETE_ORDER.add(HistoricActivityInstanceEntity.class);
		DELETE_ORDER.add(HistoricProcessInstanceEntity.class);
		DELETE_ORDER.add(HistoricTaskInstanceEntity.class);
		DELETE_ORDER.add(HistoricScopeInstanceEntity.class);
	  
		DELETE_ORDER.add(HistoricVariableInstanceEntity.class);
	  
		DELETE_ORDER.add(HistoricDetailAssignmentEntity.class);
		DELETE_ORDER.add(HistoricDetailTransitionInstanceEntity.class);
		DELETE_ORDER.add(HistoricDetailVariableInstanceUpdateEntity.class);
		DELETE_ORDER.add(HistoricFormPropertyEntity.class);
		DELETE_ORDER.add(HistoricDetailEntity.class);
		
		INSERT_ORDER = new ArrayList<Class<? extends PersistentObject>>(DELETE_ORDER);
		Collections.reverse(INSERT_ORDER);

	}

}
!@#$%
20190526_171658,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.db;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.impl.cfg.IdGenerator;
import org.activiti.engine.impl.interceptor.CommandContext;
import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.interceptor.SessionFactory;
import org.activiti.engine.impl.persistence.entity.Entity;
import org.activiti.engine.impl.persistence.entity.EventLogEntryEntityImpl;
import org.apache.ibatis.session.SqlSessionFactory;

/**
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class DbSqlSessionFactory implements SessionFactory {
  
  protected static final Map<String, Map<String, String>> databaseSpecificStatements = new HashMap<String, Map<String, String>>();

  /**
   * A map {class, boolean}, to indicate whether or not a certain {@link Entity} class can be bulk inserted.
   */
  protected static Map<Class<? extends Entity>, Boolean> bulkInsertableMap;
  
  protected String databaseType;
  protected String databaseTablePrefix = "";
  private boolean tablePrefixIsSchema;

  protected String databaseCatalog;
  /**
   * In some situations you want to set the schema to use for table checks /
   * generation if the database metadata doesn't return that correctly, see
   * https://activiti.atlassian.net/browse/ACT-1220,
   * https://activiti.atlassian.net/browse/ACT-1062
   */
  protected String databaseSchema;
  protected SqlSessionFactory sqlSessionFactory;
  protected IdGenerator idGenerator;
  protected Map<String, String> statementMappings;
  
  // Caches, filled while executing processes 
  protected Map<Class<?>,String> insertStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String> bulkInsertStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String> updateStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String> deleteStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String> bulkDeleteStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String> selectStatements = new ConcurrentHashMap<Class<?>, String>();
  
  protected boolean isDbIdentityUsed = true;
  protected boolean isDbHistoryUsed = true;
  protected int maxNrOfStatementsInBulkInsert = 100;
  
  public Class<?> getSessionType() {
    return DbSqlSession.class;
  }

  public Session openSession(CommandContext commandContext) {
    DbSqlSession dbSqlSession = new DbSqlSession(this, commandContext.getEntityCache());
    if (getDatabaseSchema() != null && getDatabaseSchema().length() > 0) {
      try {
        dbSqlSession.getSqlSession().getConnection().setSchema(getDatabaseSchema());
      } catch (SQLException e) {
        throw new ActivitiException("Could not set database schema on connection", e);
      }
    }
    if (getDatabaseCatalog() != null && getDatabaseCatalog().length() > 0) {
      try {
        dbSqlSession.getSqlSession().getConnection().setCatalog(getDatabaseCatalog());
      } catch (SQLException e) {
        throw new ActivitiException("Could not set database catalog on connection", e);
      }
    }
    return dbSqlSession;
  }

  // insert, update and delete statements
  // /////////////////////////////////////

  public String getInsertStatement(Entity object) {
    return getStatement(object.getClass(), insertStatements, "insert");
  }
  
  
  public String getInsertStatement(Class<? extends Entity> clazz) {
    return getStatement(clazz, insertStatements, "insert");
  }
  
  @SuppressWarnings("rawtypes")
  public String getBulkInsertStatement(Class clazz) {
    return getStatement(clazz, bulkInsertStatements, "bulkInsert");
  }

  public String getUpdateStatement(Entity object) {
    return getStatement(object.getClass(), updateStatements, "update");
  }

  public String getDeleteStatement(Class<?> entityClass) {
    return getStatement(entityClass, deleteStatements, "delete");
  }

  public String getBulkDeleteStatement(Class<?> entityClass) {
    return getStatement(entityClass, bulkDeleteStatements, "bulkDelete");
  }

  public String getSelectStatement(Class<?> entityClass) {
    return getStatement(entityClass, selectStatements, "select");
  }

  private String getStatement(Class<?> entityClass, Map<Class<?>, String> cachedStatements, String prefix) {
    String statement = cachedStatements.get(entityClass);
    if (statement != null) {
      return statement;
    }
    statement = prefix + entityClass.getSimpleName();
    if (statement.endsWith("Impl")) {
      statement = statement.substring(0, statement.length() - 10); // removing 'entityImpl'
    } else {
      statement = statement.substring(0, statement.length() - 6); // removing 'entity'
    }
    cachedStatements.put(entityClass, statement);
    return statement;
  }

  // db specific mappings
  // /////////////////////////////////////////////////////

  protected static void addDatabaseSpecificStatement(String databaseType, String activitiStatement, String ibatisStatement) {
    Map<String, String> specificStatements = databaseSpecificStatements.get(databaseType);
    if (specificStatements == null) {
      specificStatements = new HashMap<String, String>();
      databaseSpecificStatements.put(databaseType, specificStatements);
    }
    specificStatements.put(activitiStatement, ibatisStatement);
  }

  public String mapStatement(String statement) {
    if (statementMappings == null) {
      return statement;
    }
    String mappedStatement = statementMappings.get(statement);
    return (mappedStatement != null ? mappedStatement : statement);
  }

  // customized getters and setters
  // ///////////////////////////////////////////

  public void setDatabaseType(String databaseType) {
    this.databaseType = databaseType;
    this.statementMappings = databaseSpecificStatements.get(databaseType);
  }
  
  public void setBulkInsertEnabled(boolean isBulkInsertEnabled, String databaseType) {
  	// If false, just keep don't initialize the map. Memory saved.
  	if (isBulkInsertEnabled) {
  		initBulkInsertEnabledMap(databaseType);
  	}
  }
  
  protected void initBulkInsertEnabledMap(String databaseType) {
  	bulkInsertableMap = new HashMap<Class<? extends Entity>, Boolean>();
  	
  	for (Class<? extends Entity> clazz : EntityDependencyOrder.INSERT_ORDER) {
  		bulkInsertableMap.put(clazz, Boolean.TRUE);
  	}

  	// Only Oracle is making a fuss in one specific case right now
		if ("oracle".equals(databaseType)) {
			bulkInsertableMap.put(EventLogEntryEntityImpl.class, Boolean.FALSE);
		}
  }
  
  public Boolean isBulkInsertable(Class<? extends Entity> entityClass) {
  	return bulkInsertableMap != null && bulkInsertableMap.containsKey(entityClass) && bulkInsertableMap.get(entityClass) == true;
  }

  // getters and setters //////////////////////////////////////////////////////
  
  public SqlSessionFactory getSqlSessionFactory() {
    return sqlSessionFactory;
  }

  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }

  public IdGenerator getIdGenerator() {
    return idGenerator;
  }

  public void setIdGenerator(IdGenerator idGenerator) {
    this.idGenerator = idGenerator;
  }

  public String getDatabaseType() {
    return databaseType;
  }

  public Map<String, String> getStatementMappings() {
    return statementMappings;
  }

  public void setStatementMappings(Map<String, String> statementMappings) {
    this.statementMappings = statementMappings;
  }

  public Map<Class<?>, String> getInsertStatements() {
    return insertStatements;
  }

  public void setInsertStatements(Map<Class<?>, String> insertStatements) {
    this.insertStatements = insertStatements;
  }

  
  public Map<Class< ? >, String> getBulkInsertStatements() {
    return bulkInsertStatements;
  }

  
  public void setBulkInsertStatements(Map<Class< ? >, String> bulkInsertStatements) {
    this.bulkInsertStatements = bulkInsertStatements;
  }

  
  public Map<Class< ? >, String> getUpdateStatements() {
    return updateStatements;
  }

  public void setUpdateStatements(Map<Class<?>, String> updateStatements) {
    this.updateStatements = updateStatements;
  }

  public Map<Class<?>, String> getDeleteStatements() {
    return deleteStatements;
  }

  public void setDeleteStatements(Map<Class<?>, String> deleteStatements) {
    this.deleteStatements = deleteStatements;
  }

  public Map<Class<?>, String> getBulkDeleteStatements() {
    return bulkDeleteStatements;
  }

  public void setBulkDeleteStatements(Map<Class<?>, String> bulkDeleteStatements) {
    this.bulkDeleteStatements = bulkDeleteStatements;
  }

  public Map<Class<?>, String> getSelectStatements() {
    return selectStatements;
  }

  public void setSelectStatements(Map<Class<?>, String> selectStatements) {
    this.selectStatements = selectStatements;
  }

  public boolean isDbIdentityUsed() {
    return isDbIdentityUsed;
  }

  public void setDbIdentityUsed(boolean isDbIdentityUsed) {
    this.isDbIdentityUsed = isDbIdentityUsed;
  }

  public boolean isDbHistoryUsed() {
    return isDbHistoryUsed;
  }

  public void setDbHistoryUsed(boolean isDbHistoryUsed) {
    this.isDbHistoryUsed = isDbHistoryUsed;
  }

  public void setDatabaseTablePrefix(String databaseTablePrefix) {
    this.databaseTablePrefix = databaseTablePrefix;
  }

  public String getDatabaseTablePrefix() {
    return databaseTablePrefix;
  }

  public String getDatabaseCatalog() {
    return databaseCatalog;
  }

  public void setDatabaseCatalog(String databaseCatalog) {
    this.databaseCatalog = databaseCatalog;
  }

  public String getDatabaseSchema() {
    return databaseSchema;
  }

  public void setDatabaseSchema(String databaseSchema) {
    this.databaseSchema = databaseSchema;
  }

  public void setTablePrefixIsSchema(boolean tablePrefixIsSchema) {
    this.tablePrefixIsSchema = tablePrefixIsSchema;
  }

  public boolean isTablePrefixIsSchema() {
    return tablePrefixIsSchema;
  }

  public int getMaxNrOfStatementsInBulkInsert() {
    return maxNrOfStatementsInBulkInsert;
  }

  public void setMaxNrOfStatementsInBulkInsert(int maxNrOfStatementsInBulkInsert) {
    this.maxNrOfStatementsInBulkInsert = maxNrOfStatementsInBulkInsert;
  }

}
!@#$%
20190526_171658,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.db;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.activiti.engine.impl.cfg.IdGenerator;
import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.interceptor.SessionFactory;
import org.apache.ibatis.session.SqlSessionFactory;


/**
 * @author Tom Baeyens
 */
public class DbSqlSessionFactory implements SessionFactory {

  protected static final Map<String, Map<String, String>> databaseSpecificStatements = new HashMap<String, Map<String,String>>();
  
  public static final Map<String, String> databaseSpecificLimitBeforeStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificLimitAfterStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificLimitBetweenStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificOrderByStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseOuterJoinLimitBetweenStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificLimitBeforeNativeQueryStatements = new HashMap<String, String>();

  static {
    
    String defaultOrderBy = " order by ${orderBy} ";
    
    // h2
    databaseSpecificLimitBeforeStatements.put("h2", "");
    databaseSpecificLimitAfterStatements.put("h2", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("h2", "");
    databaseOuterJoinLimitBetweenStatements.put("h2", "");
    databaseSpecificOrderByStatements.put("h2", defaultOrderBy);

    // hsql
    databaseSpecificLimitBeforeStatements.put("hsql", "");
    databaseSpecificLimitAfterStatements.put("hsql", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("hsql", "");
    databaseOuterJoinLimitBetweenStatements.put("hsql", "");
    databaseSpecificOrderByStatements.put("hsql", defaultOrderBy);

    
	  //mysql specific
    databaseSpecificLimitBeforeStatements.put("mysql", "");
    databaseSpecificLimitAfterStatements.put("mysql", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("mysql", "");
    databaseOuterJoinLimitBetweenStatements.put("mysql", "");
    databaseSpecificOrderByStatements.put("mysql", defaultOrderBy);
    addDatabaseSpecificStatement("mysql", "selectProcessDefinitionsByQueryCriteria", "selectProcessDefinitionsByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectProcessDefinitionCountByQueryCriteria", "selectProcessDefinitionCountByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectDeploymentsByQueryCriteria", "selectDeploymentsByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectDeploymentCountByQueryCriteria", "selectDeploymentCountByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectModelCountByQueryCriteria", "selectModelCountByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "updateExecutionTenantIdForDeployment", "updateExecutionTenantIdForDeployment_mysql");
    addDatabaseSpecificStatement("mysql", "updateTaskTenantIdForDeployment", "updateTaskTenantIdForDeployment_mysql");
    addDatabaseSpecificStatement("mysql", "updateJobTenantIdForDeployment", "updateJobTenantIdForDeployment_mysql");
    
    //postgres specific
    databaseSpecificLimitBeforeStatements.put("postgres", "");
    databaseSpecificLimitAfterStatements.put("postgres", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("postgres", "");
    databaseOuterJoinLimitBetweenStatements.put("postgres", "");
    databaseSpecificOrderByStatements.put("postgres", defaultOrderBy);
    addDatabaseSpecificStatement("postgres", "insertByteArray", "insertByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertByteArray", "bulkInsertByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "updateByteArray", "updateByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "selectByteArray", "selectByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "selectResourceByDeploymentIdAndResourceName", "selectResourceByDeploymentIdAndResourceName_postgres");
    addDatabaseSpecificStatement("postgres", "selectResourcesByDeploymentId", "selectResourcesByDeploymentId_postgres");
    addDatabaseSpecificStatement("postgres", "insertIdentityInfo", "insertIdentityInfo_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertIdentityInfo", "bulkInsertIdentityInfo_postgres");
    addDatabaseSpecificStatement("postgres", "updateIdentityInfo", "updateIdentityInfo_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoById", "selectIdentityInfoById_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoByUserIdAndKey", "selectIdentityInfoByUserIdAndKey_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoByUserId", "selectIdentityInfoByUserId_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoDetails", "selectIdentityInfoDetails_postgres");
    addDatabaseSpecificStatement("postgres", "insertComment", "insertComment_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertComment", "bulkInsertComment_postgres");
    addDatabaseSpecificStatement("postgres", "selectComment", "selectComment_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByTaskId", "selectCommentsByTaskId_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByProcessInstanceId", "selectCommentsByProcessInstanceId_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByProcessInstanceIdAndType", "selectCommentsByProcessInstanceIdAndType_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByType", "selectCommentsByType_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByTaskIdAndType", "selectCommentsByTaskIdAndType_postgres");
    addDatabaseSpecificStatement("postgres", "selectEventsByTaskId", "selectEventsByTaskId_postgres");
    addDatabaseSpecificStatement("postgres", "insertEventLogEntry", "insertEventLogEntry_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertEventLogEntry", "bulkInsertEventLogEntry_postgres");
    addDatabaseSpecificStatement("postgres", "selectAllEventLogEntries", "selectAllEventLogEntries_postgres");
    addDatabaseSpecificStatement("postgres", "selectEventLogEntries", "selectEventLogEntries_postgres");
    addDatabaseSpecificStatement("postgres", "selectEventLogEntriesByProcessInstanceId", "selectEventLogEntriesByProcessInstanceId_postgres");
        
    // oracle
    databaseSpecificLimitBeforeStatements.put("oracle", "select * from ( select a.*, ROWNUM rnum from (");
    databaseSpecificLimitAfterStatements.put("oracle", "  ) a where ROWNUM < #{lastRow}) where rnum  >= #{firstRow}");
    databaseSpecificLimitBetweenStatements.put("oracle", "");
    databaseOuterJoinLimitBetweenStatements.put("oracle", "");
    databaseSpecificOrderByStatements.put("oracle", defaultOrderBy);
    addDatabaseSpecificStatement("oracle", "selectExclusiveJobsToExecute", "selectExclusiveJobsToExecute_integerBoolean");
    addDatabaseSpecificStatement("oracle", "selectUnlockedTimersByDuedate", "selectUnlockedTimersByDuedate_oracle");
    addDatabaseSpecificStatement("oracle", "insertEventLogEntry", "insertEventLogEntry_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertVariableInstance", "bulkInsertVariableInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertUser", "bulkInsertUser_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertTask", "bulkInsertTask_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertResource", "bulkInsertResource_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertProperty", "bulkInsertProperty_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertProcessDefinition", "bulkInsertProcessDefinition_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertModel", "bulkInsertModel_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMembership", "bulkInsertMembership_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertTimer", "bulkInsertTimer_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMessage", "bulkInsertMessage_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertIdentityInfo", "bulkInsertIdentityInfo_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertIdentityLink", "bulkInsertIdentityLink_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMembership", "bulkInsertMembership_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertTimer", "bulkInsertTimer_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMessage", "bulkInsertMessage_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricVariableInstance", "bulkInsertHistoricVariableInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricTaskInstance", "bulkInsertHistoricTaskInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricProcessInstance", "bulkInsertHistoricProcessInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricIdentityLink", "bulkInsertHistoricIdentityLink_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricDetailVariableInstanceUpdate", "bulkInsertHistoricDetailVariableInstanceUpdate_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricFormProperty", "bulkInsertHistoricFormProperty_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricActivityInstance", "bulkInsertHistoricActivityInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertGroup", "bulkInsertGroup_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertExecution", "bulkInsertExecution_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMessageEventSubscription", "bulkInsertMessageEventSubscription_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertSignalEventSubscription", "bulkInsertSignalEventSubscription_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertCompensateEventSubscription", "bulkInsertCompensateEventSubscription_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertEventLogEntry", "bulkInsertEventLogEntry_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertDeployment", "bulkInsertDeployment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertComment", "bulkInsertComment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertByteArray", "bulkInsertByteArray_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertEventLogEntry", "bulkInsertEventLogEntry_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertDeployment", "bulkInsertDeployment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertComment", "bulkInsertComment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertByteArray", "bulkInsertByteArray_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertAttachment", "bulkInsertAttachment_oracle");

    // db2
    databaseSpecificLimitBeforeStatements.put("db2", "SELECT SUB.* FROM (");
    databaseSpecificLimitAfterStatements.put("db2", ")RES ) SUB WHERE SUB.rnk >= #{firstRow} AND SUB.rnk < #{lastRow}");
    databaseSpecificLimitBetweenStatements.put("db2", ", row_number() over (ORDER BY ${orderBy}) rnk FROM ( select distinct RES.* ");
    databaseOuterJoinLimitBetweenStatements.put("db2", ", row_number() over (ORDER BY ${mssqlOrDB2OrderBy}) rnk FROM ( select distinct ");
    databaseSpecificOrderByStatements.put("db2", "");
    databaseSpecificLimitBeforeNativeQueryStatements.put("db2", "SELECT SUB.* FROM ( select RES.* , row_number() over (ORDER BY ${orderBy}) rnk FROM (");
    addDatabaseSpecificStatement("db2", "selectExclusiveJobsToExecute", "selectExclusiveJobsToExecute_integerBoolean");
    addDatabaseSpecificStatement("db2", "selectExecutionByNativeQuery", "selectExecutionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricActivityInstanceByNativeQuery", "selectHistoricActivityInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricProcessInstanceByNativeQuery", "selectHistoricProcessInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricTaskInstanceByNativeQuery", "selectHistoricTaskInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectTaskByNativeQuery", "selectTaskByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectProcessDefinitionByNativeQuery", "selectProcessDefinitionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectDeploymentByNativeQuery", "selectDeploymentByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectGroupByNativeQuery", "selectGroupByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectUserByNativeQuery", "selectUserByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectModelByNativeQuery", "selectModelByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricDetailByNativeQuery", "selectHistoricDetailByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricVariableInstanceByNativeQuery", "selectHistoricVariableInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectTaskWithVariablesByQueryCriteria", "selectTaskWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectProcessInstanceWithVariablesByQueryCriteria", "selectProcessInstanceWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricProcessInstancesWithVariablesByQueryCriteria", "selectHistoricProcessInstancesWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricTaskInstancesWithVariablesByQueryCriteria", "selectHistoricTaskInstancesWithVariablesByQueryCriteria_mssql_or_db2");

    // mssql
    databaseSpecificLimitBeforeStatements.put("mssql", "SELECT SUB.* FROM (");
    databaseSpecificLimitAfterStatements.put("mssql", ")RES ) SUB WHERE SUB.rnk >= #{firstRow} AND SUB.rnk < #{lastRow}");
    databaseSpecificLimitBetweenStatements.put("mssql", ", row_number() over (ORDER BY ${orderBy}) rnk FROM ( select distinct RES.* ");
    databaseOuterJoinLimitBetweenStatements.put("mssql", ", row_number() over (ORDER BY ${mssqlOrDB2OrderBy}) rnk FROM ( select distinct ");
    databaseSpecificOrderByStatements.put("mssql", "");
    databaseSpecificLimitBeforeNativeQueryStatements.put("mssql", "SELECT SUB.* FROM ( select RES.* , row_number() over (ORDER BY ${orderBy}) rnk FROM (");
    addDatabaseSpecificStatement("mssql", "selectExclusiveJobsToExecute", "selectExclusiveJobsToExecute_integerBoolean");
    addDatabaseSpecificStatement("mssql", "selectExecutionByNativeQuery", "selectExecutionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricActivityInstanceByNativeQuery", "selectHistoricActivityInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricProcessInstanceByNativeQuery", "selectHistoricProcessInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricTaskInstanceByNativeQuery", "selectHistoricTaskInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectTaskByNativeQuery", "selectTaskByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectProcessDefinitionByNativeQuery", "selectProcessDefinitionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectDeploymentByNativeQuery", "selectDeploymentByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectGroupByNativeQuery", "selectGroupByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectUserByNativeQuery", "selectUserByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectModelByNativeQuery", "selectModelByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricDetailByNativeQuery", "selectHistoricDetailByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricVariableInstanceByNativeQuery", "selectHistoricVariableInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectTaskWithVariablesByQueryCriteria", "selectTaskWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectProcessInstanceWithVariablesByQueryCriteria", "selectProcessInstanceWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricProcessInstancesWithVariablesByQueryCriteria", "selectHistoricProcessInstancesWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricTaskInstancesWithVariablesByQueryCriteria", "selectHistoricTaskInstancesWithVariablesByQueryCriteria_mssql_or_db2");
  }
  
  protected String databaseType;
  protected String databaseTablePrefix = "";
  private boolean tablePrefixIsSchema;

  protected String databaseCatalog;
  /**
   * In some situations you want to set the schema to use for table checks /
   * generation if the database metadata doesn't return that correctly, see
   * https://jira.codehaus.org/browse/ACT-1220,
   * https://jira.codehaus.org/browse/ACT-1062
   */
  protected String databaseSchema;
  protected SqlSessionFactory sqlSessionFactory;
  protected IdGenerator idGenerator;
  protected Map<String, String> statementMappings;
  protected Map<Class<?>,String>  insertStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  bulkInsertStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  updateStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  deleteStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  bulkDeleteStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  selectStatements = new ConcurrentHashMap<Class<?>, String>();
  protected boolean isDbIdentityUsed = true;
  protected boolean isDbHistoryUsed = true;
  protected boolean isOptimizeDeleteOperationsEnabled;


  public Class< ? > getSessionType() {
    return DbSqlSession.class;
  }

  public Session openSession() {
    return new DbSqlSession(this);
  }
  
  // insert, update and delete statements /////////////////////////////////////
  
  public String getInsertStatement(PersistentObject object) {
    return getStatement(object.getClass(), insertStatements, "insert");
  }
  
  public String getBulkInsertStatement(Class clazz) {
    return getStatement(clazz, bulkInsertStatements, "bulkInsert");
  }

  public String getUpdateStatement(PersistentObject object) {
    return getStatement(object.getClass(), updateStatements, "update");
  }

  public String getDeleteStatement(Class<?> persistentObjectClass) {
    return getStatement(persistentObjectClass, deleteStatements, "delete");
  }
  
  public String getBulkDeleteStatement(Class<?> persistentObjectClass) {
    return getStatement(persistentObjectClass, bulkDeleteStatements, "bulkDelete");
  }

  public String getSelectStatement(Class<?> persistentObjectClass) {
    return getStatement(persistentObjectClass, selectStatements, "select");
  }

  private String getStatement(Class<?> persistentObjectClass, Map<Class<?>,String> cachedStatements, String prefix) {
    String statement = cachedStatements.get(persistentObjectClass);
    if (statement!=null) {
      return statement;
    }
    statement = prefix + persistentObjectClass.getSimpleName();
    statement = statement.substring(0, statement.length()-6); // removing 'entity'
    cachedStatements.put(persistentObjectClass, statement);
    return statement;
  }

  // db specific mappings /////////////////////////////////////////////////////
  
  protected static void addDatabaseSpecificStatement(String databaseType, String activitiStatement, String ibatisStatement) {
    Map<String, String> specificStatements = databaseSpecificStatements.get(databaseType);
    if (specificStatements == null) {
      specificStatements = new HashMap<String, String>();
      databaseSpecificStatements.put(databaseType, specificStatements);
    }
    specificStatements.put(activitiStatement, ibatisStatement);
  }
  
  public String mapStatement(String statement) {
    if (statementMappings==null) {
      return statement;
    }
    String mappedStatement = statementMappings.get(statement);
    return (mappedStatement!=null ? mappedStatement : statement);
  }
  
  // customized getters and setters ///////////////////////////////////////////
  
  public void setDatabaseType(String databaseType) {
    this.databaseType = databaseType;
    this.statementMappings = databaseSpecificStatements.get(databaseType);
  }

  // getters and setters //////////////////////////////////////////////////////
  
  public SqlSessionFactory getSqlSessionFactory() {
    return sqlSessionFactory;
  }
  
  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }
  
  public IdGenerator getIdGenerator() {
    return idGenerator;
  }
  
  public void setIdGenerator(IdGenerator idGenerator) {
    this.idGenerator = idGenerator;
  }

  
  public String getDatabaseType() {
    return databaseType;
  }

  
  public Map<String, String> getStatementMappings() {
    return statementMappings;
  }

  
  public void setStatementMappings(Map<String, String> statementMappings) {
    this.statementMappings = statementMappings;
  }

  
  public Map<Class< ? >, String> getInsertStatements() {
    return insertStatements;
  }

  
  public void setInsertStatements(Map<Class< ? >, String> insertStatements) {
    this.insertStatements = insertStatements;
  }

  
  public Map<Class< ? >, String> getBulkInsertStatements() {
    return bulkInsertStatements;
  }

  
  public void setBulkInsertStatements(Map<Class< ? >, String> bulkInsertStatements) {
    this.bulkInsertStatements = bulkInsertStatements;
  }

  
  public Map<Class< ? >, String> getUpdateStatements() {
    return updateStatements;
  }

  
  public void setUpdateStatements(Map<Class< ? >, String> updateStatements) {
    this.updateStatements = updateStatements;
  }

  
  public Map<Class< ? >, String> getDeleteStatements() {
    return deleteStatements;
  }

  
  public void setDeleteStatements(Map<Class< ? >, String> deleteStatements) {
    this.deleteStatements = deleteStatements;
  }
  
  
  public Map<Class<?>, String> getBulkDeleteStatements() {
		return bulkDeleteStatements;
	}

	public void setBulkDeleteStatements(Map<Class<?>, String> bulkDeleteStatements) {
		this.bulkDeleteStatements = bulkDeleteStatements;
	}

	public Map<Class< ? >, String> getSelectStatements() {
    return selectStatements;
  }

  
  public void setSelectStatements(Map<Class< ? >, String> selectStatements) {
    this.selectStatements = selectStatements;
  }

  public boolean isDbIdentityUsed() {
    return isDbIdentityUsed;
  }
  
  public void setDbIdentityUsed(boolean isDbIdentityUsed) {
    this.isDbIdentityUsed = isDbIdentityUsed;
  }
  
  public boolean isDbHistoryUsed() {
    return isDbHistoryUsed;
  }
  
  public void setDbHistoryUsed(boolean isDbHistoryUsed) {
    this.isDbHistoryUsed = isDbHistoryUsed;
  }

  public void setDatabaseTablePrefix(String databaseTablePrefix) {
    this.databaseTablePrefix = databaseTablePrefix;
  }
    
  public String getDatabaseTablePrefix() {
    return databaseTablePrefix;
  }

  public String getDatabaseCatalog() {
    return databaseCatalog;
  }

  public void setDatabaseCatalog(String databaseCatalog) {
    this.databaseCatalog = databaseCatalog;
  }

  public String getDatabaseSchema() {
    return databaseSchema;
  }
  
  public void setDatabaseSchema(String databaseSchema) {
    this.databaseSchema = databaseSchema;
  }

	public void setTablePrefixIsSchema(boolean tablePrefixIsSchema) {
		this.tablePrefixIsSchema = tablePrefixIsSchema;
  }
	
	public boolean isTablePrefixIsSchema() {
	  return tablePrefixIsSchema;
  }

	public boolean isOptimizeDeleteOperationsEnabled() {
		return isOptimizeDeleteOperationsEnabled;
	}

	public void setOptimizeDeleteOperationsEnabled(boolean isOptimizeDeleteOperationsEnabled) {
		this.isOptimizeDeleteOperationsEnabled = isOptimizeDeleteOperationsEnabled;
	}
	
}
!@#$%
20190526_171658,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.db;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.activiti.engine.impl.cfg.IdGenerator;
import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.interceptor.SessionFactory;
import org.activiti.engine.impl.persistence.entity.EventLogEntryEntity;
import org.apache.ibatis.session.SqlSessionFactory;


/**
 * @author Tom Baeyens
 */
public class DbSqlSessionFactory implements SessionFactory {

  protected static final Map<String, Map<String, String>> databaseSpecificStatements = new HashMap<String, Map<String,String>>();
  
  public static final Map<String, String> databaseSpecificLimitBeforeStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificLimitAfterStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificLimitBetweenStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificOrderByStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseOuterJoinLimitBetweenStatements = new HashMap<String, String>();
  public static final Map<String, String> databaseSpecificLimitBeforeNativeQueryStatements = new HashMap<String, String>();

  static {
    
    String defaultOrderBy = " order by ${orderByColumns} ";
    
    // h2
    databaseSpecificLimitBeforeStatements.put("h2", "");
    databaseSpecificLimitAfterStatements.put("h2", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("h2", "");
    databaseOuterJoinLimitBetweenStatements.put("h2", "");
    databaseSpecificOrderByStatements.put("h2", defaultOrderBy);

    // hsql
    databaseSpecificLimitBeforeStatements.put("hsql", "");
    databaseSpecificLimitAfterStatements.put("hsql", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("hsql", "");
    databaseOuterJoinLimitBetweenStatements.put("hsql", "");
    databaseSpecificOrderByStatements.put("hsql", defaultOrderBy);

    
	  //mysql specific
    databaseSpecificLimitBeforeStatements.put("mysql", "");
    databaseSpecificLimitAfterStatements.put("mysql", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("mysql", "");
    databaseOuterJoinLimitBetweenStatements.put("mysql", "");
    databaseSpecificOrderByStatements.put("mysql", defaultOrderBy);
    addDatabaseSpecificStatement("mysql", "selectProcessDefinitionsByQueryCriteria", "selectProcessDefinitionsByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectProcessDefinitionCountByQueryCriteria", "selectProcessDefinitionCountByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectDeploymentsByQueryCriteria", "selectDeploymentsByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectDeploymentCountByQueryCriteria", "selectDeploymentCountByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "selectModelCountByQueryCriteria", "selectModelCountByQueryCriteria_mysql");
    addDatabaseSpecificStatement("mysql", "updateExecutionTenantIdForDeployment", "updateExecutionTenantIdForDeployment_mysql");
    addDatabaseSpecificStatement("mysql", "updateTaskTenantIdForDeployment", "updateTaskTenantIdForDeployment_mysql");
    addDatabaseSpecificStatement("mysql", "updateJobTenantIdForDeployment", "updateJobTenantIdForDeployment_mysql");
    
    //postgres specific
    databaseSpecificLimitBeforeStatements.put("postgres", "");
    databaseSpecificLimitAfterStatements.put("postgres", "LIMIT #{maxResults} OFFSET #{firstResult}");
    databaseSpecificLimitBetweenStatements.put("postgres", "");
    databaseOuterJoinLimitBetweenStatements.put("postgres", "");
    databaseSpecificOrderByStatements.put("postgres", defaultOrderBy);
    addDatabaseSpecificStatement("postgres", "insertByteArray", "insertByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertByteArray", "bulkInsertByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "updateByteArray", "updateByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "selectByteArray", "selectByteArray_postgres");
    addDatabaseSpecificStatement("postgres", "selectResourceByDeploymentIdAndResourceName", "selectResourceByDeploymentIdAndResourceName_postgres");
    addDatabaseSpecificStatement("postgres", "selectResourcesByDeploymentId", "selectResourcesByDeploymentId_postgres");
    addDatabaseSpecificStatement("postgres", "insertIdentityInfo", "insertIdentityInfo_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertIdentityInfo", "bulkInsertIdentityInfo_postgres");
    addDatabaseSpecificStatement("postgres", "updateIdentityInfo", "updateIdentityInfo_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoById", "selectIdentityInfoById_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoByUserIdAndKey", "selectIdentityInfoByUserIdAndKey_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoByUserId", "selectIdentityInfoByUserId_postgres");
    addDatabaseSpecificStatement("postgres", "selectIdentityInfoDetails", "selectIdentityInfoDetails_postgres");
    addDatabaseSpecificStatement("postgres", "insertComment", "insertComment_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertComment", "bulkInsertComment_postgres");
    addDatabaseSpecificStatement("postgres", "selectComment", "selectComment_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByTaskId", "selectCommentsByTaskId_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByProcessInstanceId", "selectCommentsByProcessInstanceId_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByProcessInstanceIdAndType", "selectCommentsByProcessInstanceIdAndType_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByType", "selectCommentsByType_postgres");
    addDatabaseSpecificStatement("postgres", "selectCommentsByTaskIdAndType", "selectCommentsByTaskIdAndType_postgres");
    addDatabaseSpecificStatement("postgres", "selectEventsByTaskId", "selectEventsByTaskId_postgres");
    addDatabaseSpecificStatement("postgres", "insertEventLogEntry", "insertEventLogEntry_postgres");
    addDatabaseSpecificStatement("postgres", "bulkInsertEventLogEntry", "bulkInsertEventLogEntry_postgres");
    addDatabaseSpecificStatement("postgres", "selectAllEventLogEntries", "selectAllEventLogEntries_postgres");
    addDatabaseSpecificStatement("postgres", "selectEventLogEntries", "selectEventLogEntries_postgres");
    addDatabaseSpecificStatement("postgres", "selectEventLogEntriesByProcessInstanceId", "selectEventLogEntriesByProcessInstanceId_postgres");
        
    // oracle
    databaseSpecificLimitBeforeStatements.put("oracle", "select * from ( select a.*, ROWNUM rnum from (");
    databaseSpecificLimitAfterStatements.put("oracle", "  ) a where ROWNUM < #{lastRow}) where rnum  >= #{firstRow}");
    databaseSpecificLimitBetweenStatements.put("oracle", "");
    databaseOuterJoinLimitBetweenStatements.put("oracle", "");
    databaseSpecificOrderByStatements.put("oracle", defaultOrderBy);
    addDatabaseSpecificStatement("oracle", "selectExclusiveJobsToExecute", "selectExclusiveJobsToExecute_integerBoolean");
    addDatabaseSpecificStatement("oracle", "selectUnlockedTimersByDuedate", "selectUnlockedTimersByDuedate_oracle");
    addDatabaseSpecificStatement("oracle", "insertEventLogEntry", "insertEventLogEntry_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertVariableInstance", "bulkInsertVariableInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertUser", "bulkInsertUser_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertTask", "bulkInsertTask_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertResource", "bulkInsertResource_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertProperty", "bulkInsertProperty_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertProcessDefinition", "bulkInsertProcessDefinition_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertModel", "bulkInsertModel_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMembership", "bulkInsertMembership_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertTimer", "bulkInsertTimer_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMessage", "bulkInsertMessage_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertIdentityInfo", "bulkInsertIdentityInfo_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertIdentityLink", "bulkInsertIdentityLink_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMembership", "bulkInsertMembership_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertTimer", "bulkInsertTimer_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMessage", "bulkInsertMessage_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricVariableInstance", "bulkInsertHistoricVariableInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricTaskInstance", "bulkInsertHistoricTaskInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricProcessInstance", "bulkInsertHistoricProcessInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricIdentityLink", "bulkInsertHistoricIdentityLink_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricDetailVariableInstanceUpdate", "bulkInsertHistoricDetailVariableInstanceUpdate_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricFormProperty", "bulkInsertHistoricFormProperty_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertHistoricActivityInstance", "bulkInsertHistoricActivityInstance_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertGroup", "bulkInsertGroup_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertExecution", "bulkInsertExecution_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertMessageEventSubscription", "bulkInsertMessageEventSubscription_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertSignalEventSubscription", "bulkInsertSignalEventSubscription_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertCompensateEventSubscription", "bulkInsertCompensateEventSubscription_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertEventLogEntry", "bulkInsertEventLogEntry_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertDeployment", "bulkInsertDeployment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertComment", "bulkInsertComment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertByteArray", "bulkInsertByteArray_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertEventLogEntry", "bulkInsertEventLogEntry_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertDeployment", "bulkInsertDeployment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertComment", "bulkInsertComment_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertByteArray", "bulkInsertByteArray_oracle");
    addDatabaseSpecificStatement("oracle", "bulkInsertAttachment", "bulkInsertAttachment_oracle");

    // db2
    databaseSpecificLimitBeforeStatements.put("db2", "SELECT SUB.* FROM (");
    databaseSpecificLimitAfterStatements.put("db2", ")RES ) SUB WHERE SUB.rnk >= #{firstRow} AND SUB.rnk < #{lastRow}");
    databaseSpecificLimitBetweenStatements.put("db2", ", row_number() over (ORDER BY ${orderByColumns}) rnk FROM ( select distinct RES.* ");
    databaseOuterJoinLimitBetweenStatements.put("db2", ", row_number() over (ORDER BY ${mssqlOrDB2OrderBy}) rnk FROM ( select distinct ");
    databaseSpecificOrderByStatements.put("db2", "");
    databaseSpecificLimitBeforeNativeQueryStatements.put("db2", "SELECT SUB.* FROM ( select RES.* , row_number() over (ORDER BY ${orderByColumns}) rnk FROM (");
    addDatabaseSpecificStatement("db2", "selectExclusiveJobsToExecute", "selectExclusiveJobsToExecute_integerBoolean");
    addDatabaseSpecificStatement("db2", "selectExecutionByNativeQuery", "selectExecutionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricActivityInstanceByNativeQuery", "selectHistoricActivityInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricProcessInstanceByNativeQuery", "selectHistoricProcessInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricTaskInstanceByNativeQuery", "selectHistoricTaskInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectTaskByNativeQuery", "selectTaskByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectProcessDefinitionByNativeQuery", "selectProcessDefinitionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectDeploymentByNativeQuery", "selectDeploymentByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectGroupByNativeQuery", "selectGroupByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectUserByNativeQuery", "selectUserByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectModelByNativeQuery", "selectModelByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricDetailByNativeQuery", "selectHistoricDetailByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricVariableInstanceByNativeQuery", "selectHistoricVariableInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectTaskWithVariablesByQueryCriteria", "selectTaskWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectProcessInstanceWithVariablesByQueryCriteria", "selectProcessInstanceWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricProcessInstancesWithVariablesByQueryCriteria", "selectHistoricProcessInstancesWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("db2", "selectHistoricTaskInstancesWithVariablesByQueryCriteria", "selectHistoricTaskInstancesWithVariablesByQueryCriteria_mssql_or_db2");

    // mssql
    databaseSpecificLimitBeforeStatements.put("mssql", "SELECT SUB.* FROM (");
    databaseSpecificLimitAfterStatements.put("mssql", ")RES ) SUB WHERE SUB.rnk >= #{firstRow} AND SUB.rnk < #{lastRow}");
    databaseSpecificLimitBetweenStatements.put("mssql", ", row_number() over (ORDER BY ${orderByColumns}) rnk FROM ( select distinct RES.* ");
    databaseOuterJoinLimitBetweenStatements.put("mssql", ", row_number() over (ORDER BY ${mssqlOrDB2OrderBy}) rnk FROM ( select distinct ");
    databaseSpecificOrderByStatements.put("mssql", "");
    databaseSpecificLimitBeforeNativeQueryStatements.put("mssql", "SELECT SUB.* FROM ( select RES.* , row_number() over (ORDER BY ${orderByColumns}) rnk FROM (");
    addDatabaseSpecificStatement("mssql", "selectExclusiveJobsToExecute", "selectExclusiveJobsToExecute_integerBoolean");
    addDatabaseSpecificStatement("mssql", "selectExecutionByNativeQuery", "selectExecutionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricActivityInstanceByNativeQuery", "selectHistoricActivityInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricProcessInstanceByNativeQuery", "selectHistoricProcessInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricTaskInstanceByNativeQuery", "selectHistoricTaskInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectTaskByNativeQuery", "selectTaskByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectProcessDefinitionByNativeQuery", "selectProcessDefinitionByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectDeploymentByNativeQuery", "selectDeploymentByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectGroupByNativeQuery", "selectGroupByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectUserByNativeQuery", "selectUserByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectModelByNativeQuery", "selectModelByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricDetailByNativeQuery", "selectHistoricDetailByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricVariableInstanceByNativeQuery", "selectHistoricVariableInstanceByNativeQuery_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectTaskWithVariablesByQueryCriteria", "selectTaskWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectProcessInstanceWithVariablesByQueryCriteria", "selectProcessInstanceWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricProcessInstancesWithVariablesByQueryCriteria", "selectHistoricProcessInstancesWithVariablesByQueryCriteria_mssql_or_db2");
    addDatabaseSpecificStatement("mssql", "selectHistoricTaskInstancesWithVariablesByQueryCriteria", "selectHistoricTaskInstancesWithVariablesByQueryCriteria_mssql_or_db2");
  }
  
  
  /**
   * A map {class, boolean}, to indicate whether or not a certain {@link PersistentObject} class can be bulk inserted.
   */
  protected static Map<Class<? extends PersistentObject>, Boolean> bulkInsertableMap;
  
  protected String databaseType;
  protected String databaseTablePrefix = "";
  private boolean tablePrefixIsSchema;

  protected String databaseCatalog;
  /**
   * In some situations you want to set the schema to use for table checks /
   * generation if the database metadata doesn't return that correctly, see
   * https://activiti.atlassian.net/browse/ACT-1220,
   * https://activiti.atlassian.net/browse/ACT-1062
   */
  protected String databaseSchema;
  protected SqlSessionFactory sqlSessionFactory;
  protected IdGenerator idGenerator;
  protected Map<String, String> statementMappings;
  protected Map<Class<?>,String>  insertStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  bulkInsertStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  updateStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  deleteStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  bulkDeleteStatements = new ConcurrentHashMap<Class<?>, String>();
  protected Map<Class<?>,String>  selectStatements = new ConcurrentHashMap<Class<?>, String>();
  protected boolean isDbIdentityUsed = true;
  protected boolean isDbHistoryUsed = true;
  protected int maxNrOfStatementsInBulkInsert = 100;


  public Class< ? > getSessionType() {
    return DbSqlSession.class;
  }

  public Session openSession() {
    return new DbSqlSession(this);
  }
  
  // insert, update and delete statements /////////////////////////////////////
  
  public String getInsertStatement(PersistentObject object) {
    return getStatement(object.getClass(), insertStatements, "insert");
  }
  
  
  public String getInsertStatement(Class<? extends PersistentObject> clazz) {
    return getStatement(clazz, insertStatements, "insert");
  }
  
  public String getBulkInsertStatement(Class clazz) {
    return getStatement(clazz, bulkInsertStatements, "bulkInsert");
  }

  public String getUpdateStatement(PersistentObject object) {
    return getStatement(object.getClass(), updateStatements, "update");
  }

  public String getDeleteStatement(Class<?> persistentObjectClass) {
    return getStatement(persistentObjectClass, deleteStatements, "delete");
  }
  
  public String getBulkDeleteStatement(Class<?> persistentObjectClass) {
    return getStatement(persistentObjectClass, bulkDeleteStatements, "bulkDelete");
  }

  public String getSelectStatement(Class<?> persistentObjectClass) {
    return getStatement(persistentObjectClass, selectStatements, "select");
  }

  private String getStatement(Class<?> persistentObjectClass, Map<Class<?>,String> cachedStatements, String prefix) {
    String statement = cachedStatements.get(persistentObjectClass);
    if (statement!=null) {
      return statement;
    }
    statement = prefix + persistentObjectClass.getSimpleName();
    statement = statement.substring(0, statement.length()-6); // removing 'entity'
    cachedStatements.put(persistentObjectClass, statement);
    return statement;
  }

  // db specific mappings /////////////////////////////////////////////////////
  
  protected static void addDatabaseSpecificStatement(String databaseType, String activitiStatement, String ibatisStatement) {
    Map<String, String> specificStatements = databaseSpecificStatements.get(databaseType);
    if (specificStatements == null) {
      specificStatements = new HashMap<String, String>();
      databaseSpecificStatements.put(databaseType, specificStatements);
    }
    specificStatements.put(activitiStatement, ibatisStatement);
  }
  
  public String mapStatement(String statement) {
    if (statementMappings==null) {
      return statement;
    }
    String mappedStatement = statementMappings.get(statement);
    return (mappedStatement!=null ? mappedStatement : statement);
  }
  
  // customized getters and setters ///////////////////////////////////////////
  
  public void setDatabaseType(String databaseType) {
    this.databaseType = databaseType;
    this.statementMappings = databaseSpecificStatements.get(databaseType);
  }
  
  public void setBulkInsertEnabled(boolean isBulkInsertEnabled, String databaseType) {
  	// If false, just keep don't initialize the map. Memory saved.
  	if (isBulkInsertEnabled) {
  		initBulkInsertEnabledMap(databaseType);
  	}
  }
  
  protected void initBulkInsertEnabledMap(String databaseType) {
  	bulkInsertableMap = new HashMap<Class<? extends PersistentObject>, Boolean>();
  	
  	for (Class<? extends PersistentObject> clazz : EntityDependencyOrder.INSERT_ORDER) {
  		bulkInsertableMap.put(clazz, Boolean.TRUE);
  	}

  	// Only Oracle is making a fuss in one specific case right now
		if ("oracle".equals(databaseType)) {
			bulkInsertableMap.put(EventLogEntryEntity.class, Boolean.FALSE);
		}
  }
  
  public Boolean isBulkInsertable(Class<? extends PersistentObject> persistentObjectClass) {
  	return bulkInsertableMap != null && bulkInsertableMap.containsKey(persistentObjectClass) && bulkInsertableMap.get(persistentObjectClass) == true;
  }

  // getters and setters //////////////////////////////////////////////////////
  
  public SqlSessionFactory getSqlSessionFactory() {
    return sqlSessionFactory;
  }
  
  public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {
    this.sqlSessionFactory = sqlSessionFactory;
  }
  
  public IdGenerator getIdGenerator() {
    return idGenerator;
  }
  
  public void setIdGenerator(IdGenerator idGenerator) {
    this.idGenerator = idGenerator;
  }

  
  public String getDatabaseType() {
    return databaseType;
  }

  
  public Map<String, String> getStatementMappings() {
    return statementMappings;
  }

  
  public void setStatementMappings(Map<String, String> statementMappings) {
    this.statementMappings = statementMappings;
  }

  
  public Map<Class< ? >, String> getInsertStatements() {
    return insertStatements;
  }

  
  public void setInsertStatements(Map<Class< ? >, String> insertStatements) {
    this.insertStatements = insertStatements;
  }

  
  public Map<Class< ? >, String> getBulkInsertStatements() {
    return bulkInsertStatements;
  }

  
  public void setBulkInsertStatements(Map<Class< ? >, String> bulkInsertStatements) {
    this.bulkInsertStatements = bulkInsertStatements;
  }

  
  public Map<Class< ? >, String> getUpdateStatements() {
    return updateStatements;
  }

  
  public void setUpdateStatements(Map<Class< ? >, String> updateStatements) {
    this.updateStatements = updateStatements;
  }

  
  public Map<Class< ? >, String> getDeleteStatements() {
    return deleteStatements;
  }

  
  public void setDeleteStatements(Map<Class< ? >, String> deleteStatements) {
    this.deleteStatements = deleteStatements;
  }
  
  
  public Map<Class<?>, String> getBulkDeleteStatements() {
		return bulkDeleteStatements;
	}

	public void setBulkDeleteStatements(Map<Class<?>, String> bulkDeleteStatements) {
		this.bulkDeleteStatements = bulkDeleteStatements;
	}

	public Map<Class< ? >, String> getSelectStatements() {
    return selectStatements;
  }

  
  public void setSelectStatements(Map<Class< ? >, String> selectStatements) {
    this.selectStatements = selectStatements;
  }

  public boolean isDbIdentityUsed() {
    return isDbIdentityUsed;
  }
  
  public void setDbIdentityUsed(boolean isDbIdentityUsed) {
    this.isDbIdentityUsed = isDbIdentityUsed;
  }
  
  public boolean isDbHistoryUsed() {
    return isDbHistoryUsed;
  }
  
  public void setDbHistoryUsed(boolean isDbHistoryUsed) {
    this.isDbHistoryUsed = isDbHistoryUsed;
  }

  public void setDatabaseTablePrefix(String databaseTablePrefix) {
    this.databaseTablePrefix = databaseTablePrefix;
  }
    
  public String getDatabaseTablePrefix() {
    return databaseTablePrefix;
  }

  public String getDatabaseCatalog() {
    return databaseCatalog;
  }

  public void setDatabaseCatalog(String databaseCatalog) {
    this.databaseCatalog = databaseCatalog;
  }

  public String getDatabaseSchema() {
    return databaseSchema;
  }
  
  public void setDatabaseSchema(String databaseSchema) {
    this.databaseSchema = databaseSchema;
  }

	public void setTablePrefixIsSchema(boolean tablePrefixIsSchema) {
		this.tablePrefixIsSchema = tablePrefixIsSchema;
  }
	
	public boolean isTablePrefixIsSchema() {
	  return tablePrefixIsSchema;
  }

	public int getMaxNrOfStatementsInBulkInsert() {
		return maxNrOfStatementsInBulkInsert;
	}

	public void setMaxNrOfStatementsInBulkInsert(int maxNrOfStatementsInBulkInsert) {
		this.maxNrOfStatementsInBulkInsert = maxNrOfStatementsInBulkInsert;
	}
	
}
!@#$%
20190526_171716,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.db;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.ActivitiOptimisticLockingException;
import org.activiti.engine.ActivitiWrongDbException;
import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.activiti.engine.impl.DeploymentQueryImpl;
import org.activiti.engine.impl.ExecutionQueryImpl;
import org.activiti.engine.impl.GroupQueryImpl;
import org.activiti.engine.impl.HistoricActivityInstanceQueryImpl;
import org.activiti.engine.impl.HistoricDetailQueryImpl;
import org.activiti.engine.impl.HistoricProcessInstanceQueryImpl;
import org.activiti.engine.impl.HistoricTaskInstanceQueryImpl;
import org.activiti.engine.impl.HistoricVariableInstanceQueryImpl;
import org.activiti.engine.impl.JobQueryImpl;
import org.activiti.engine.impl.ModelQueryImpl;
import org.activiti.engine.impl.Page;
import org.activiti.engine.impl.ProcessDefinitionQueryImpl;
import org.activiti.engine.impl.ProcessInstanceQueryImpl;
import org.activiti.engine.impl.TaskQueryImpl;
import org.activiti.engine.impl.UserQueryImpl;
import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.db.upgrade.DbUpgradeStep;
import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.persistence.cache.CachedEntity;
import org.activiti.engine.impl.persistence.cache.EntityCache;
import org.activiti.engine.impl.persistence.entity.Entity;
import org.activiti.engine.impl.persistence.entity.ExecutionEntity;
import org.activiti.engine.impl.persistence.entity.PropertyEntity;
import org.activiti.engine.impl.util.IoUtil;
import org.activiti.engine.impl.util.ReflectUtil;
import org.apache.ibatis.session.SqlSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class DbSqlSession implements Session {

  private static final Logger log = LoggerFactory.getLogger(DbSqlSession.class);
  
  protected static final Pattern CLEAN_VERSION_REGEX = Pattern.compile("\\d\\.\\d*");
  
  protected static final String LAST_V5_VERSION = "5.99.0.0";
  
  protected static final List<ActivitiVersion> ACTIVITI_VERSIONS = new ArrayList<ActivitiVersion>();
  static {

    /* Previous */

    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.7"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.8"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.9"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.10"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.11"));

    // 5.12.1 was a bugfix release on 5.12 and did NOT change the version in ACT_GE_PROPERTY
    // On top of that, DB2 create script for 5.12.1 was shipped with a 'T' suffix ...
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.12", Arrays.asList("5.12.1", "5.12T")));

    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.13"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.14"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.15"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.15.1"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.1"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.2-SNAPSHOT"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.2"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.3.0"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.4.0"));

    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.0"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.1"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.2"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.18.0.0"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.18.0.1"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.20.0.0"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.20.0.1"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.20.0.2"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.21.0.0"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("5.22.0.0"));
    
    /*
     * Version 5.18.0.1 is the latest v5 version in the list here, although if you would look at the v5 code,
     * you'll see there are a few other releases afterwards.
     * 
     * The reasoning is as follows: after 5.18.0.1, no database changes were done anymore.
     * And if there would be database changes, they would have been part of both 5.x _and_ 6.x upgrade scripts.
     * The logic below will assume it's one of these releases in case it isn't found in the list here
     * and do the upgrade from the 'virtual' release 5.99.0.0 to make sure th v6 changes are applied.
     */
    

    // This is the latest version of the 5 branch. It's a 'virtual' version cause it doesn't exist, but it is
    // there to make sure all previous version can upgrade to the 6 version correctly.
    ACTIVITI_VERSIONS.add(new ActivitiVersion(LAST_V5_VERSION));
    
    // Version 6
    ACTIVITI_VERSIONS.add(new ActivitiVersion("6.0.0.0"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("6.0.0.1"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("6.0.0.2"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("6.0.0.3"));
    ACTIVITI_VERSIONS.add(new ActivitiVersion("6.0.0.4"));
    
    /* Current */
    ACTIVITI_VERSIONS.add(new ActivitiVersion(ProcessEngine.VERSION));
  }

  protected SqlSession sqlSession;
  protected DbSqlSessionFactory dbSqlSessionFactory;
  protected EntityCache entityCache;
  
  protected Map<Class<? extends Entity>, Map<String, Entity>> insertedObjects 
    = new HashMap<Class<? extends Entity>, Map<String, Entity>>();
  protected Map<Class<? extends Entity>, Map<String, Entity>> deletedObjects 
    = new HashMap<Class<? extends Entity>, Map<String, Entity>>();
  protected Map<Class<? extends Entity>, List<BulkDeleteOperation>> bulkDeleteOperations
    = new HashMap<Class<? extends Entity>, List<BulkDeleteOperation>>();
  protected List<Entity> updatedObjects = new ArrayList<Entity>();
 
  protected String connectionMetadataDefaultCatalog;
  protected String connectionMetadataDefaultSchema;

  public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory, EntityCache entityCache) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.sqlSession = dbSqlSessionFactory.getSqlSessionFactory().openSession();
    this.entityCache = entityCache;
    this.connectionMetadataDefaultCatalog = dbSqlSessionFactory.getDatabaseCatalog();
    this.connectionMetadataDefaultSchema = dbSqlSessionFactory.getDatabaseSchema();
  }

  public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory, EntityCache entityCache, Connection connection, String catalog, String schema) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.sqlSession = dbSqlSessionFactory.getSqlSessionFactory().openSession(connection); // Note the use of connection param here, different from other constructor
    this.entityCache = entityCache;
    this.connectionMetadataDefaultCatalog = catalog;
    this.connectionMetadataDefaultSchema = schema;
  }
  
  // insert ///////////////////////////////////////////////////////////////////
  
  
  public void insert(Entity entity) {
    if (entity.getId() == null) {
      String id = dbSqlSessionFactory.getIdGenerator().getNextId();
      entity.setId(id);
    }
    
    Class<? extends Entity> clazz = entity.getClass();
    if (!insertedObjects.containsKey(clazz)) {
    	insertedObjects.put(clazz, new LinkedHashMap<String, Entity>()); // order of insert is important, hence LinkedHashMap
    }
    
    insertedObjects.get(clazz).put(entity.getId(), entity);
    entityCache.put(entity, false); // False -> entity is inserted, so always changed
    entity.setInserted(true);
  }

  // update
  // ///////////////////////////////////////////////////////////////////

  public void update(Entity entity) {
    entityCache.put(entity, false); // false -> we don't store state, meaning it will always be seen as changed 
    entity.setUpdated(true);
  }

  public int update(String statement, Object parameters) {
    String updateStatement = dbSqlSessionFactory.mapStatement(statement);
    return getSqlSession().update(updateStatement, parameters);
  }

  // delete
  // ///////////////////////////////////////////////////////////////////

  /**
   * Executes a {@link BulkDeleteOperation}, with the sql in the statement parameter.
   * The passed class determines when this operation will be executed: it will be executed
   * when the particular class has passed in the {@link EntityDependencyOrder}. 
   */
  public void delete(String statement, Object parameter, Class<? extends Entity> entityClass) {
    if (!bulkDeleteOperations.containsKey(entityClass)) {
      bulkDeleteOperations.put(entityClass, new ArrayList<BulkDeleteOperation>(1));
    }
    bulkDeleteOperations.get(entityClass).add(new BulkDeleteOperation(dbSqlSessionFactory.mapStatement(statement), parameter));
  }

  public void delete(Entity entity) {
    Class<? extends Entity> clazz = entity.getClass();
    if (!deletedObjects.containsKey(clazz)) {
      deletedObjects.put(clazz, new LinkedHashMap<String, Entity>()); // order of insert is important, hence LinkedHashMap
    }
    deletedObjects.get(clazz).put(entity.getId(), entity);
    entity.setDeleted(true); 
  }

  // select
  // ///////////////////////////////////////////////////////////////////

  @SuppressWarnings({ "rawtypes" })
  public List selectList(String statement) {
    return selectList(statement, null, 0, Integer.MAX_VALUE);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter) {
    return selectList(statement, parameter, 0, Integer.MAX_VALUE);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, boolean useCache) {
    return selectList(statement, parameter, 0, Integer.MAX_VALUE, useCache);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, Page page) {
    return selectList(statement, parameter, page, true);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, Page page, boolean useCache) {
    if (page != null) {
      return selectList(statement, parameter, page.getFirstResult(), page.getMaxResults(), useCache);
    } else {
      return selectList(statement, parameter, 0, Integer.MAX_VALUE, useCache);
    }
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter, Page page) {
    return selectList(statement, parameter, page, true);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter, Page page, boolean useCache) {
    
    ListQueryParameterObject parameterToUse = parameter;
    if (parameterToUse == null) {
      parameterToUse = new ListQueryParameterObject();
    } 
    
    if (page != null) {
      parameterToUse.setFirstResult(page.getFirstResult());
      parameterToUse.setMaxResults(page.getMaxResults());
    }

    return selectList(statement, parameterToUse, useCache);
      
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, int firstResult, int maxResults) {
    return selectList(statement, parameter, firstResult, maxResults, true);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, int firstResult, int maxResults, boolean useCache) {
    return selectList(statement, new ListQueryParameterObject(parameter, firstResult, maxResults), useCache);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter) {
    return selectList(statement, parameter, true);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter, boolean useCache) {
    return selectListWithRawParameter(statement, parameter, parameter.getFirstResult(), parameter.getMaxResults(), useCache);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectListWithRawParameter(String statement, Object parameter, int firstResult, int maxResults) {
    return selectListWithRawParameter(statement, parameter, firstResult, maxResults, true);
  }

  @SuppressWarnings({ "rawtypes", "unchecked" })
  public List selectListWithRawParameter(String statement, Object parameter, int firstResult, int maxResults, boolean useCache) {
    statement = dbSqlSessionFactory.mapStatement(statement);
    if (firstResult == -1 || maxResults == -1) {
      return Collections.EMPTY_LIST;
    }
    
    List loadedObjects = sqlSession.selectList(statement, parameter);
    if (useCache) {
      return cacheLoadOrStore(loadedObjects);
    } else {
      return loadedObjects;
    }
  }

  @SuppressWarnings({ "rawtypes" })
  public List selectListWithRawParameterWithoutFilter(String statement, Object parameter, int firstResult, int maxResults) {
    statement = dbSqlSessionFactory.mapStatement(statement);
    if (firstResult == -1 || maxResults == -1) {
      return Collections.EMPTY_LIST;
    }
    return sqlSession.selectList(statement, parameter);
  }

  public Object selectOne(String statement, Object parameter) {
    statement = dbSqlSessionFactory.mapStatement(statement);
    Object result = sqlSession.selectOne(statement, parameter);
    if (result instanceof Entity) {
      Entity loadedObject = (Entity) result;
      result = cacheLoadOrStore(loadedObject);
    }
    return result;
  }

  public <T extends Entity> T selectById(Class<T> entityClass, String id) {
    return selectById(entityClass, id, true);
  }
  
  @SuppressWarnings("unchecked")
  public <T extends Entity> T selectById(Class<T> entityClass, String id, boolean useCache) {
    T entity = null;
    
    if (useCache) {
      entity = entityCache.findInCache(entityClass, id);
      if (entity != null) {
        return entity;
      }
    }
    
    String selectStatement = dbSqlSessionFactory.getSelectStatement(entityClass);
    selectStatement = dbSqlSessionFactory.mapStatement(selectStatement);
    entity = (T) sqlSession.selectOne(selectStatement, id);
    if (entity == null) {
      return null;
    }
    
    entityCache.put(entity, true); // true -> store state so we can see later if it is updated later on
    return entity;
  }

  // internal session cache
  // ///////////////////////////////////////////////////

  @SuppressWarnings("rawtypes")
  protected List cacheLoadOrStore(List<Object> loadedObjects) {
    if (loadedObjects.isEmpty()) {
      return loadedObjects;
    }
    if (!(loadedObjects.get(0) instanceof Entity)) {
      return loadedObjects;
    }

    List<Entity> filteredObjects = new ArrayList<Entity>(loadedObjects.size());
    for (Object loadedObject : loadedObjects) {
      Entity cachedEntity = cacheLoadOrStore((Entity) loadedObject);
      filteredObjects.add(cachedEntity);
    }
    return filteredObjects;
  }

  /**
   * Returns the object in the cache. If this object was loaded before, then the original object is returned (the cached version is more recent). 
   * If this is the first time this object is loaded, then the loadedObject is added to the cache.
   */
  protected Entity cacheLoadOrStore(Entity entity) {
    Entity cachedEntity = entityCache.findInCache(entity.getClass(), entity.getId());
    if (cachedEntity != null) {
      return cachedEntity;
    }
    entityCache.put(entity, true);
    return entity;
  }

  // flush
  // ////////////////////////////////////////////////////////////////////

  public void flush() {
    determineUpdatedObjects(); // Needs to be done before the removeUnnecessaryOperations, as removeUnnecessaryOperations will remove stuff from the cache
    removeUnnecessaryOperations();

    if (log.isDebugEnabled()) {
      debugFlush();
    }

    flushInserts();
    flushUpdates();
    flushDeletes();
  }

  /**
   * Clears all deleted and inserted objects from the cache, 
   * and removes inserts and deletes that cancel each other.
   * 
   * Also removes deletes with duplicate ids.
   */
  protected void removeUnnecessaryOperations() {
    
    for (Class<? extends Entity> entityClass : deletedObjects.keySet()) {
      
      // Collect ids of deleted entities + remove duplicates 
      Set<String> ids = new HashSet<String>();
      Iterator<Entity> entitiesToDeleteIterator = deletedObjects.get(entityClass).values().iterator();
      while (entitiesToDeleteIterator.hasNext()) {
        Entity entityToDelete = entitiesToDeleteIterator.next();
        if (!ids.contains(entityToDelete.getId())) {
          ids.add(entityToDelete.getId());
        } else {
          entitiesToDeleteIterator.remove(); // Removing duplicate deletes
        }
      }
      
      // Now we have the deleted ids, we can remove the inserted objects (as they cancel each other)
      for (String id : ids) {
        if (insertedObjects.containsKey(entityClass) && insertedObjects.get(entityClass).containsKey(id)) {
          insertedObjects.get(entityClass).remove(id);
          deletedObjects.get(entityClass).remove(id);
        }
      }
      
    }
  }

  public void determineUpdatedObjects() {
    updatedObjects = new ArrayList<Entity>();
    Map<Class<?>, Map<String, CachedEntity>> cachedObjects = entityCache.getAllCachedEntities();
    for (Class<?> clazz : cachedObjects.keySet()) {

      Map<String, CachedEntity> classCache = cachedObjects.get(clazz);
      for (CachedEntity cachedObject : classCache.values()) {

        Entity cachedEntity = cachedObject.getEntity();
        
        // Executions are stored as a hierarchical tree, and updates are important to execute
        // even when the execution are deleted, as they can change the parent-child relationships.
        // For the other entities, this is not applicable and an update can be discarded when an update follows.
        
        if (!isEntityInserted(cachedEntity) && 
            (ExecutionEntity.class.isAssignableFrom(cachedEntity.getClass()) || !isEntityToBeDeleted(cachedEntity)) &&
            cachedObject.hasChanged() 
            ) {
          updatedObjects.add(cachedEntity);
        }
      }
    }
  }
  
  protected void debugFlush() {
    log.debug("Flushing dbSqlSession");
    int nrOfInserts = 0, nrOfUpdates = 0, nrOfDeletes = 0;
    for (Map<String, Entity> insertedObjectMap: insertedObjects.values()) {
      for (Entity insertedObject : insertedObjectMap.values()) {
        log.debug("  insert {}", insertedObject);
        nrOfInserts++;
      }
    }
    for (Entity updatedObject : updatedObjects) {
      log.debug("  update {}", updatedObject);
      nrOfUpdates++;
    }
    for (Map<String, Entity> deletedObjectMap: deletedObjects.values()) {
      for (Entity deletedObject : deletedObjectMap.values()) {
        log.debug("  delete {} with id {}", deletedObject, deletedObject.getId());
        nrOfDeletes++;
      }
    }
    for (Collection<BulkDeleteOperation> bulkDeleteOperationList : bulkDeleteOperations.values()) {
      for (BulkDeleteOperation bulkDeleteOperation : bulkDeleteOperationList) {
        log.debug("  {}", bulkDeleteOperation);
        nrOfDeletes++;
      }
    }
    log.debug("flush summary: {} insert, {} update, {} delete.", nrOfInserts, nrOfUpdates, nrOfDeletes);
    log.debug("now executing flush...");
  }
  
  public boolean isEntityInserted(Entity entity) {
    return insertedObjects.containsKey(entity.getClass())
        && insertedObjects.get(entity.getClass()).containsKey(entity.getId());
  }
  
  public boolean isEntityToBeDeleted(Entity entity) {
    return deletedObjects.containsKey(entity.getClass())
        && deletedObjects.get(entity.getClass()).containsKey(entity.getId());
  }

  protected void flushInserts() {
    
    if (insertedObjects.size() == 0) {
      return;
    }
  	
  	// Handle in entity dependency order
    for (Class<? extends Entity> entityClass : EntityDependencyOrder.INSERT_ORDER) {
      if (insertedObjects.containsKey(entityClass)) {
        flushInsertEntities(entityClass, insertedObjects.get(entityClass).values());
      	insertedObjects.remove(entityClass);
      }
    }
    
    // Next, in case of custom entities or we've screwed up and forgotten some entity
    if (insertedObjects.size() > 0) {
	    for (Class<? extends Entity> entityClass : insertedObjects.keySet()) {
      	flushInsertEntities(entityClass, insertedObjects.get(entityClass).values());
	    }
    }
    
    insertedObjects.clear();
  }

	protected void flushInsertEntities(Class<? extends Entity> entityClass, Collection<Entity> entitiesToInsert) {
	  if (entitiesToInsert.size() == 1) {
	  	flushRegularInsert(entitiesToInsert.iterator().next(), entityClass);
	  } else if (Boolean.FALSE.equals(dbSqlSessionFactory.isBulkInsertable(entityClass))) {
	  	for (Entity entity : entitiesToInsert) {
	  		flushRegularInsert(entity, entityClass);
	  	}
	  }	else {
	  	flushBulkInsert(entitiesToInsert, entityClass);
	  }
  }
	
	protected Collection<Entity> orderExecutionEntities(Map<String, Entity> executionEntities, boolean parentBeforeChildExecution) {
	  
	  // For insertion: parent executions should go before child executions
	  
	  List<Entity> result = new ArrayList<Entity>(executionEntities.size());
	  
	  // Gather parent-child relationships
	  Map<String, String> childToParentExecutionMapping = new HashMap<String, String>();
	  Map<String, List<ExecutionEntity>> parentToChildrenMapping = new HashMap<String, List<ExecutionEntity>>();
    
	  Collection<Entity> executionCollection = executionEntities.values();
    Iterator<Entity> executionIterator = executionCollection.iterator();
    while (executionIterator.hasNext()) {
      ExecutionEntity currentExecutionEntity = (ExecutionEntity) executionIterator.next();
      String parentId = currentExecutionEntity.getParentId();
      String superExecutionId = currentExecutionEntity.getSuperExecutionId();

      String parentKey = parentId != null ? parentId : superExecutionId;
      childToParentExecutionMapping.put(currentExecutionEntity.getId(), parentKey);
      
      if (!parentToChildrenMapping.containsKey(parentKey)) {
        parentToChildrenMapping.put(parentKey, new ArrayList<ExecutionEntity>());
      }
      parentToChildrenMapping.get(parentKey).add(currentExecutionEntity);
    }
    
    // Loop over all entities, and insert in the correct order
    Set<String> handledExecutionIds = new HashSet<String>(executionEntities.size());
    executionIterator = executionCollection.iterator();
    while (executionIterator.hasNext()) {
      ExecutionEntity currentExecutionEntity = (ExecutionEntity) executionIterator.next();
      String executionId = currentExecutionEntity.getId();
      
      if (!handledExecutionIds.contains(executionId)) {
        String parentId = childToParentExecutionMapping.get(executionId);
        if (parentId != null) {
          while (parentId != null) {
            String newParentId = childToParentExecutionMapping.get(parentId);
            if (newParentId == null) {
              break;
            }
            parentId = newParentId;
          }
        }
        
        if (parentId == null) {
          parentId = executionId;
        }

        if (executionEntities.containsKey(parentId) && !handledExecutionIds.contains(parentId)) {
          handledExecutionIds.add(parentId);
          if (parentBeforeChildExecution) {
            result.add(executionEntities.get(parentId));
          } else {
            result.add(0, executionEntities.get(parentId));
          }
        }
        
        collectChildExecutionsForInsertion(result, parentToChildrenMapping, handledExecutionIds, parentId, parentBeforeChildExecution);
        
      }
    }
    
    return result;
	}

  protected void collectChildExecutionsForInsertion(List<Entity> result, Map<String, List<ExecutionEntity>> parentToChildrenMapping, 
      Set<String> handledExecutionIds, String parentId, boolean parentBeforeChildExecution) {
    List<ExecutionEntity> childExecutionEntities = parentToChildrenMapping.get(parentId);
    
    if (childExecutionEntities == null) {
      return;
    }
    
    for (ExecutionEntity childExecutionEntity : childExecutionEntities) {
      handledExecutionIds.add(childExecutionEntity.getId());
      if (parentBeforeChildExecution) {
        result.add(childExecutionEntity);
      } else {
        result.add(0, childExecutionEntity);
      }
      
      collectChildExecutionsForInsertion(result, parentToChildrenMapping, handledExecutionIds, childExecutionEntity.getId(), parentBeforeChildExecution);
    }
  }
	
  protected void flushRegularInsert(Entity entity, Class<? extends Entity> clazz) {
  	 String insertStatement = dbSqlSessionFactory.getInsertStatement(entity);
     insertStatement = dbSqlSessionFactory.mapStatement(insertStatement);

     if (insertStatement==null) {
       throw new ActivitiException("no insert statement for " + entity.getClass() + " in the ibatis mapping files");
     }
     
     log.debug("inserting: {}", entity);
     sqlSession.insert(insertStatement, entity);
     
     // See https://activiti.atlassian.net/browse/ACT-1290
     if (entity instanceof HasRevision) {
       incrementRevision(entity);
     }
  }

  protected void flushBulkInsert(Collection<Entity> entities, Class<? extends Entity> clazz) {
    String insertStatement = dbSqlSessionFactory.getBulkInsertStatement(clazz);
    insertStatement = dbSqlSessionFactory.mapStatement(insertStatement);

    if (insertStatement==null) {
      throw new ActivitiException("no insert statement for " + entities.iterator().next().getClass() + " in the ibatis mapping files");
    }

    Iterator<Entity> entityIterator = entities.iterator();
    Boolean hasRevision = null;
    
    while (entityIterator.hasNext()) {
      List<Entity> subList = new ArrayList<Entity>();
      int index = 0;
      while (entityIterator.hasNext() && index < dbSqlSessionFactory.getMaxNrOfStatementsInBulkInsert()) {
        Entity entity = entityIterator.next();
        subList.add(entity);
        
        if (hasRevision == null) {
          hasRevision = entity instanceof HasRevision;
        }
        index++;
      }
      sqlSession.insert(insertStatement, subList);
    }
    
    if (hasRevision != null && hasRevision) {
      entityIterator = entities.iterator();
      while (entityIterator.hasNext()) {
        incrementRevision(entityIterator.next());
      }
    }
    
  }

  protected void incrementRevision(Entity insertedObject) {
    HasRevision revisionEntity = (HasRevision) insertedObject;
    if (revisionEntity.getRevision() == 0) {
      revisionEntity.setRevision(revisionEntity.getRevisionNext());
    }
  }


  protected void flushUpdates() {
    for (Entity updatedObject : updatedObjects) {
      String updateStatement = dbSqlSessionFactory.getUpdateStatement(updatedObject);
      updateStatement = dbSqlSessionFactory.mapStatement(updateStatement);

      if (updateStatement == null) {
        throw new ActivitiException("no update statement for " + updatedObject.getClass() + " in the ibatis mapping files");
      }

      log.debug("updating: {}", updatedObject);
      int updatedRecords = sqlSession.update(updateStatement, updatedObject);
      if (updatedRecords == 0) {
        throw new ActivitiOptimisticLockingException(updatedObject + " was updated by another transaction concurrently");
      }

      // See https://activiti.atlassian.net/browse/ACT-1290
      if (updatedObject instanceof HasRevision) {
        ((HasRevision) updatedObject).setRevision(((HasRevision) updatedObject).getRevisionNext());
      }

    }
    updatedObjects.clear();
  }

  protected void flushDeletes() {
    
    if (deletedObjects.size() == 0 && bulkDeleteOperations.size() == 0) {
      return;
    }
    
    // Handle in entity dependency order
    for (Class<? extends Entity> entityClass : EntityDependencyOrder.DELETE_ORDER) {
      if (deletedObjects.containsKey(entityClass)) {
        flushDeleteEntities(entityClass, deletedObjects.get(entityClass).values());
        deletedObjects.remove(entityClass);
      }
      flushBulkDeletes(entityClass);
    }
    
    // Next, in case of custom entities or we've screwed up and forgotten some entity
    if (deletedObjects.size() > 0) {
      for (Class<? extends Entity> entityClass : deletedObjects.keySet()) {
        flushDeleteEntities(entityClass, deletedObjects.get(entityClass).values());
        flushBulkDeletes(entityClass);
      }
    }
    
    deletedObjects.clear();
  }

  protected void flushBulkDeletes(Class<? extends Entity> entityClass) {
    // Bulk deletes
    if (bulkDeleteOperations.containsKey(entityClass)) {
      for (BulkDeleteOperation bulkDeleteOperation : bulkDeleteOperations.get(entityClass)) {
        bulkDeleteOperation.execute(sqlSession);
      }
    }
  }

  protected void flushDeleteEntities(Class<? extends Entity> entityClass, Collection<Entity> entitiesToDelete) {
    for (Entity entity : entitiesToDelete) {
      String deleteStatement = dbSqlSessionFactory.getDeleteStatement(entity.getClass());
      deleteStatement = dbSqlSessionFactory.mapStatement(deleteStatement);
      if (deleteStatement == null) {
        throw new ActivitiException("no delete statement for " + entity.getClass() + " in the ibatis mapping files");
      }

      // It only makes sense to check for optimistic locking exceptions
      // for objects that actually have a revision
      if (entity instanceof HasRevision) {
        int nrOfRowsDeleted = sqlSession.delete(deleteStatement, entity);
        if (nrOfRowsDeleted == 0) {
          throw new ActivitiOptimisticLockingException(entity + " was updated by another transaction concurrently");
        }
      } else {
        sqlSession.delete(deleteStatement, entity);
      }
    }
  }

  public void close() {
    sqlSession.close();
  }

  public void commit() {
    sqlSession.commit();
  }

  public void rollback() {
    sqlSession.rollback();
  }

  // schema operations
  // ////////////////////////////////////////////////////////

  public void dbSchemaCheckVersion() {
    try {
      String dbVersion = getDbVersion();
      if (!ProcessEngine.VERSION.equals(dbVersion)) {
        throw new ActivitiWrongDbException(ProcessEngine.VERSION, dbVersion);
      }

      String errorMessage = null;
      if (!isEngineTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "engine");
      }
      if (dbSqlSessionFactory.isDbHistoryUsed() && !isHistoryTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "history");
      }
      if (dbSqlSessionFactory.isDbIdentityUsed() && !isIdentityTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "identity");
      }

      if (errorMessage != null) {
        throw new ActivitiException("Activiti database problem: " + errorMessage);
      }

    } catch (Exception e) {
      if (isMissingTablesException(e)) {
        throw new ActivitiException(
            "no activiti tables in db. set <property name=\"databaseSchemaUpdate\" to value=\"true\" or value=\"create-drop\" (use create-drop for testing only!) in bean processEngineConfiguration in activiti.cfg.xml for automatic schema creation",
            e);
      } else {
        if (e instanceof RuntimeException) {
          throw (RuntimeException) e;
        } else {
          throw new ActivitiException("couldn't get db schema version", e);
        }
      }
    }

    log.debug("activiti db schema check successful");
  }

  protected String addMissingComponent(String missingComponents, String component) {
    if (missingComponents == null) {
      return "Tables missing for component(s) " + component;
    }
    return missingComponents + ", " + component;
  }

  protected String getDbVersion() {
    String selectSchemaVersionStatement = dbSqlSessionFactory.mapStatement("selectDbSchemaVersion");
    return (String) sqlSession.selectOne(selectSchemaVersionStatement);
  }

  public void dbSchemaCreate() {
    if (isEngineTablePresent()) {
      String dbVersion = getDbVersion();
      if (!ProcessEngine.VERSION.equals(dbVersion)) {
        throw new ActivitiWrongDbException(ProcessEngine.VERSION, dbVersion);
      }
    } else {
      dbSchemaCreateEngine();
    }

    if (dbSqlSessionFactory.isDbHistoryUsed()) {
      dbSchemaCreateHistory();
    }

    if (dbSqlSessionFactory.isDbIdentityUsed()) {
      dbSchemaCreateIdentity();
    }
  }

  protected void dbSchemaCreateIdentity() {
    executeMandatorySchemaResource("create", "identity");
  }

  protected void dbSchemaCreateHistory() {
    executeMandatorySchemaResource("create", "history");
  }

  protected void dbSchemaCreateEngine() {
    executeMandatorySchemaResource("create", "engine");
  }

  public void dbSchemaDrop() {
    executeMandatorySchemaResource("drop", "engine");
    if (dbSqlSessionFactory.isDbHistoryUsed()) {
      executeMandatorySchemaResource("drop", "history");
    }
    if (dbSqlSessionFactory.isDbIdentityUsed()) {
      executeMandatorySchemaResource("drop", "identity");
    }
  }

  public void dbSchemaPrune() {
    if (isHistoryTablePresent() && !dbSqlSessionFactory.isDbHistoryUsed()) {
      executeMandatorySchemaResource("drop", "history");
    }
    if (isIdentityTablePresent() && dbSqlSessionFactory.isDbIdentityUsed()) {
      executeMandatorySchemaResource("drop", "identity");
    }
  }

  public void executeMandatorySchemaResource(String operation, String component) {
    executeSchemaResource(operation, component, getResourceForDbOperation(operation, operation, component), false);
  }

  public static String[] JDBC_METADATA_TABLE_TYPES = { "TABLE" };

  public String dbSchemaUpdate() {

    String feedback = null;
    boolean isUpgradeNeeded = false;
    int matchingVersionIndex = -1;

    if (isEngineTablePresent()) {

      PropertyEntity dbVersionProperty = selectById(PropertyEntity.class, "schema.version");
      String dbVersion = dbVersionProperty.getValue();

      // Determine index in the sequence of Activiti releases
      matchingVersionIndex = findMatchingVersionIndex(dbVersion);
      
      // If no match has been found, but the version starts with '5.x', 
      // we assume it's the last version (see comment in the VERSIONS list)
      if (matchingVersionIndex < 0 && dbVersion != null && dbVersion.startsWith("5.")) {
        matchingVersionIndex = findMatchingVersionIndex(LAST_V5_VERSION);
      }

      // Exception when no match was found: unknown/unsupported version
      if (matchingVersionIndex < 0) {
        throw new ActivitiException("Could not update Activiti database schema: unknown version from database: '" + dbVersion + "'");
      }

      isUpgradeNeeded = (matchingVersionIndex != (ACTIVITI_VERSIONS.size() - 1));

      if (isUpgradeNeeded) {
        dbVersionProperty.setValue(ProcessEngine.VERSION);

        PropertyEntity dbHistoryProperty;
        if ("5.0".equals(dbVersion)) {
          dbHistoryProperty = Context.getCommandContext().getPropertyEntityManager().create();
          dbHistoryProperty.setName("schema.history");
          dbHistoryProperty.setValue("create(5.0)");
          insert(dbHistoryProperty);
        } else {
          dbHistoryProperty = selectById(PropertyEntity.class, "schema.history");
        }

        // Set upgrade history
        String dbHistoryValue = dbHistoryProperty.getValue() + " upgrade(" + dbVersion + "->" + ProcessEngine.VERSION + ")";
        dbHistoryProperty.setValue(dbHistoryValue);

        // Engine upgrade
        dbSchemaUpgrade("engine", matchingVersionIndex);
        feedback = "upgraded Activiti from " + dbVersion + " to " + ProcessEngine.VERSION;
      }

    } else {
      dbSchemaCreateEngine();
    }
    if (isHistoryTablePresent()) {
      if (isUpgradeNeeded) {
        dbSchemaUpgrade("history", matchingVersionIndex);
      }
    } else if (dbSqlSessionFactory.isDbHistoryUsed()) {
      dbSchemaCreateHistory();
    }

    if (isIdentityTablePresent()) {
      if (isUpgradeNeeded) {
        dbSchemaUpgrade("identity", matchingVersionIndex);
      }
    } else if (dbSqlSessionFactory.isDbIdentityUsed()) {
      dbSchemaCreateIdentity();
    }

    return feedback;
  }

  /**
   * Returns the index in the list of {@link #ACTIVITI_VERSIONS} matching the provided string version.
   * Returns -1 if no match can be found.  
   */
  protected int findMatchingVersionIndex(String dbVersion) {
    int index = 0;
    int matchingVersionIndex = -1;
    while (matchingVersionIndex < 0 && index < ACTIVITI_VERSIONS.size()) {
      if (ACTIVITI_VERSIONS.get(index).matches(dbVersion)) {
        matchingVersionIndex = index;
      } else {
        index++;
      }
    }
    return matchingVersionIndex;
  }

  public boolean isEngineTablePresent() {
    return isTablePresent("ACT_RU_EXECUTION");
  }

  public boolean isHistoryTablePresent() {
    return isTablePresent("ACT_HI_PROCINST");
  }

  public boolean isIdentityTablePresent() {
    return isTablePresent("ACT_ID_USER");
  }

  public boolean isTablePresent(String tableName) {
    // ACT-1610: in case the prefix IS the schema itself, we don't add the
    // prefix, since the check is already aware of the schema
    if (!dbSqlSessionFactory.isTablePrefixIsSchema()) {
      tableName = prependDatabaseTablePrefix(tableName);
    }

    Connection connection = null;
    try {
      connection = sqlSession.getConnection();
      DatabaseMetaData databaseMetaData = connection.getMetaData();
      ResultSet tables = null;

      String catalog = this.connectionMetadataDefaultCatalog;
      if (dbSqlSessionFactory.getDatabaseCatalog() != null && dbSqlSessionFactory.getDatabaseCatalog().length() > 0) {
        catalog = dbSqlSessionFactory.getDatabaseCatalog();
      }

      String schema = this.connectionMetadataDefaultSchema;
      if (dbSqlSessionFactory.getDatabaseSchema() != null && dbSqlSessionFactory.getDatabaseSchema().length() > 0) {
        schema = dbSqlSessionFactory.getDatabaseSchema();
      }

      String databaseType = dbSqlSessionFactory.getDatabaseType();

      if ("postgres".equals(databaseType)) {
        tableName = tableName.toLowerCase();
      } 
      
      if (schema != null && "oracle".equals(databaseType)) {
        schema = schema.toUpperCase();
      }
      
      if (catalog != null && catalog.length() == 0) {
        catalog = null;
      }

      try {
        tables = databaseMetaData.getTables(catalog, schema, tableName, JDBC_METADATA_TABLE_TYPES);
        return tables.next();
      } finally {
        try {
          tables.close();
        } catch (Exception e) {
          log.error("Error closing meta data tables", e);
        }
      }

    } catch (Exception e) {
      throw new ActivitiException("couldn't check if tables are already present using metadata: " + e.getMessage(), e);
    }
  }

  protected boolean isUpgradeNeeded(String versionInDatabase) {
    if (ProcessEngine.VERSION.equals(versionInDatabase)) {
      return false;
    }

    String cleanDbVersion = getCleanVersion(versionInDatabase);
    String[] cleanDbVersionSplitted = cleanDbVersion.split("\\.");
    int dbMajorVersion = Integer.valueOf(cleanDbVersionSplitted[0]);
    int dbMinorVersion = Integer.valueOf(cleanDbVersionSplitted[1]);

    String cleanEngineVersion = getCleanVersion(ProcessEngine.VERSION);
    String[] cleanEngineVersionSplitted = cleanEngineVersion.split("\\.");
    int engineMajorVersion = Integer.valueOf(cleanEngineVersionSplitted[0]);
    int engineMinorVersion = Integer.valueOf(cleanEngineVersionSplitted[1]);

    if ((dbMajorVersion > engineMajorVersion) || ((dbMajorVersion <= engineMajorVersion) && (dbMinorVersion > engineMinorVersion))) {
      throw new ActivitiException("Version of activiti database (" + versionInDatabase + ") is more recent than the engine (" + ProcessEngine.VERSION + ")");
    } else if (cleanDbVersion.compareTo(cleanEngineVersion) == 0) {
      // Versions don't match exactly, possibly snapshot is being used
      log.warn("Engine-version is the same, but not an exact match: {} vs. {}. Not performing database-upgrade.", versionInDatabase, ProcessEngine.VERSION);
      return false;
    }
    return true;
  }

  protected String getCleanVersion(String versionString) {
    Matcher matcher = CLEAN_VERSION_REGEX.matcher(versionString);
    if (!matcher.find()) {
      throw new ActivitiException("Illegal format for version: " + versionString);
    }

    String cleanString = matcher.group();
    try {
      Double.parseDouble(cleanString); // try to parse it, to see if it is
                                       // really a number
      return cleanString;
    } catch (NumberFormatException nfe) {
      throw new ActivitiException("Illegal format for version: " + versionString);
    }
  }

  protected String prependDatabaseTablePrefix(String tableName) {
    return dbSqlSessionFactory.getDatabaseTablePrefix() + tableName;
  }

  protected void dbSchemaUpgrade(final String component, final int currentDatabaseVersionsIndex) {
    ActivitiVersion activitiVersion = ACTIVITI_VERSIONS.get(currentDatabaseVersionsIndex);
    String dbVersion = activitiVersion.getMainVersion();
    log.info("upgrading activiti {} schema from {} to {}", component, dbVersion, ProcessEngine.VERSION);

    // Actual execution of schema DDL SQL
    for (int i = currentDatabaseVersionsIndex + 1; i < ACTIVITI_VERSIONS.size(); i++) {
      String nextVersion = ACTIVITI_VERSIONS.get(i).getMainVersion();

      // Taking care of -SNAPSHOT version in development
      if (nextVersion.endsWith("-SNAPSHOT")) {
        nextVersion = nextVersion.substring(0, nextVersion.length() - "-SNAPSHOT".length());
      }

      dbVersion = dbVersion.replace(".", "");
      nextVersion = nextVersion.replace(".", "");
      log.info("Upgrade needed: {} -> {}. Looking for schema update resource for component '{}'", dbVersion, nextVersion, component);
      executeSchemaResource("upgrade", component, getResourceForDbOperation("upgrade", "upgradestep." + dbVersion + ".to." + nextVersion, component), true);
      dbVersion = nextVersion;
    }
  }

  public String getResourceForDbOperation(String directory, String operation, String component) {
    String databaseType = dbSqlSessionFactory.getDatabaseType();
    return "org/activiti/db/" + directory + "/activiti." + databaseType + "." + operation + "." + component + ".sql";
  }

  public void executeSchemaResource(String operation, String component, String resourceName, boolean isOptional) {
    InputStream inputStream = null;
    try {
      inputStream = ReflectUtil.getResourceAsStream(resourceName);
      if (inputStream == null) {
        if (isOptional) {
          log.info("no schema resource {} for {}", resourceName, operation);
        } else {
          throw new ActivitiException("resource '" + resourceName + "' is not available");
        }
      } else {
        executeSchemaResource(operation, component, resourceName, inputStream);
      }

    } finally {
      IoUtil.closeSilently(inputStream);
    }
  }

  private void executeSchemaResource(String operation, String component, String resourceName, InputStream inputStream) {
    log.info("performing {} on {} with resource {}", operation, component, resourceName);
    String sqlStatement = null;
    String exceptionSqlStatement = null;
    try {
      Connection connection = sqlSession.getConnection();
      Exception exception = null;
      byte[] bytes = IoUtil.readInputStream(inputStream, resourceName);
      String ddlStatements = new String(bytes);

      // Special DDL handling for certain databases
      try {
        if (isMysql()) {
          DatabaseMetaData databaseMetaData = connection.getMetaData();
          int majorVersion = databaseMetaData.getDatabaseMajorVersion();
          int minorVersion = databaseMetaData.getDatabaseMinorVersion();
          log.info("Found MySQL: majorVersion=" + majorVersion + " minorVersion=" + minorVersion);

          // Special care for MySQL < 5.6
          if (majorVersion <= 5 && minorVersion < 6) {
            ddlStatements = updateDdlForMySqlVersionLowerThan56(ddlStatements);
          }
        }
      } catch (Exception e) {
        log.info("Could not get database metadata", e);
      }

      BufferedReader reader = new BufferedReader(new StringReader(ddlStatements));
      String line = readNextTrimmedLine(reader);
      boolean inOraclePlsqlBlock = false;
      while (line != null) {
        if (line.startsWith("# ")) {
          log.debug(line.substring(2));

        } else if (line.startsWith("-- ")) {
          log.debug(line.substring(3));

        } else if (line.startsWith("execute java ")) {
          String upgradestepClassName = line.substring(13).trim();
          DbUpgradeStep dbUpgradeStep = null;
          try {
            dbUpgradeStep = (DbUpgradeStep) ReflectUtil.instantiate(upgradestepClassName);
          } catch (ActivitiException e) {
            throw new ActivitiException("database update java class '" + upgradestepClassName + "' can't be instantiated: " + e.getMessage(), e);
          }
          try {
            log.debug("executing upgrade step java class {}", upgradestepClassName);
            dbUpgradeStep.execute(this);
          } catch (Exception e) {
            throw new ActivitiException("error while executing database update java class '" + upgradestepClassName + "': " + e.getMessage(), e);
          }

        } else if (line.length() > 0) {

          if (isOracle() && line.startsWith("begin")) {
            inOraclePlsqlBlock = true;
            sqlStatement = addSqlStatementPiece(sqlStatement, line);

          } else if ((line.endsWith(";") && inOraclePlsqlBlock == false) || (line.startsWith("/") && inOraclePlsqlBlock == true)) {

            if (inOraclePlsqlBlock) {
              inOraclePlsqlBlock = false;
            } else {
              sqlStatement = addSqlStatementPiece(sqlStatement, line.substring(0, line.length() - 1));
            }

            Statement jdbcStatement = connection.createStatement();
            try {
              // no logging needed as the connection will log it
              log.debug("SQL: {}", sqlStatement);
              jdbcStatement.execute(sqlStatement);
              jdbcStatement.close();
            } catch (Exception e) {
              if (exception == null) {
                exception = e;
                exceptionSqlStatement = sqlStatement;
              }
              log.error("problem during schema {}, statement {}", operation, sqlStatement, e);
            } finally {
              sqlStatement = null;
            }
          } else {
            sqlStatement = addSqlStatementPiece(sqlStatement, line);
          }
        }

        line = readNextTrimmedLine(reader);
      }

      if (exception != null) {
        throw exception;
      }

      log.debug("activiti db schema {} for component {} successful", operation, component);

    } catch (Exception e) {
      throw new ActivitiException("couldn't " + operation + " db schema: " + exceptionSqlStatement, e);
    }
  }

  /**
   * MySQL is funny when it comes to timestamps and dates.
   * 
   * More specifically, for a DDL statement like 'MYCOLUMN timestamp(3)': - MySQL 5.6.4+ has support for timestamps/dates with millisecond (or smaller) precision. The DDL above works and the data in
   * the table will have millisecond precision - MySQL < 5.5.3 allows the DDL statement, but ignores it. The DDL above works but the data won't have millisecond precision - MySQL 5.5.3 < [version] <
   * 5.6.4 gives and exception when using the DDL above.
   * 
   * Also, the 5.5 and 5.6 branches of MySQL are both actively developed and patched.
   * 
   * Hence, when doing auto-upgrade/creation of the Activiti tables, the default MySQL DDL file is used and all timestamps/datetimes are converted to not use the millisecond precision by string
   * replacement done in the method below.
   * 
   * If using the DDL files directly (which is a sane choice in production env.), there is a distinction between MySQL version < 5.6.
   */
  protected String updateDdlForMySqlVersionLowerThan56(String ddlStatements) {
    return ddlStatements.replace("timestamp(3)", "timestamp").replace("datetime(3)", "datetime").replace("TIMESTAMP(3)", "TIMESTAMP").replace("DATETIME(3)", "DATETIME");
  }

  protected String addSqlStatementPiece(String sqlStatement, String line) {
    if (sqlStatement == null) {
      return line;
    }
    return sqlStatement + " \n" + line;
  }

  protected String readNextTrimmedLine(BufferedReader reader) throws IOException {
    String line = reader.readLine();
    if (line != null) {
      line = line.trim();
    }
    return line;
  }

  protected boolean isMissingTablesException(Exception e) {
    String exceptionMessage = e.getMessage();
    if (e.getMessage() != null) {
      // Matches message returned from H2
      if ((exceptionMessage.indexOf("Table") != -1) && (exceptionMessage.indexOf("not found") != -1)) {
        return true;
      }

      // Message returned from MySQL and Oracle
      if (((exceptionMessage.indexOf("Table") != -1 || exceptionMessage.indexOf("table") != -1)) && (exceptionMessage.indexOf("doesn't exist") != -1)) {
        return true;
      }

      // Message returned from Postgres
      if (((exceptionMessage.indexOf("relation") != -1 || exceptionMessage.indexOf("table") != -1)) && (exceptionMessage.indexOf("does not exist") != -1)) {
        return true;
      }
    }
    return false;
  }

  public void performSchemaOperationsProcessEngineBuild() {
    String databaseSchemaUpdate = Context.getProcessEngineConfiguration().getDatabaseSchemaUpdate();
    log.debug("Executing performSchemaOperationsProcessEngineBuild with setting " + databaseSchemaUpdate);
    if (ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_DROP_CREATE.equals(databaseSchemaUpdate)) {
      try {
        dbSchemaDrop();
      } catch (RuntimeException e) {
        // ignore
      }
    }
    if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_CREATE_DROP.equals(databaseSchemaUpdate)
        || ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_DROP_CREATE.equals(databaseSchemaUpdate) || ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_CREATE.equals(databaseSchemaUpdate)) {
      dbSchemaCreate();

    } else if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE.equals(databaseSchemaUpdate)) {
      dbSchemaCheckVersion();

    } else if (ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE.equals(databaseSchemaUpdate)) {
      dbSchemaUpdate();
    }
  }

  public void performSchemaOperationsProcessEngineClose() {
    String databaseSchemaUpdate = Context.getProcessEngineConfiguration().getDatabaseSchemaUpdate();
    if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_CREATE_DROP.equals(databaseSchemaUpdate)) {
      dbSchemaDrop();
    }
  }

  public <T> T getCustomMapper(Class<T> type) {
    return sqlSession.getMapper(type);
  }
  
  public boolean isMysql() {
    return dbSqlSessionFactory.getDatabaseType().equals("mysql");
  }
  
  public boolean isOracle() {
    return dbSqlSessionFactory.getDatabaseType().equals("oracle");
  }

  // query factory methods
  // ////////////////////////////////////////////////////

  public DeploymentQueryImpl createDeploymentQuery() {
    return new DeploymentQueryImpl();
  }

  public ModelQueryImpl createModelQueryImpl() {
    return new ModelQueryImpl();
  }

  public ProcessDefinitionQueryImpl createProcessDefinitionQuery() {
    return new ProcessDefinitionQueryImpl();
  }

  public ProcessInstanceQueryImpl createProcessInstanceQuery() {
    return new ProcessInstanceQueryImpl();
  }

  public ExecutionQueryImpl createExecutionQuery() {
    return new ExecutionQueryImpl();
  }

  public TaskQueryImpl createTaskQuery() {
    return new TaskQueryImpl();
  }

  public JobQueryImpl createJobQuery() {
    return new JobQueryImpl();
  }

  public HistoricProcessInstanceQueryImpl createHistoricProcessInstanceQuery() {
    return new HistoricProcessInstanceQueryImpl();
  }

  public HistoricActivityInstanceQueryImpl createHistoricActivityInstanceQuery() {
    return new HistoricActivityInstanceQueryImpl();
  }

  public HistoricTaskInstanceQueryImpl createHistoricTaskInstanceQuery() {
    return new HistoricTaskInstanceQueryImpl();
  }

  public HistoricDetailQueryImpl createHistoricDetailQuery() {
    return new HistoricDetailQueryImpl();
  }

  public HistoricVariableInstanceQueryImpl createHistoricVariableInstanceQuery() {
    return new HistoricVariableInstanceQueryImpl();
  }

  public UserQueryImpl createUserQuery() {
    return new UserQueryImpl();
  }

  public GroupQueryImpl createGroupQuery() {
    return new GroupQueryImpl();
  }

  // getters and setters
  // //////////////////////////////////////////////////////

  public SqlSession getSqlSession() {
    return sqlSession;
  }

  public DbSqlSessionFactory getDbSqlSessionFactory() {
    return dbSqlSessionFactory;
  }

}
!@#$%
20190526_171716,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.db;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.ActivitiOptimisticLockingException;
import org.activiti.engine.ActivitiWrongDbException;
import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.delegate.event.ActivitiVariableEvent;
import org.activiti.engine.delegate.event.impl.ActivitiEventBuilder;
import org.activiti.engine.impl.DeploymentQueryImpl;
import org.activiti.engine.impl.ExecutionQueryImpl;
import org.activiti.engine.impl.GroupQueryImpl;
import org.activiti.engine.impl.HistoricActivityInstanceQueryImpl;
import org.activiti.engine.impl.HistoricDetailQueryImpl;
import org.activiti.engine.impl.HistoricProcessInstanceQueryImpl;
import org.activiti.engine.impl.HistoricTaskInstanceQueryImpl;
import org.activiti.engine.impl.HistoricVariableInstanceQueryImpl;
import org.activiti.engine.impl.JobQueryImpl;
import org.activiti.engine.impl.ModelQueryImpl;
import org.activiti.engine.impl.Page;
import org.activiti.engine.impl.ProcessDefinitionQueryImpl;
import org.activiti.engine.impl.ProcessInstanceQueryImpl;
import org.activiti.engine.impl.TaskQueryImpl;
import org.activiti.engine.impl.UserQueryImpl;
import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.db.PersistentObject;
import org.activiti.engine.impl.db.upgrade.DbUpgradeStep;
import org.activiti.engine.impl.history.HistoryLevel;
import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity;
import org.activiti.engine.impl.persistence.entity.PropertyEntity;
import org.activiti.engine.impl.persistence.entity.ResourceEntity;
import org.activiti.engine.impl.persistence.entity.UserEntity;
import org.activiti.engine.impl.persistence.entity.VariableInstanceEntity;
import org.activiti.engine.impl.util.IoUtil;
import org.activiti.engine.impl.util.ReflectUtil;
import org.activiti.engine.impl.variable.DeserializedObject;
import org.apache.ibatis.session.SqlSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** responsibilities:
 *   - delayed flushing of inserts updates and deletes
 *   - optional dirty checking
 *   - db specific statement name mapping
 *   
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class DbSqlSession implements Session {
  
  private static final Logger log = LoggerFactory.getLogger(DbSqlSession.class);
  
  private static final Pattern CLEAN_VERSION_REGEX = Pattern.compile("\\d\\.\\d*");
  
  private static final List<ActivitiVersion> ACTIVITI_VERSIONS = new ArrayList<ActivitiVersion>();
  static {
	  
	  /* Previous */
	  
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.7"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.8"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.9"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.10"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.11"));
	  
	  // 5.12.1 was a bugfix release on 5.12 and did NOT change the version in ACT_GE_PROPERTY
	  // On top of that, DB2 create script for 5.12.1 was shipped with a 'T' suffix ...
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.12", Arrays.asList("5.12.1", "5.12T")));
	  
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.13"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.14"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.15"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.15.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.2-SNAPSHOT"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.2"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.3.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.4.0"));

	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.2"));
	  
	  /* Current */
	  ACTIVITI_VERSIONS.add(new ActivitiVersion(ProcessEngine.VERSION));
  }

  protected SqlSession sqlSession;
  protected DbSqlSessionFactory dbSqlSessionFactory;
  protected List<PersistentObject> insertedObjects = new ArrayList<PersistentObject>();
  protected Map<Class<?>, Map<String, CachedObject>> cachedObjects = new HashMap<Class<?>, Map<String,CachedObject>>();
  protected List<DeleteOperation> deleteOperations = new ArrayList<DeleteOperation>();
  protected List<DeserializedObject> deserializedObjects = new ArrayList<DeserializedObject>();
  protected String connectionMetadataDefaultCatalog;
  protected String connectionMetadataDefaultSchema;
  
  protected boolean isOptimizeDeleteOperationsEnabled;

  public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.isOptimizeDeleteOperationsEnabled = dbSqlSessionFactory.isOptimizeDeleteOperationsEnabled();
    this.sqlSession = dbSqlSessionFactory
      .getSqlSessionFactory()
      .openSession();
  }

  public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory, Connection connection, String catalog, String schema) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.sqlSession = dbSqlSessionFactory
      .getSqlSessionFactory()
      .openSession(connection);
    this.connectionMetadataDefaultCatalog = catalog;
    this.connectionMetadataDefaultSchema = schema;
  }
  
  // Touch  ///////////////////////////////////////////////////////////////////
  // brings the given persistenObject to the top if it already exists
  public void touch(PersistentObject persistentObject) {
	  if (persistentObject.getId()==null) {
		  throw new ActivitiException("Cannot touch " + persistentObject.getClass() + " with no id");
	  }
	  if (insertedObjects.contains(persistentObject)) {
		  insertedObjects.remove(persistentObject);
		  insertedObjects.add(persistentObject);
		  cachePut(persistentObject, false);
	  } 
   }
	  
  // insert ///////////////////////////////////////////////////////////////////
  
  
  public void insert(PersistentObject persistentObject) {
    if (persistentObject.getId()==null) {
      String id = dbSqlSessionFactory.getIdGenerator().getNextId();  
      persistentObject.setId(id);
    }
    insertedObjects.add(persistentObject);
    cachePut(persistentObject, false);
  }
  
  // update ///////////////////////////////////////////////////////////////////
  
  public void update(PersistentObject persistentObject) {
    cachePut(persistentObject, false);
  }
  
  public int update(String statement, Object parameters) {
     String updateStatement = dbSqlSessionFactory.mapStatement(statement);
     return getSqlSession().update(updateStatement, parameters);
  }
  
  // delete ///////////////////////////////////////////////////////////////////

  public void delete(String statement, Object parameter) {
    deleteOperations.add(new BulkDeleteOperation(statement, parameter));
  }
  
  public void delete(PersistentObject persistentObject) {
    for (DeleteOperation deleteOperation: deleteOperations) {
        if (deleteOperation.sameIdentity(persistentObject)) {
          log.debug("skipping redundant delete: {}", persistentObject);
          return; // Skip this delete. It was already added.
        }
    }
    
    deleteOperations.add(new CheckedDeleteOperation(persistentObject));
  }

  public interface DeleteOperation {
    
    boolean sameIdentity(PersistentObject other);

    void clearCache();
    
    void execute();
    
  }

  /**
   * Use this {@link DeleteOperation} to execute a dedicated delete statement.
   * It is important to note there won't be any optimistic locking checks done 
   * for these kind of delete operations!
   * 
   * For example, a usage of this operation would be to delete all variables for
   * a certain execution, when that certain execution is removed. The optimistic locking
   * happens on the execution, but the variables can be removed by a simple
   * 'delete from var_table where execution_id is xxx'. It could very well be there
   * are no variables, which would also work with this query, but not with the 
   * regular {@link CheckedDeleteOperation}. 
   */
  public class BulkDeleteOperation implements DeleteOperation {
    private String statement;
    private Object parameter;
    
    public BulkDeleteOperation(String statement, Object parameter) {
      this.statement = dbSqlSessionFactory.mapStatement(statement);
      this.parameter = parameter;
    }
    
    @Override
    public boolean sameIdentity(PersistentObject other) {
      // this implementation is unable to determine what the identity of the removed object(s) will be.
      return false;
    }

    @Override
    public void clearCache() {
      // this implementation cannot clear the object(s) to be removed from the cache.
    }
    
    @Override
    public void execute() {
      sqlSession.delete(statement, parameter);
    }
    
    @Override
    public String toString() {
      return "bulk delete: " + statement + "(" + parameter + ")";
    }
  }
  
  /**
   * A {@link DeleteOperation} that checks for concurrent modifications if the persistent object implements {@link HasRevision}.
   * That is, it employs optimisting concurrency control. Used when the persistent object has been fetched already.
   */
  public class CheckedDeleteOperation implements DeleteOperation {
    protected final PersistentObject persistentObject;
    
    public CheckedDeleteOperation(PersistentObject persistentObject) {
      this.persistentObject = persistentObject;
    }
    
    @Override
    public boolean sameIdentity(PersistentObject other) {
      return persistentObject.getClass().equals(other.getClass())
          && persistentObject.getId().equals(other.getId());
    }

    @Override
    public void clearCache() {
      cacheRemove(persistentObject.getClass(), persistentObject.getId());
    }
    
    @Override
    public void execute() {
      String deleteStatement = dbSqlSessionFactory.getDeleteStatement(persistentObject.getClass());
      deleteStatement = dbSqlSessionFactory.mapStatement(deleteStatement);
      if (deleteStatement == null) {
        throw new ActivitiException("no delete statement for " + persistentObject.getClass() + " in the ibatis mapping files");
      }
      
      // It only makes sense to check for optimistic locking exceptions for objects that actually have a revision
      if (persistentObject instanceof HasRevision) {
        int nrOfRowsDeleted = sqlSession.delete(deleteStatement, persistentObject);
        if (nrOfRowsDeleted == 0) {
          throw new ActivitiOptimisticLockingException(persistentObject + " was updated by another transaction concurrently");
        }
      } else {
        sqlSession.delete(deleteStatement, persistentObject);
      }
    }

    public PersistentObject getPersistentObject() {
      return persistentObject;
    }

    @Override
    public String toString() {
      return "delete " + persistentObject;
    }
  }
  
  
  /**
   * A bulk version of the {@link CheckedDeleteOperation}.
   */
  public class BulkCheckedDeleteOperation implements DeleteOperation {
  	
  	protected Class<? extends PersistentObject> persistentObjectClass;
    protected List<PersistentObject> persistentObjects = new ArrayList<PersistentObject>();
    
    public BulkCheckedDeleteOperation(Class<? extends PersistentObject> persistentObjectClass) {
    	this.persistentObjectClass = persistentObjectClass;
    }
    
    public void addPersistentObject(PersistentObject persistentObject) {
    	persistentObjects.add(persistentObject);
    }
    
    @Override
    public boolean sameIdentity(PersistentObject other) {
    	for (PersistentObject persistentObject : persistentObjects) {
    		if (persistentObject.getClass().equals(other.getClass()) && persistentObject.getId().equals(other.getId())) {
    			return true;
    		}
    	}
    	return false;
    }

    @Override
    public void clearCache() {
    	for (PersistentObject persistentObject : persistentObjects) {
    		cacheRemove(persistentObject.getClass(), persistentObject.getId());
    	}
    }
    
    @Override
    public void execute() {
    	
    	if (persistentObjects.isEmpty()) {
    		return;
    	}
    	
      String bulkDeleteStatement = dbSqlSessionFactory.getBulkDeleteStatement(persistentObjectClass);
      bulkDeleteStatement = dbSqlSessionFactory.mapStatement(bulkDeleteStatement);
      if (bulkDeleteStatement == null) {
        throw new ActivitiException("no bulk delete statement for " + persistentObjectClass + " in the mapping files");
      }
      
      // It only makes sense to check for optimistic locking exceptions for objects that actually have a revision
      if (persistentObjects.get(0) instanceof HasRevision) {
        int nrOfRowsDeleted = sqlSession.delete(bulkDeleteStatement, persistentObjects);
        if (nrOfRowsDeleted < persistentObjects.size()) {
          throw new ActivitiOptimisticLockingException("One of the entities " + persistentObjectClass 
          		+ " was updated by another transaction concurrently while trying to do a bulk delete");
        }
      } else {
        sqlSession.delete(bulkDeleteStatement, persistentObjects);
      }
    }
    
    public Class<? extends PersistentObject> getPersistentObjectClass() {
			return persistentObjectClass;
		}

		public void setPersistentObjectClass(
		    Class<? extends PersistentObject> persistentObjectClass) {
			this.persistentObjectClass = persistentObjectClass;
		}

		public List<PersistentObject> getPersistentObjects() {
			return persistentObjects;
		}

		public void setPersistentObjects(List<PersistentObject> persistentObjects) {
			this.persistentObjects = persistentObjects;
		}

		@Override
    public String toString() {
      return "bulk delete of " + persistentObjects.size() + (!persistentObjects.isEmpty() ? " entities of " + persistentObjects.get(0).getClass() : 0 );
    }
  }
  
  // select ///////////////////////////////////////////////////////////////////

  @SuppressWarnings({ "rawtypes" })
  public List selectList(String statement) {
    return selectList(statement, null, 0, Integer.MAX_VALUE);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter) {  
    return selectList(statement, parameter, 0, Integer.MAX_VALUE);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, Page page) {   
    if (page!=null) {
      return selectList(statement, parameter, page.getFirstResult(), page.getMaxResults());
    } else {
      return selectList(statement, parameter, 0, Integer.MAX_VALUE);
    }
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter, Page page) {   
    return selectList(statement, parameter);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, int firstResult, int maxResults) {   
    return selectList(statement, new ListQueryParameterObject(parameter, firstResult, maxResults));
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter) {
    return selectListWithRawParameter(statement, parameter, parameter.getFirstResult(), parameter.getMaxResults());
  }
  
  @SuppressWarnings({ "rawtypes", "unchecked" })
  public List selectListWithRawParameter(String statement, Object parameter, int firstResult, int maxResults) {
    statement = dbSqlSessionFactory.mapStatement(statement);    
    if (firstResult == -1 ||  maxResults == -1) {
      return Collections.EMPTY_LIST;
    }    
    List loadedObjects = sqlSession.selectList(statement, parameter);
    return filterLoadedObjects(loadedObjects);
  }
  
  @SuppressWarnings({ "rawtypes" })
  public List selectListWithRawParameterWithoutFilter(String statement, Object parameter, int firstResult, int maxResults) {
    statement = dbSqlSessionFactory.mapStatement(statement);    
    if (firstResult == -1 ||  maxResults == -1) {
      return Collections.EMPTY_LIST;
    }    
    return sqlSession.selectList(statement, parameter);
  }

  public Object selectOne(String statement, Object parameter) {
    statement = dbSqlSessionFactory.mapStatement(statement);
    Object result = sqlSession.selectOne(statement, parameter);
    if (result instanceof PersistentObject) {
      PersistentObject loadedObject = (PersistentObject) result;
      result = cacheFilter(loadedObject);
    }
    return result;
  }
  
  @SuppressWarnings("unchecked")
  public <T extends PersistentObject> T selectById(Class<T> entityClass, String id) {
    T persistentObject = cacheGet(entityClass, id);
    if (persistentObject!=null) {
      return persistentObject;
    }
    String selectStatement = dbSqlSessionFactory.getSelectStatement(entityClass);
    selectStatement = dbSqlSessionFactory.mapStatement(selectStatement);
    persistentObject = (T) sqlSession.selectOne(selectStatement, id);
    if (persistentObject==null) {
      return null;
    }
    cachePut(persistentObject, true);
    return persistentObject;
  }

  // internal session cache ///////////////////////////////////////////////////
  
  @SuppressWarnings("rawtypes")
  protected List filterLoadedObjects(List<Object> loadedObjects) {
    if (loadedObjects.isEmpty()) {
      return loadedObjects;
    }
    if (!(loadedObjects.get(0) instanceof PersistentObject)) {
      return loadedObjects;
    }
    
    List<PersistentObject> filteredObjects = new ArrayList<PersistentObject>(loadedObjects.size());
    for (Object loadedObject: loadedObjects) {
      PersistentObject cachedPersistentObject = cacheFilter((PersistentObject) loadedObject);
      filteredObjects.add(cachedPersistentObject);
    }
    return filteredObjects;
  }

  protected CachedObject cachePut(PersistentObject persistentObject, boolean storeState) {
    Map<String, CachedObject> classCache = cachedObjects.get(persistentObject.getClass());
    if (classCache==null) {
      classCache = new HashMap<String, CachedObject>();
      cachedObjects.put(persistentObject.getClass(), classCache);
    }
    CachedObject cachedObject = new CachedObject(persistentObject, storeState);
    classCache.put(persistentObject.getId(), cachedObject);
    return cachedObject;
  }
  
  /** returns the object in the cache.  if this object was loaded before, 
   * then the original object is returned.  if this is the first time 
   * this object is loaded, then the loadedObject is added to the cache. */
  protected PersistentObject cacheFilter(PersistentObject persistentObject) {
    PersistentObject cachedPersistentObject = cacheGet(persistentObject.getClass(), persistentObject.getId());
    if (cachedPersistentObject!=null) {
      return cachedPersistentObject;
    }
    cachePut(persistentObject, true);
    return persistentObject;
  }

  @SuppressWarnings("unchecked")
  protected <T> T cacheGet(Class<T> entityClass, String id) {
    CachedObject cachedObject = null;
    Map<String, CachedObject> classCache = cachedObjects.get(entityClass);
    if (classCache!=null) {
      cachedObject = classCache.get(id);
    }
    if (cachedObject!=null) {
      return (T) cachedObject.getPersistentObject();
    }
    return null;
  }
  
  protected void cacheRemove(Class<?> persistentObjectClass, String persistentObjectId) {
    Map<String, CachedObject> classCache = cachedObjects.get(persistentObjectClass);
    if (classCache==null) {
      return;
    }
    classCache.remove(persistentObjectId);
  }
  
  @SuppressWarnings("unchecked")
  public <T> List<T> findInCache(Class<T> entityClass) {
    Map<String, CachedObject> classCache = cachedObjects.get(entityClass);
    if (classCache!=null) {
      List<T> entities = new ArrayList<T>(classCache.size());
      for (CachedObject cachedObject: classCache.values()) {
        entities.add((T) cachedObject.getPersistentObject());
      }
      return entities;
    }
    return Collections.emptyList();
  }
  
  public <T> T findInCache(Class<T> entityClass, String id) {
    return cacheGet(entityClass, id);
  }
  
  public static class CachedObject {
    protected PersistentObject persistentObject;
    protected Object persistentObjectState;
    
    public CachedObject(PersistentObject persistentObject, boolean storeState) {
      this.persistentObject = persistentObject;
      if (storeState) {
        this.persistentObjectState = persistentObject.getPersistentState();
      }
    }

    public PersistentObject getPersistentObject() {
      return persistentObject;
    }

    public Object getPersistentObjectState() {
      return persistentObjectState;
    }
  }

  // deserialized objects /////////////////////////////////////////////////////
  
  public void addDeserializedObject(DeserializedObject deserializedObject) {
  	deserializedObjects.add(deserializedObject);
  }

  // flush ////////////////////////////////////////////////////////////////////

  @Override
  public void flush() {
    List<DeleteOperation> removedOperations = removeUnnecessaryOperations();
    
    flushDeserializedObjects();
    List<PersistentObject> updatedObjects = getUpdatedObjects();
    
    if (log.isDebugEnabled()) {
      log.debug("flush summary: {} insert, {} update, {} delete.", insertedObjects.size(), updatedObjects.size(), deleteOperations.size());
      for (PersistentObject insertedObject: insertedObjects) {
        log.debug("  insert {}", insertedObject);
      }
      for (PersistentObject updatedObject: updatedObjects) {
        log.debug("  update {}", updatedObject);
      }
      for (DeleteOperation deleteOperation: deleteOperations) {
        log.debug("  {}", deleteOperation);
      }
      log.debug("now executing flush...");
    }

    flushInserts();
    flushUpdates(updatedObjects);
    flushDeletes(removedOperations);
  }

  /**
   * Clears all deleted and inserted objects from the cache, 
   * and removes inserts and deletes that cancel each other.
   */
  protected List<DeleteOperation> removeUnnecessaryOperations() {
    List<DeleteOperation> removedDeleteOperations = new ArrayList<DeleteOperation>();

    for (Iterator<DeleteOperation> deleteIt = deleteOperations.iterator(); deleteIt.hasNext();) {
      DeleteOperation deleteOperation = deleteIt.next();
      
      for (Iterator<PersistentObject> insertIt = insertedObjects.iterator(); insertIt.hasNext();) {
        PersistentObject insertedObject = insertIt.next();
        
        // if the deleted object is inserted,
        if (deleteOperation.sameIdentity(insertedObject)) {
          // remove the insert and the delete, they cancel each other
          insertIt.remove();
          deleteIt.remove();
          // add removed operations to be able to fire events
          removedDeleteOperations.add( deleteOperation);
        }
      }
      
      // in any case, remove the deleted object from the cache
      deleteOperation.clearCache();
    }
    
    for (PersistentObject insertedObject: insertedObjects) {
      cacheRemove(insertedObject.getClass(), insertedObject.getId());
    }

    return removedDeleteOperations;
  }
  
  /**
   * Optimizes the given delete operations:
   * for example, if there are two deletes for two different variables, merges this into
   * one bulk delete which improves performance
   */
  protected List<DeleteOperation> optimizeDeleteOperations(List<DeleteOperation> deleteOperations) {
  	
  	// No optimization possible for 0 or 1 operations
  	if (!isOptimizeDeleteOperationsEnabled || deleteOperations.size() <= 1) {
  		return deleteOperations;
  	}
  	
  	List<DeleteOperation> optimizedDeleteOperations = new ArrayList<DbSqlSession.DeleteOperation>();
  	boolean[] checkedIndices = new boolean[deleteOperations.size()];
  	for (int i=0; i<deleteOperations.size(); i++) {
  		
  		if (checkedIndices[i] == true) {
  			continue;
  		}
  		
  		DeleteOperation deleteOperation = deleteOperations.get(i);
  		boolean couldOptimize = false;
  		if (deleteOperation instanceof CheckedDeleteOperation) {
  			
  			PersistentObject persistentObject = ((CheckedDeleteOperation) deleteOperation).getPersistentObject();
  			if (persistentObject instanceof BulkDeleteable) {
				String bulkDeleteStatement = dbSqlSessionFactory.getBulkDeleteStatement(persistentObject.getClass());
				bulkDeleteStatement = dbSqlSessionFactory.mapStatement(bulkDeleteStatement);
				if (bulkDeleteStatement != null) {
					BulkCheckedDeleteOperation bulkCheckedDeleteOperation = null;
					
					// Find all objects of the same type
					for (int j=0; j<deleteOperations.size(); j++) {
						DeleteOperation otherDeleteOperation = deleteOperations.get(j);
						if (j != i && checkedIndices[j] == false && otherDeleteOperation instanceof CheckedDeleteOperation) {
							PersistentObject otherPersistentObject = ((CheckedDeleteOperation) otherDeleteOperation).getPersistentObject();
							if (otherPersistentObject.getClass().equals(persistentObject.getClass())) {
	  							if (bulkCheckedDeleteOperation == null) {
	  								bulkCheckedDeleteOperation = new BulkCheckedDeleteOperation(persistentObject.getClass());
	  								bulkCheckedDeleteOperation.addPersistentObject(persistentObject);
	  								optimizedDeleteOperations.add(bulkCheckedDeleteOperation);
	  							}
	  							couldOptimize = true;
	  							bulkCheckedDeleteOperation.addPersistentObject(otherPersistentObject);
	  							checkedIndices[j] = true;
							} else {
							    // We may only optimize subsequent delete operations of the same type, to prevent messing up 
							    // the order of deletes of related entities which may depend on the referenced entity being deleted before
							    break;
							}
						}
						
					}
				}
  			}
  		}
  		
   		if (!couldOptimize) {
  			optimizedDeleteOperations.add(deleteOperation);
  		}
  		checkedIndices[i]=true;
  		
  	}
  	return optimizedDeleteOperations;
  }

  protected void flushDeserializedObjects() {
    for (DeserializedObject deserializedObject: deserializedObjects) {
      deserializedObject.flush();
    }
  }

  public List<PersistentObject> getUpdatedObjects() {
    List<PersistentObject> updatedObjects = new ArrayList<PersistentObject>();
    for (Class<?> clazz: cachedObjects.keySet()) {
      
      Map<String, CachedObject> classCache = cachedObjects.get(clazz);
      for (CachedObject cachedObject: classCache.values()) {
        
        PersistentObject persistentObject = cachedObject.getPersistentObject();
        if (!isPersistentObjectDeleted(persistentObject)) {
          Object originalState = cachedObject.getPersistentObjectState();
          if (persistentObject.getPersistentState() != null && 
          		!persistentObject.getPersistentState().equals(originalState)) {
            updatedObjects.add(persistentObject);
          } else {
            log.trace("loaded object '{}' was not updated", persistentObject);
          }
        }
        
      }
      
    }
    return updatedObjects;
  }
  
  protected boolean isPersistentObjectDeleted(PersistentObject persistentObject) {
    for (DeleteOperation deleteOperation : deleteOperations) {
      if (deleteOperation.sameIdentity(persistentObject)) {
        return true;
      }
    }
    return false;
  }
  
  public <T extends PersistentObject> List<T> pruneDeletedEntities(List<T> listToPrune) {
    List<T> prunedList = new ArrayList<T>(listToPrune);
    for (T potentiallyDeleted : listToPrune) {
      for (DeleteOperation deleteOperation: deleteOperations) {
          
        if (deleteOperation.sameIdentity(potentiallyDeleted)) {
          prunedList.remove(potentiallyDeleted);
        }
          
      }
    }
    return prunedList;
  }

  protected void flushInserts() {
    LinkedHashMap<Class<? extends PersistentObject>, List<PersistentObject>> bulkInsertHandledMap =
        new LinkedHashMap<Class<? extends PersistentObject>, List<PersistentObject>>();
    for (PersistentObject insertedObject: insertedObjects) {
      if (!bulkInsertHandledMap.containsKey(insertedObject.getClass())) {
        bulkInsertHandledMap.put(insertedObject.getClass(), new ArrayList<PersistentObject>());
      }
      bulkInsertHandledMap.get(insertedObject.getClass()).add(insertedObject);
    }
    log.info("Insert queries collection formed: " + bulkInsertHandledMap);
    // First process for entities in order of dependency requirement
    for (EntityDependencyOrder entityName : EntityDependencyOrder.values()) {
      if (!bulkInsertHandledMap.containsKey(entityName.getClazz())) {
        continue;
      }
      flushBulkInserts(bulkInsertHandledMap.get(entityName.getClazz()), entityName.getClazz());
      bulkInsertHandledMap.remove(entityName.getClazz());
    }
    // Next, process for all remaining entities
    for (Class<? extends PersistentObject> clazz : bulkInsertHandledMap.keySet()) {
      flushBulkInserts(bulkInsertHandledMap.get(clazz), clazz);
    }
    insertedObjects.clear();
  }

  private void flushBulkInserts(List<PersistentObject> variableList, Class<? extends PersistentObject> clazz) {
    String insertStatement = dbSqlSessionFactory.getBulkInsertStatement(clazz);
    insertStatement = dbSqlSessionFactory.mapStatement(insertStatement);
    log.info("Insert statement to be executed:" + insertStatement);

    if (insertStatement==null) {
      throw new ActivitiException("no insert statement for "+variableList.get(0).getClass()+" in the ibatis mapping files");
    }

    log.info("inserting: {}", variableList);
    sqlSession.insert(insertStatement, variableList);

    if (variableList.get(0) instanceof HasRevision) {
      for (PersistentObject insertedObject: variableList) {
        ((HasRevision) insertedObject).setRevision(((HasRevision) insertedObject).getRevisionNext());
      }
    }
  }

  protected void flushUpdates(List<PersistentObject> updatedObjects) {
    for (PersistentObject updatedObject: updatedObjects) {
      String updateStatement = dbSqlSessionFactory.getUpdateStatement(updatedObject);
      updateStatement = dbSqlSessionFactory.mapStatement(updateStatement);
      
      if (updateStatement==null) {
        throw new ActivitiException("no update statement for "+updatedObject.getClass()+" in the ibatis mapping files");
      }
      
      log.debug("updating: {}", updatedObject);
      int updatedRecords = sqlSession.update(updateStatement, updatedObject);
      if (updatedRecords!=1) {
        throw new ActivitiOptimisticLockingException(updatedObject + " was updated by another transaction concurrently");
      } 
      
      // See http://jira.codehaus.org/browse/ACT-1290
      if (updatedObject instanceof HasRevision) {
        ((HasRevision) updatedObject).setRevision(((HasRevision) updatedObject).getRevisionNext());
      }
      
    }
    updatedObjects.clear();
  }

  protected void flushDeletes(List<DeleteOperation> removedOperations) {
    boolean dispatchEvent = Context.getProcessEngineConfiguration().getEventDispatcher().isEnabled();

    flushRegularDeletes(dispatchEvent);

    if (dispatchEvent) {
      dispatchEventsForRemovedOperations(removedOperations);
    }

    deleteOperations.clear();
  }

  protected void dispatchEventsForRemovedOperations(List<DeleteOperation> removedOperations) {
    for (DeleteOperation delete : removedOperations) {
      // dispatch removed delete events
      if (delete instanceof CheckedDeleteOperation) {
        CheckedDeleteOperation checkedDeleteOperation = (CheckedDeleteOperation) delete;
        PersistentObject persistentObject = checkedDeleteOperation.getPersistentObject();
        if (persistentObject instanceof VariableInstanceEntity) {
          VariableInstanceEntity variableInstance = (VariableInstanceEntity) persistentObject;
          Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
            createVariableDeleteEvent(variableInstance)
          );
        }
      }
    }
  }

  protected static ActivitiVariableEvent createVariableDeleteEvent(VariableInstanceEntity variableInstance) {
    return ActivitiEventBuilder.createVariableEvent(ActivitiEventType.VARIABLE_DELETED, variableInstance.getName(), null, variableInstance.getType(),
    		variableInstance.getTaskId(), variableInstance.getExecutionId(), variableInstance.getProcessInstanceId(), null);
  }

  protected void flushRegularDeletes(boolean dispatchEvent) {
  	List<DeleteOperation> optimizedDeleteOperations = optimizeDeleteOperations(deleteOperations);
    for (DeleteOperation delete : optimizedDeleteOperations) {
//  	for (DeleteOperation delete : deleteOperations) {
      log.debug("executing: {}", delete);

      delete.execute();

      //  fire event for variable delete operation. (BulkDeleteOperation is not taken into account)
      if (dispatchEvent) {
        //  prepare delete event to fire for variable delete operation. (BulkDeleteOperation is not taken into account)
        if (delete instanceof CheckedDeleteOperation) {
          CheckedDeleteOperation checkedDeleteOperation = (CheckedDeleteOperation) delete;
          PersistentObject persistentObject = checkedDeleteOperation.getPersistentObject();
          if (persistentObject instanceof VariableInstanceEntity) {
            VariableInstanceEntity variableInstance = (VariableInstanceEntity) persistentObject;
            Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
              createVariableDeleteEvent(variableInstance)
            );
          }
        } else if (delete instanceof BulkCheckedDeleteOperation) {
        	BulkCheckedDeleteOperation bulkCheckedDeleteOperation = (BulkCheckedDeleteOperation) delete;
        	if (VariableInstanceEntity.class.isAssignableFrom(bulkCheckedDeleteOperation.getPersistentObjectClass())) {
        		for (PersistentObject persistentObject : bulkCheckedDeleteOperation.getPersistentObjects()) {
        			 VariableInstanceEntity variableInstance = (VariableInstanceEntity) persistentObject;
               Context.getProcessEngineConfiguration().getEventDispatcher().dispatchEvent(
                 createVariableDeleteEvent(variableInstance)
               );
        		}
        	}
        }
      }
    }
  }

  @Override
  public void close() {
    sqlSession.close();
  }

  public void commit() {
    sqlSession.commit();
  }

  public void rollback() {
    sqlSession.rollback();
  }
  
  // schema operations ////////////////////////////////////////////////////////
  
  public void dbSchemaCheckVersion() {
    try {
      String dbVersion = getDbVersion();
      if (!ProcessEngine.VERSION.equals(dbVersion)) {
        throw new ActivitiWrongDbException(ProcessEngine.VERSION, dbVersion);
      }

      String errorMessage = null;
      if (!isEngineTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "engine");
      }
      if (dbSqlSessionFactory.isDbHistoryUsed() && !isHistoryTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "history");
      }
      if (dbSqlSessionFactory.isDbIdentityUsed() && !isIdentityTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "identity");
      }
      
      if (errorMessage!=null) {
        throw new ActivitiException("Activiti database problem: "+errorMessage);
      }
      
    } catch (Exception e) {
      if (isMissingTablesException(e)) {
        throw new ActivitiException("no activiti tables in db. set <property name=\"databaseSchemaUpdate\" to value=\"true\" or value=\"create-drop\" (use create-drop for testing only!) in bean processEngineConfiguration in activiti.cfg.xml for automatic schema creation", e);
      } else {
        if (e instanceof RuntimeException) {
          throw (RuntimeException) e;
        } else {
          throw new ActivitiException("couldn't get db schema version", e);
        }
      }
    }

    log.debug("activiti db schema check successful");
  }

  protected String addMissingComponent(String missingComponents, String component) {
    if (missingComponents==null) {
      return "Tables missing for component(s) "+component;
    }
    return missingComponents+", "+component;
  }

  protected String getDbVersion() {
    String selectSchemaVersionStatement = dbSqlSessionFactory.mapStatement("selectDbSchemaVersion");
    return (String) sqlSession.selectOne(selectSchemaVersionStatement);
  }

  public void dbSchemaCreate() {
    ProcessEngineConfigurationImpl processEngineConfiguration = Context.getProcessEngineConfiguration();
    
    if (isEngineTablePresent()) {
      String dbVersion = getDbVersion();
      if (!ProcessEngine.VERSION.equals(dbVersion)) {
        throw new ActivitiWrongDbException(ProcessEngine.VERSION, dbVersion);
      }
    } else {
      dbSchemaCreateEngine();
    }

    if (processEngineConfiguration.getHistoryLevel() != HistoryLevel.NONE) {
      dbSchemaCreateHistory();
    }

    if (processEngineConfiguration.isDbIdentityUsed()) {
      dbSchemaCreateIdentity();
    }
  }

  protected void dbSchemaCreateIdentity() {
    executeMandatorySchemaResource("create", "identity");
  }

  protected void dbSchemaCreateHistory() {
    executeMandatorySchemaResource("create", "history");
  }

  protected void dbSchemaCreateEngine() {
    executeMandatorySchemaResource("create", "engine");
  }

  public void dbSchemaDrop() {
    executeMandatorySchemaResource("drop", "engine");
    if (dbSqlSessionFactory.isDbHistoryUsed()) {
      executeMandatorySchemaResource("drop", "history");
    }
    if (dbSqlSessionFactory.isDbIdentityUsed()) {
      executeMandatorySchemaResource("drop", "identity");
    }
  }

  public void dbSchemaPrune() {
    if (isHistoryTablePresent() && !dbSqlSessionFactory.isDbHistoryUsed()) {
      executeMandatorySchemaResource("drop", "history");
    }
    if (isIdentityTablePresent() && dbSqlSessionFactory.isDbIdentityUsed()) {
      executeMandatorySchemaResource("drop", "identity");
    }
  }

  public void executeMandatorySchemaResource(String operation, String component) {
    executeSchemaResource(operation, component, getResourceForDbOperation(operation, operation, component), false);
  }

  public static String[] JDBC_METADATA_TABLE_TYPES = {"TABLE"};

	public String dbSchemaUpdate() {

		String feedback = null;
		boolean isUpgradeNeeded = false;
		int matchingVersionIndex = -1;

		if (isEngineTablePresent()) {

			PropertyEntity dbVersionProperty = selectById(PropertyEntity.class,"schema.version");
			String dbVersion = dbVersionProperty.getValue();

			// Determine index in the sequence of Activiti releases
			int index = 0;
			while (matchingVersionIndex < 0 && index < ACTIVITI_VERSIONS.size()) {
				if (ACTIVITI_VERSIONS.get(index).matches(dbVersion)) {
					matchingVersionIndex = index;
				} else {
					index++;
				}
			}

			// Exception when no match was found: unknown/unsupported version
			if (matchingVersionIndex < 0) {
				throw new ActivitiException(
				    "Could not update Activiti database schema: unknown version from database: '"
				        + dbVersion + "'");
			}

			isUpgradeNeeded = (matchingVersionIndex != (ACTIVITI_VERSIONS.size() - 1));

			if (isUpgradeNeeded) {
				dbVersionProperty.setValue(ProcessEngine.VERSION);

				PropertyEntity dbHistoryProperty;
				if ("5.0".equals(dbVersion)) {
					dbHistoryProperty = new PropertyEntity("schema.history", "create(5.0)");
					insert(dbHistoryProperty);
				} else {
					dbHistoryProperty = selectById(PropertyEntity.class, "schema.history");
				}

				// Set upgrade history
				String dbHistoryValue = dbHistoryProperty.getValue() + " upgrade(" + dbVersion + "->" + ProcessEngine.VERSION + ")";
				dbHistoryProperty.setValue(dbHistoryValue);

				// Engine upgrade
				dbSchemaUpgrade("engine", matchingVersionIndex);
				feedback = "upgraded Activiti from " + dbVersion + " to "+ ProcessEngine.VERSION;
			}

		} else {
			dbSchemaCreateEngine();
		}
		if (isHistoryTablePresent()) {
			if (isUpgradeNeeded) {
				dbSchemaUpgrade("history", matchingVersionIndex);
			}
		} else if (dbSqlSessionFactory.isDbHistoryUsed()) {
			dbSchemaCreateHistory();
		}
    
    if (isIdentityTablePresent()) {
      if (isUpgradeNeeded) {
        dbSchemaUpgrade("identity", matchingVersionIndex);
      }
    } else if (dbSqlSessionFactory.isDbIdentityUsed()) {
      dbSchemaCreateIdentity();
    }
    
    return feedback;
  }

  public boolean isEngineTablePresent(){
    return isTablePresent("ACT_RU_EXECUTION");
  }
  public boolean isHistoryTablePresent(){
    return isTablePresent("ACT_HI_PROCINST");
  }
  public boolean isIdentityTablePresent(){
    return isTablePresent("ACT_ID_USER");
  }

  public boolean isTablePresent(String tableName) {
  	// ACT-1610: in case the prefix IS the schema itself, we don't add the prefix, since the
  	// check is already aware of the schema
  	if (!dbSqlSessionFactory.isTablePrefixIsSchema()) {
  		tableName = prependDatabaseTablePrefix(tableName);
  	}
  	
    Connection connection = null;
    try {
      connection = sqlSession.getConnection();
      DatabaseMetaData databaseMetaData = connection.getMetaData();
      ResultSet tables = null;

      String catalog = this.connectionMetadataDefaultCatalog;
      if (dbSqlSessionFactory.getDatabaseCatalog() != null && dbSqlSessionFactory.getDatabaseCatalog().length() > 0) {
        catalog = dbSqlSessionFactory.getDatabaseCatalog();
      }

      String schema = this.connectionMetadataDefaultSchema;
      if (dbSqlSessionFactory.getDatabaseSchema() != null && dbSqlSessionFactory.getDatabaseSchema().length() > 0) {
        schema = dbSqlSessionFactory.getDatabaseSchema();
      }
      
      String databaseType = dbSqlSessionFactory.getDatabaseType();
      
      if ("postgres".equals(databaseType)) {
        tableName = tableName.toLowerCase();
      }
      
      try {
        tables = databaseMetaData.getTables(catalog, schema, tableName, JDBC_METADATA_TABLE_TYPES);
        return tables.next();
      } finally {
        try {
          tables.close();
        } catch (Exception e) {
          log.error("Error closing meta data tables", e);
        }
      }
      
    } catch (Exception e) {
      throw new ActivitiException("couldn't check if tables are already present using metadata: "+e.getMessage(), e);
    }
  }
  
  protected boolean isUpgradeNeeded(String versionInDatabase) {
    if(ProcessEngine.VERSION.equals(versionInDatabase)) {
      return false;
    }
    
    String cleanDbVersion = getCleanVersion(versionInDatabase);
    String[] cleanDbVersionSplitted = cleanDbVersion.split("\\.");
    int dbMajorVersion = Integer.valueOf(cleanDbVersionSplitted[0]);
    int dbMinorVersion = Integer.valueOf(cleanDbVersionSplitted[1]);
    
    String cleanEngineVersion = getCleanVersion(ProcessEngine.VERSION);
    String[] cleanEngineVersionSplitted = cleanEngineVersion.split("\\.");
    int engineMajorVersion = Integer.valueOf(cleanEngineVersionSplitted[0]);
    int engineMinorVersion = Integer.valueOf(cleanEngineVersionSplitted[1]);
      
    if((dbMajorVersion > engineMajorVersion)
            || ( (dbMajorVersion <= engineMajorVersion) && (dbMinorVersion > engineMinorVersion) )) {
      throw new ActivitiException("Version of activiti database (" + versionInDatabase + ") is more recent than the engine (" + ProcessEngine.VERSION +")");
    } else if(cleanDbVersion.compareTo(cleanEngineVersion) == 0) {
      // Versions don't match exactly, possibly snapshot is being used
      log.warn("Engine-version is the same, but not an exact match: {} vs. {}. Not performing database-upgrade.", versionInDatabase, ProcessEngine.VERSION);
      return false;
    }
    return true;
  }
  
  protected String getCleanVersion(String versionString) {
    Matcher matcher = CLEAN_VERSION_REGEX.matcher(versionString);
    if(!matcher.find()) {
      throw new ActivitiException("Illegal format for version: " + versionString);
    }
    
    String cleanString = matcher.group();
    try {
      Double.parseDouble(cleanString); // try to parse it, to see if it is really a number
      return cleanString;
    } catch(NumberFormatException nfe) {
      throw new ActivitiException("Illegal format for version: " + versionString);
    }
  }
  
  protected String prependDatabaseTablePrefix(String tableName) {
    return dbSqlSessionFactory.getDatabaseTablePrefix() + tableName;    
  }
  
  protected void dbSchemaUpgrade(final String component, final int currentDatabaseVersionsIndex) {
  	ActivitiVersion activitiVersion = ACTIVITI_VERSIONS.get(currentDatabaseVersionsIndex);
  	String dbVersion = activitiVersion.getMainVersion();
    log.info("upgrading activiti {} schema from {} to {}", component, dbVersion, ProcessEngine.VERSION);
    
    // Actual execution of schema DDL SQL
    for (int i=currentDatabaseVersionsIndex + 1; i<ACTIVITI_VERSIONS.size(); i++) {
    	String nextVersion = ACTIVITI_VERSIONS.get(i).getMainVersion();
    	
    	// Taking care of -SNAPSHOT version in development
      if (nextVersion.endsWith("-SNAPSHOT")) {
      	nextVersion = nextVersion.substring(0, nextVersion.length()-"-SNAPSHOT".length());
      }
      
      dbVersion = dbVersion.replace(".", "");
      nextVersion = nextVersion.replace(".", "");
      log.info("Upgrade needed: {} -> {}. Looking for schema update resource for component '{}'", dbVersion, nextVersion, component);
    	executeSchemaResource("upgrade", component, getResourceForDbOperation("upgrade", "upgradestep." + dbVersion + ".to." + nextVersion, component), true);
    	dbVersion = nextVersion;
    }
  }
  
  public String getResourceForDbOperation(String directory, String operation, String component) {
    String databaseType = dbSqlSessionFactory.getDatabaseType();
    return "org/activiti/db/" + directory + "/activiti." + databaseType + "." + operation + "."+component+".sql";
  }

  public void executeSchemaResource(String operation, String component, String resourceName, boolean isOptional) {
    InputStream inputStream = null;
    try {
      inputStream = ReflectUtil.getResourceAsStream(resourceName);
      if (inputStream == null) {
        if (isOptional) {
          log.info("no schema resource {} for {}", resourceName, operation);
        } else {
          throw new ActivitiException("resource '" + resourceName + "' is not available");
        }
      } else {
        executeSchemaResource(operation, component, resourceName, inputStream);
      }

    } finally {
      IoUtil.closeSilently(inputStream);
    }
  }

  private void executeSchemaResource(String operation, String component, String resourceName, InputStream inputStream) {
    log.info("performing {} on {} with resource {}", operation, component, resourceName);
    String sqlStatement = null;
    String exceptionSqlStatement = null;
    try {
      Connection connection = sqlSession.getConnection();
      Exception exception = null;
      byte[] bytes = IoUtil.readInputStream(inputStream, resourceName);
      String ddlStatements = new String(bytes);
      String databaseType = dbSqlSessionFactory.getDatabaseType();
      
      // Special DDL handling for certain databases
      try {
	    	if ("mysql".equals(databaseType)) {
	    	  DatabaseMetaData databaseMetaData = connection.getMetaData();
	    	  int majorVersion = databaseMetaData.getDatabaseMajorVersion();
	    	  int minorVersion = databaseMetaData.getDatabaseMinorVersion();
	    	  log.info("Found MySQL: majorVersion=" + majorVersion + " minorVersion=" + minorVersion);
		      
	    	  // Special care for MySQL < 5.6
	    	  if (majorVersion <= 5 && minorVersion < 6) {
	    	    ddlStatements = updateDdlForMySqlVersionLowerThan56(ddlStatements);
	    	  }
	    	}
      } catch (Exception e) {
        log.info("Could not get database metadata", e);
      }
      
      BufferedReader reader = new BufferedReader(new StringReader(ddlStatements));
      String line = readNextTrimmedLine(reader);
      boolean inOraclePlsqlBlock = false;
      while (line != null) {
        if (line.startsWith("# ")) {
          log.debug(line.substring(2));
          
        } else if (line.startsWith("-- ")) {
          log.debug(line.substring(3));
          
        } else if (line.startsWith("execute java ")) {
          String upgradestepClassName = line.substring(13).trim();
          DbUpgradeStep dbUpgradeStep = null;
          try {
            dbUpgradeStep = (DbUpgradeStep) ReflectUtil.instantiate(upgradestepClassName);
          } catch (ActivitiException e) {
            throw new ActivitiException("database update java class '"+upgradestepClassName+"' can't be instantiated: "+e.getMessage(), e);
          }
          try {
            log.debug("executing upgrade step java class {}", upgradestepClassName);
            dbUpgradeStep.execute(this);
          } catch (Exception e) {
            throw new ActivitiException("error while executing database update java class '"+upgradestepClassName+"': "+e.getMessage(), e);
          }
          
        } else if (line.length()>0) {
          
          if ("oracle".equals(databaseType) && line.startsWith("begin")) {
            inOraclePlsqlBlock = true;
            sqlStatement = addSqlStatementPiece(sqlStatement, line);
            
          } else if ((line.endsWith(";") && inOraclePlsqlBlock == false) ||
              (line.startsWith("/") && inOraclePlsqlBlock == true)) {
            
            if (inOraclePlsqlBlock) {
              inOraclePlsqlBlock = false;
            } else {
              sqlStatement = addSqlStatementPiece(sqlStatement, line.substring(0, line.length()-1));
            }
            
            Statement jdbcStatement = connection.createStatement();
            try {
              // no logging needed as the connection will log it
              log.debug("SQL: {}", sqlStatement);
              jdbcStatement.execute(sqlStatement);
              jdbcStatement.close();
            } catch (Exception e) {
              if (exception == null) {
                exception = e;
                exceptionSqlStatement = sqlStatement;
              }
              log.error("problem during schema {}, statement {}", operation, sqlStatement, e);
            } finally {
              sqlStatement = null; 
            }
          } else {
            sqlStatement = addSqlStatementPiece(sqlStatement, line);
          }
        }
        
        line = readNextTrimmedLine(reader);
      }

      if (exception != null) {
        throw exception;
      }
      
      log.debug("activiti db schema {} for component {} successful", operation, component);
      
    } catch (Exception e) {
      throw new ActivitiException("couldn't "+operation+" db schema: "+exceptionSqlStatement, e);
    }
  }
  
  /**
   * MySQL is funny when it comes to timestamps and dates.
   *  
   * More specifically, for a DDL statement like 'MYCOLUMN timestamp(3)':
   *   - MySQL 5.6.4+ has support for timestamps/dates with millisecond (or smaller) precision. 
   *     The DDL above works and the data in the table will have millisecond precision
   *   - MySQL < 5.5.3 allows the DDL statement, but ignores it.
   *     The DDL above works but the data won't have millisecond precision
   *   - MySQL 5.5.3 < [version] < 5.6.4 gives and exception when using the DDL above.
   *   
   * Also, the 5.5 and 5.6 branches of MySQL are both actively developed and patched.
   * 
   * Hence, when doing auto-upgrade/creation of the Activiti tables, the default 
   * MySQL DDL file is used and all timestamps/datetimes are converted to not use the 
   * millisecond precision by string replacement done in the method below.
   * 
   * If using the DDL files directly (which is a sane choice in production env.),
   * there is a distinction between MySQL version < 5.6.
   */
  protected String updateDdlForMySqlVersionLowerThan56(String ddlStatements) {
	  return ddlStatements.replace("timestamp(3)", "timestamp")
			  			  .replace("datetime(3)", "datetime")
			  			  .replace("TIMESTAMP(3)", "TIMESTAMP")
			  			  .replace("DATETIME(3)", "DATETIME");
  }

  protected String addSqlStatementPiece(String sqlStatement, String line) {
    if (sqlStatement==null) {
      return line;
    }
    return sqlStatement + " \n" + line;
  }
  
  protected String readNextTrimmedLine(BufferedReader reader) throws IOException {
    String line = reader.readLine();
    if (line!=null) {
      line = line.trim();
    }
    return line;
  }
  
  protected boolean isMissingTablesException(Exception e) {
    String exceptionMessage = e.getMessage();
    if(e.getMessage() != null) {      
      // Matches message returned from H2
      if ((exceptionMessage.indexOf("Table") != -1) && (exceptionMessage.indexOf("not found") != -1)) {
        return true;
      }
      
      // Message returned from MySQL and Oracle
      if (((exceptionMessage.indexOf("Table") != -1 || exceptionMessage.indexOf("table") != -1)) && (exceptionMessage.indexOf("doesn't exist") != -1)) {
        return true;
      }
      
      // Message returned from Postgres
      if (((exceptionMessage.indexOf("relation") != -1 || exceptionMessage.indexOf("table") != -1)) && (exceptionMessage.indexOf("does not exist") != -1)) {
        return true;
      }
    }
    return false;
  }
  
  public void performSchemaOperationsProcessEngineBuild() {
    String databaseSchemaUpdate = Context.getProcessEngineConfiguration().getDatabaseSchemaUpdate();
    if (ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_DROP_CREATE.equals(databaseSchemaUpdate)) {
      try {
        dbSchemaDrop();
      } catch (RuntimeException e) {
        // ignore
      }
    }
    if ( org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_CREATE_DROP.equals(databaseSchemaUpdate) 
         || ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_DROP_CREATE.equals(databaseSchemaUpdate)
         || ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_CREATE.equals(databaseSchemaUpdate)
       ) {
      dbSchemaCreate();
      
    } else if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE.equals(databaseSchemaUpdate)) {
      dbSchemaCheckVersion();
      
    } else if (ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE.equals(databaseSchemaUpdate)) {
      dbSchemaUpdate();
    }
  }

  public void performSchemaOperationsProcessEngineClose() {
    String databaseSchemaUpdate = Context.getProcessEngineConfiguration().getDatabaseSchemaUpdate();
    if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_CREATE_DROP.equals(databaseSchemaUpdate)) {
      dbSchemaDrop();
    }
  }
  
  public <T> T getCustomMapper(Class<T> type) {
	  return sqlSession.getMapper(type);
  }

  // query factory methods ////////////////////////////////////////////////////  

  public DeploymentQueryImpl createDeploymentQuery() {
    return new DeploymentQueryImpl();
  }
  public ModelQueryImpl createModelQueryImpl() {
    return new ModelQueryImpl();
  }
  public ProcessDefinitionQueryImpl createProcessDefinitionQuery() {
    return new ProcessDefinitionQueryImpl();
  }
  public ProcessInstanceQueryImpl createProcessInstanceQuery() {
    return new ProcessInstanceQueryImpl();
  }
  public ExecutionQueryImpl createExecutionQuery() {
    return new ExecutionQueryImpl();
  }
  public TaskQueryImpl createTaskQuery() {
    return new TaskQueryImpl();
  }
  public JobQueryImpl createJobQuery() {
    return new JobQueryImpl();
  }
  public HistoricProcessInstanceQueryImpl createHistoricProcessInstanceQuery() {
    return new HistoricProcessInstanceQueryImpl();
  }
  public HistoricActivityInstanceQueryImpl createHistoricActivityInstanceQuery() {
    return new HistoricActivityInstanceQueryImpl();
  }
  public HistoricTaskInstanceQueryImpl createHistoricTaskInstanceQuery() {
    return new HistoricTaskInstanceQueryImpl();
  }
  public HistoricDetailQueryImpl createHistoricDetailQuery() {
    return new HistoricDetailQueryImpl();
  }
  public HistoricVariableInstanceQueryImpl createHistoricVariableInstanceQuery() {
    return new HistoricVariableInstanceQueryImpl();
  }
  public UserQueryImpl createUserQuery() {
    return new UserQueryImpl();
  }
  public GroupQueryImpl createGroupQuery() {
    return new GroupQueryImpl();
  }

  // getters and setters //////////////////////////////////////////////////////
  
  public SqlSession getSqlSession() {
    return sqlSession;
  }
  public DbSqlSessionFactory getDbSqlSessionFactory() {
    return dbSqlSessionFactory;
  }

	public boolean isOptimizeDeleteOperationsEnabled() {
		return isOptimizeDeleteOperationsEnabled;
	}

	public void setOptimizeDeleteOperationsEnabled(boolean isOptimizeDeleteOperationsEnabled) {
		this.isOptimizeDeleteOperationsEnabled = isOptimizeDeleteOperationsEnabled;
	}
  
}
!@#$%
20190526_171716,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.db;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.ActivitiOptimisticLockingException;
import org.activiti.engine.ActivitiWrongDbException;
import org.activiti.engine.ProcessEngine;
import org.activiti.engine.ProcessEngineConfiguration;
import org.activiti.engine.impl.DeploymentQueryImpl;
import org.activiti.engine.impl.ExecutionQueryImpl;
import org.activiti.engine.impl.GroupQueryImpl;
import org.activiti.engine.impl.HistoricActivityInstanceQueryImpl;
import org.activiti.engine.impl.HistoricDetailQueryImpl;
import org.activiti.engine.impl.HistoricProcessInstanceQueryImpl;
import org.activiti.engine.impl.HistoricTaskInstanceQueryImpl;
import org.activiti.engine.impl.HistoricVariableInstanceQueryImpl;
import org.activiti.engine.impl.JobQueryImpl;
import org.activiti.engine.impl.ModelQueryImpl;
import org.activiti.engine.impl.Page;
import org.activiti.engine.impl.ProcessDefinitionQueryImpl;
import org.activiti.engine.impl.ProcessInstanceQueryImpl;
import org.activiti.engine.impl.TaskQueryImpl;
import org.activiti.engine.impl.UserQueryImpl;
import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.db.upgrade.DbUpgradeStep;
import org.activiti.engine.impl.interceptor.Session;
import org.activiti.engine.impl.persistence.entity.PropertyEntity;
import org.activiti.engine.impl.util.IoUtil;
import org.activiti.engine.impl.util.ReflectUtil;
import org.activiti.engine.impl.variable.DeserializedObject;
import org.apache.ibatis.session.SqlSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** responsibilities:
 *   - delayed flushing of inserts updates and deletes
 *   - optional dirty checking
 *   - db specific statement name mapping
 *   
 * @author Tom Baeyens
 * @author Joram Barrez
 */
public class DbSqlSession implements Session {
  
  private static final Logger log = LoggerFactory.getLogger(DbSqlSession.class);
  
  protected static final Pattern CLEAN_VERSION_REGEX = Pattern.compile("\\d\\.\\d*");
  
  protected static final List<ActivitiVersion> ACTIVITI_VERSIONS = new ArrayList<ActivitiVersion>();
  static {
	  
	  /* Previous */
	  
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.7"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.8"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.9"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.10"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.11"));
	  
	  // 5.12.1 was a bugfix release on 5.12 and did NOT change the version in ACT_GE_PROPERTY
	  // On top of that, DB2 create script for 5.12.1 was shipped with a 'T' suffix ...
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.12", Arrays.asList("5.12.1", "5.12T")));
	  
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.13"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.14"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.15"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.15.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.2-SNAPSHOT"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.2"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.3.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.16.4.0"));

	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.17.0.2"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.18.0.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.18.0.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.20.0.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.20.0.1"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.20.0.2"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.21.0.0"));
	  ACTIVITI_VERSIONS.add(new ActivitiVersion("5.22.0.0"));
	  
	  /* Current */
	  ACTIVITI_VERSIONS.add(new ActivitiVersion(ProcessEngine.VERSION));
  }

  protected SqlSession sqlSession;
  protected DbSqlSessionFactory dbSqlSessionFactory;
  protected Map<Class<? extends PersistentObject>, List<PersistentObject>> insertedObjects = new HashMap<Class<? extends PersistentObject>, List<PersistentObject>>();
  protected Map<Class<?>, Map<String, CachedObject>> cachedObjects = new HashMap<Class<?>, Map<String,CachedObject>>();
  protected List<DeleteOperation> deleteOperations = new ArrayList<DeleteOperation>();
  protected List<DeserializedObject> deserializedObjects = new ArrayList<DeserializedObject>();
  protected String connectionMetadataDefaultCatalog;
  protected String connectionMetadataDefaultSchema;
  
  public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.sqlSession = dbSqlSessionFactory
      .getSqlSessionFactory()
      .openSession();
  }

  public DbSqlSession(DbSqlSessionFactory dbSqlSessionFactory, Connection connection, String catalog, String schema) {
    this.dbSqlSessionFactory = dbSqlSessionFactory;
    this.sqlSession = dbSqlSessionFactory
      .getSqlSessionFactory()
      .openSession(connection);
    this.connectionMetadataDefaultCatalog = catalog;
    this.connectionMetadataDefaultSchema = schema;
  }
  
  // insert ///////////////////////////////////////////////////////////////////
  
  
  public void insert(PersistentObject persistentObject) {
    if (persistentObject.getId()==null) {
      String id = dbSqlSessionFactory.getIdGenerator().getNextId();  
      persistentObject.setId(id);
    }
    
    Class<? extends PersistentObject> clazz = persistentObject.getClass();
    if (!insertedObjects.containsKey(clazz)) {
    	insertedObjects.put(clazz, new ArrayList<PersistentObject>());
    }
    
    insertedObjects.get(clazz).add(persistentObject);
    cachePut(persistentObject, false);
  }
  
  // update ///////////////////////////////////////////////////////////////////
  
  public void update(PersistentObject persistentObject) {
    cachePut(persistentObject, false);
  }
  
  public int update(String statement, Object parameters) {
     String updateStatement = dbSqlSessionFactory.mapStatement(statement);
     return getSqlSession().update(updateStatement, parameters);
  }
  
  // delete ///////////////////////////////////////////////////////////////////

  public void delete(String statement, Object parameter) {
    deleteOperations.add(new BulkDeleteOperation(statement, parameter));
  }
  
  public void delete(PersistentObject persistentObject) {
    for (DeleteOperation deleteOperation: deleteOperations) {
        if (deleteOperation.sameIdentity(persistentObject)) {
          log.debug("skipping redundant delete: {}", persistentObject);
          return; // Skip this delete. It was already added.
        }
    }
    
    deleteOperations.add(new CheckedDeleteOperation(persistentObject));
  }

  public interface DeleteOperation {
  	
  	/**
  	 * @return The persistent object class that is being deleted.
  	 *         Null in case there are multiple objects of different types!
  	 */
  	Class<? extends PersistentObject> getPersistentObjectClass();
    
    boolean sameIdentity(PersistentObject other);

    void clearCache();
    
    void execute();
    
  }

  /**
   * Use this {@link DeleteOperation} to execute a dedicated delete statement.
   * It is important to note there won't be any optimistic locking checks done 
   * for these kind of delete operations!
   * 
   * For example, a usage of this operation would be to delete all variables for
   * a certain execution, when that certain execution is removed. The optimistic locking
   * happens on the execution, but the variables can be removed by a simple
   * 'delete from var_table where execution_id is xxx'. It could very well be there
   * are no variables, which would also work with this query, but not with the 
   * regular {@link CheckedDeleteOperation}. 
   */
  public class BulkDeleteOperation implements DeleteOperation {
    private String statement;
    private Object parameter;
    
    public BulkDeleteOperation(String statement, Object parameter) {
      this.statement = dbSqlSessionFactory.mapStatement(statement);
      this.parameter = parameter;
    }
    
    @Override
    public Class<? extends PersistentObject> getPersistentObjectClass() {
    	return null;
    }
    
    @Override
    public boolean sameIdentity(PersistentObject other) {
      // this implementation is unable to determine what the identity of the removed object(s) will be.
      return false;
    }

    @Override
    public void clearCache() {
      // this implementation cannot clear the object(s) to be removed from the cache.
    }
    
    @Override
    public void execute() {
      sqlSession.delete(statement, parameter);
    }
    
    @Override
    public String toString() {
      return "bulk delete: " + statement + "(" + parameter + ")";
    }
  }
  
  /**
   * A {@link DeleteOperation} that checks for concurrent modifications if the persistent object implements {@link HasRevision}.
   * That is, it employs optimisting concurrency control. Used when the persistent object has been fetched already.
   */
  public class CheckedDeleteOperation implements DeleteOperation {
    protected final PersistentObject persistentObject;
    
    public CheckedDeleteOperation(PersistentObject persistentObject) {
      this.persistentObject = persistentObject;
    }
    
    @Override
    public Class<? extends PersistentObject> getPersistentObjectClass() {
    	return persistentObject.getClass();
    }
    
    @Override
    public boolean sameIdentity(PersistentObject other) {
      return persistentObject.getClass().equals(other.getClass())
          && persistentObject.getId().equals(other.getId());
    }

    @Override
    public void clearCache() {
      cacheRemove(persistentObject.getClass(), persistentObject.getId());
    }
    
    @Override
    public void execute() {
      String deleteStatement = dbSqlSessionFactory.getDeleteStatement(persistentObject.getClass());
      deleteStatement = dbSqlSessionFactory.mapStatement(deleteStatement);
      if (deleteStatement == null) {
        throw new ActivitiException("no delete statement for " + persistentObject.getClass() + " in the ibatis mapping files");
      }
      
      // It only makes sense to check for optimistic locking exceptions for objects that actually have a revision
      if (persistentObject instanceof HasRevision) {
        int nrOfRowsDeleted = sqlSession.delete(deleteStatement, persistentObject);
        if (nrOfRowsDeleted == 0) {
          throw new ActivitiOptimisticLockingException(persistentObject + " was updated by another transaction concurrently");
        }
      } else {
        sqlSession.delete(deleteStatement, persistentObject);
      }
    }

    public PersistentObject getPersistentObject() {
      return persistentObject;
    }

    @Override
    public String toString() {
      return "delete " + persistentObject;
    }
  }
  
  
  /**
   * A bulk version of the {@link CheckedDeleteOperation}.
   */
  public class BulkCheckedDeleteOperation implements DeleteOperation {
  	
  	protected Class<? extends PersistentObject> persistentObjectClass;
    protected List<PersistentObject> persistentObjects = new ArrayList<PersistentObject>();
    
    public BulkCheckedDeleteOperation(Class<? extends PersistentObject> persistentObjectClass) {
    	this.persistentObjectClass = persistentObjectClass;
    }
    
    public void addPersistentObject(PersistentObject persistentObject) {
    	persistentObjects.add(persistentObject);
    }
    
    @Override
    public boolean sameIdentity(PersistentObject other) {
    	for (PersistentObject persistentObject : persistentObjects) {
    		if (persistentObject.getClass().equals(other.getClass()) && persistentObject.getId().equals(other.getId())) {
    			return true;
    		}
    	}
    	return false;
    }

    @Override
    public void clearCache() {
    	for (PersistentObject persistentObject : persistentObjects) {
    		cacheRemove(persistentObject.getClass(), persistentObject.getId());
    	}
    }
    
    @Override
    public void execute() {
    	
    	if (persistentObjects.isEmpty()) {
    		return;
    	}
    	
      String bulkDeleteStatement = dbSqlSessionFactory.getBulkDeleteStatement(persistentObjectClass);
      bulkDeleteStatement = dbSqlSessionFactory.mapStatement(bulkDeleteStatement);
      if (bulkDeleteStatement == null) {
        throw new ActivitiException("no bulk delete statement for " + persistentObjectClass + " in the mapping files");
      }
      
      // It only makes sense to check for optimistic locking exceptions for objects that actually have a revision
      if (persistentObjects.get(0) instanceof HasRevision) {
        int nrOfRowsDeleted = sqlSession.delete(bulkDeleteStatement, persistentObjects);
        if (nrOfRowsDeleted < persistentObjects.size()) {
          throw new ActivitiOptimisticLockingException("One of the entities " + persistentObjectClass 
          		+ " was updated by another transaction concurrently while trying to do a bulk delete");
        }
      } else {
        sqlSession.delete(bulkDeleteStatement, persistentObjects);
      }
    }
    
    public Class<? extends PersistentObject> getPersistentObjectClass() {
			return persistentObjectClass;
		}

		public void setPersistentObjectClass(
		    Class<? extends PersistentObject> persistentObjectClass) {
			this.persistentObjectClass = persistentObjectClass;
		}

		public List<PersistentObject> getPersistentObjects() {
			return persistentObjects;
		}

		public void setPersistentObjects(List<PersistentObject> persistentObjects) {
			this.persistentObjects = persistentObjects;
		}

		@Override
    public String toString() {
      return "bulk delete of " + persistentObjects.size() + (!persistentObjects.isEmpty() ? " entities of " + persistentObjects.get(0).getClass() : 0 );
    }
  }
  
  // select ///////////////////////////////////////////////////////////////////

  @SuppressWarnings({ "rawtypes" })
  public List selectList(String statement) {
    return selectList(statement, null, 0, Integer.MAX_VALUE);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter) {  
    return selectList(statement, parameter, 0, Integer.MAX_VALUE);
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, Page page) {   
    if (page!=null) {
      return selectList(statement, parameter, page.getFirstResult(), page.getMaxResults());
    } else {
      return selectList(statement, parameter, 0, Integer.MAX_VALUE);
    }
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter, Page page) {
    if (page != null) {
      parameter.setFirstResult(page.getFirstResult());
      parameter.setMaxResults(page.getMaxResults());
    }
    return selectList(statement, parameter);
  }

  @SuppressWarnings("rawtypes")
  public List selectList(String statement, Object parameter, int firstResult, int maxResults) {   
    return selectList(statement, new ListQueryParameterObject(parameter, firstResult, maxResults));
  }
  
  @SuppressWarnings("rawtypes")
  public List selectList(String statement, ListQueryParameterObject parameter) {
    return selectListWithRawParameter(statement, parameter, parameter.getFirstResult(), parameter.getMaxResults());
  }
  
  @SuppressWarnings({ "rawtypes", "unchecked" })
  public List selectListWithRawParameter(String statement, Object parameter, int firstResult, int maxResults) {
    statement = dbSqlSessionFactory.mapStatement(statement);    
    if (firstResult == -1 ||  maxResults == -1) {
      return Collections.EMPTY_LIST;
    }    
    List loadedObjects = sqlSession.selectList(statement, parameter);
    return filterLoadedObjects(loadedObjects);
  }
  
  @SuppressWarnings({ "rawtypes" })
  public List selectListWithRawParameterWithoutFilter(String statement, Object parameter, int firstResult, int maxResults) {
    statement = dbSqlSessionFactory.mapStatement(statement);    
    if (firstResult == -1 ||  maxResults == -1) {
      return Collections.EMPTY_LIST;
    }    
    return sqlSession.selectList(statement, parameter);
  }

  public Object selectOne(String statement, Object parameter) {
    statement = dbSqlSessionFactory.mapStatement(statement);
    Object result = sqlSession.selectOne(statement, parameter);
    if (result instanceof PersistentObject) {
      PersistentObject loadedObject = (PersistentObject) result;
      result = cacheFilter(loadedObject);
    }
    return result;
  }
  
  @SuppressWarnings("unchecked")
  public <T extends PersistentObject> T selectById(Class<T> entityClass, String id) {
    T persistentObject = cacheGet(entityClass, id);
    if (persistentObject!=null) {
      return persistentObject;
    }
    String selectStatement = dbSqlSessionFactory.getSelectStatement(entityClass);
    selectStatement = dbSqlSessionFactory.mapStatement(selectStatement);
    persistentObject = (T) sqlSession.selectOne(selectStatement, id);
    if (persistentObject==null) {
      return null;
    }
    cachePut(persistentObject, true);
    return persistentObject;
  }

  // internal session cache ///////////////////////////////////////////////////
  
  @SuppressWarnings("rawtypes")
  protected List filterLoadedObjects(List<Object> loadedObjects) {
    if (loadedObjects.isEmpty()) {
      return loadedObjects;
    }
    if (!(loadedObjects.get(0) instanceof PersistentObject)) {
      return loadedObjects;
    }
    
    List<PersistentObject> filteredObjects = new ArrayList<PersistentObject>(loadedObjects.size());
    for (Object loadedObject: loadedObjects) {
      PersistentObject cachedPersistentObject = cacheFilter((PersistentObject) loadedObject);
      filteredObjects.add(cachedPersistentObject);
    }
    return filteredObjects;
  }

  protected CachedObject cachePut(PersistentObject persistentObject, boolean storeState) {
    Map<String, CachedObject> classCache = cachedObjects.get(persistentObject.getClass());
    if (classCache==null) {
      classCache = new HashMap<String, CachedObject>();
      cachedObjects.put(persistentObject.getClass(), classCache);
    }
    CachedObject cachedObject = new CachedObject(persistentObject, storeState);
    classCache.put(persistentObject.getId(), cachedObject);
    return cachedObject;
  }
  
  /** returns the object in the cache.  if this object was loaded before, 
   * then the original object is returned.  if this is the first time 
   * this object is loaded, then the loadedObject is added to the cache. */
  protected PersistentObject cacheFilter(PersistentObject persistentObject) {
    PersistentObject cachedPersistentObject = cacheGet(persistentObject.getClass(), persistentObject.getId());
    if (cachedPersistentObject!=null) {
      return cachedPersistentObject;
    }
    cachePut(persistentObject, true);
    return persistentObject;
  }

  @SuppressWarnings("unchecked")
  protected <T> T cacheGet(Class<T> entityClass, String id) {
    CachedObject cachedObject = null;
    Map<String, CachedObject> classCache = cachedObjects.get(entityClass);
    if (classCache!=null) {
      cachedObject = classCache.get(id);
    }
    if (cachedObject!=null) {
      return (T) cachedObject.getPersistentObject();
    }
    return null;
  }
  
  protected void cacheRemove(Class<?> persistentObjectClass, String persistentObjectId) {
    Map<String, CachedObject> classCache = cachedObjects.get(persistentObjectClass);
    if (classCache==null) {
      return;
    }
    classCache.remove(persistentObjectId);
  }
  
  @SuppressWarnings("unchecked")
  public <T> List<T> findInCache(Class<T> entityClass) {
    Map<String, CachedObject> classCache = cachedObjects.get(entityClass);
    if (classCache!=null) {
      List<T> entities = new ArrayList<T>(classCache.size());
      for (CachedObject cachedObject: classCache.values()) {
        entities.add((T) cachedObject.getPersistentObject());
      }
      return entities;
    }
    return Collections.emptyList();
  }
  
  public <T> T findInCache(Class<T> entityClass, String id) {
    return cacheGet(entityClass, id);
  }
  
  public static class CachedObject {
    protected PersistentObject persistentObject;
    protected Object persistentObjectState;
    
    public CachedObject(PersistentObject persistentObject, boolean storeState) {
      this.persistentObject = persistentObject;
      if (storeState) {
        this.persistentObjectState = persistentObject.getPersistentState();
      }
    }

    public PersistentObject getPersistentObject() {
      return persistentObject;
    }

    public Object getPersistentObjectState() {
      return persistentObjectState;
    }
  }

  // deserialized objects /////////////////////////////////////////////////////
  
  public void addDeserializedObject(DeserializedObject deserializedObject) {
  	deserializedObjects.add(deserializedObject);
  }

  // flush ////////////////////////////////////////////////////////////////////

  @Override
  public void flush() {
    List<DeleteOperation> removedOperations = removeUnnecessaryOperations();
    
    flushDeserializedObjects();
    List<PersistentObject> updatedObjects = getUpdatedObjects();
    
    if (log.isDebugEnabled()) {
      Collection<List<PersistentObject>> insertedObjectLists = insertedObjects.values();
      int nrOfInserts = 0, nrOfUpdates = 0, nrOfDeletes = 0;
      for (List<PersistentObject> insertedObjectList: insertedObjectLists) {
      	for (PersistentObject insertedObject : insertedObjectList) {
      		log.debug("  insert {}", insertedObject);
      		nrOfInserts++;
      	}
      }
      for (PersistentObject updatedObject: updatedObjects) {
        log.debug("  update {}", updatedObject);
        nrOfUpdates++;
      }
      for (DeleteOperation deleteOperation: deleteOperations) {
        log.debug("  {}", deleteOperation);
        nrOfDeletes++;
      }
      log.debug("flush summary: {} insert, {} update, {} delete.", nrOfInserts, nrOfUpdates, nrOfDeletes);
      log.debug("now executing flush...");
    }

    flushInserts();
    flushUpdates(updatedObjects);
    flushDeletes(removedOperations);
  }

  /**
   * Clears all deleted and inserted objects from the cache, 
   * and removes inserts and deletes that cancel each other.
   */
  protected List<DeleteOperation> removeUnnecessaryOperations() {
    List<DeleteOperation> removedDeleteOperations = new ArrayList<DeleteOperation>();

    for (Iterator<DeleteOperation> deleteIterator = deleteOperations.iterator(); deleteIterator.hasNext();) {
    	
      DeleteOperation deleteOperation = deleteIterator.next();
      Class<? extends PersistentObject> deletedPersistentObjectClass = deleteOperation.getPersistentObjectClass();
      
      List<PersistentObject> insertedObjectsOfSameClass = insertedObjects.get(deletedPersistentObjectClass);
      if (insertedObjectsOfSameClass != null && insertedObjectsOfSameClass.size() > 0) {
      	
	      for (Iterator<PersistentObject> insertIterator = insertedObjectsOfSameClass.iterator(); insertIterator.hasNext();) {
	        PersistentObject insertedObject = insertIterator.next();
	        
	        // if the deleted object is inserted,
	        if (deleteOperation.sameIdentity(insertedObject)) {
	          // remove the insert and the delete, they cancel each other
	          insertIterator.remove();
	          deleteIterator.remove();
	          // add removed operations to be able to fire events
	          removedDeleteOperations.add( deleteOperation);
	        }
	      }
	      
	      if (insertedObjects.get(deletedPersistentObjectClass).size() == 0) {
	      	insertedObjects.remove(deletedPersistentObjectClass);
	      }
	      
      }
      
      // in any case, remove the deleted object from the cache
      deleteOperation.clearCache();
    }
    
    for (Class<? extends PersistentObject> persistentObjectClass : insertedObjects.keySet()) {
    	for (PersistentObject insertedObject : insertedObjects.get(persistentObjectClass)) {
    		cacheRemove(insertedObject.getClass(), insertedObject.getId());
    	}
    }

    return removedDeleteOperations;
  }
  
//  
//  [Joram] Put this in comments. Had all kinds of errors.
//  
//  /**
//   * Optimizes the given delete operations:
//   * for example, if there are two deletes for two different variables, merges this into
//   * one bulk delete which improves performance
//   */
//  protected List<DeleteOperation> optimizeDeleteOperations(List<DeleteOperation> deleteOperations) {
//  	
//  	// No optimization possible for 0 or 1 operations
//  	if (!isOptimizeDeleteOperationsEnabled || deleteOperations.size() <= 1) {
//  		return deleteOperations;
//  	}
//  	
//  	List<DeleteOperation> optimizedDeleteOperations = new ArrayList<DbSqlSession.DeleteOperation>();
//  	boolean[] checkedIndices = new boolean[deleteOperations.size()];
//  	for (int i=0; i<deleteOperations.size(); i++) {
//  		
//  		if (checkedIndices[i] == true) {
//  			continue;
//  		}
//  		
//  		DeleteOperation deleteOperation = deleteOperations.get(i);
//  		boolean couldOptimize = false;
//  		if (deleteOperation instanceof CheckedDeleteOperation) {
//  			
//  			PersistentObject persistentObject = ((CheckedDeleteOperation) deleteOperation).getPersistentObject();
//  			if (persistentObject instanceof BulkDeleteable) {
//				String bulkDeleteStatement = dbSqlSessionFactory.getBulkDeleteStatement(persistentObject.getClass());
//				bulkDeleteStatement = dbSqlSessionFactory.mapStatement(bulkDeleteStatement);
//				if (bulkDeleteStatement != null) {
//					BulkCheckedDeleteOperation bulkCheckedDeleteOperation = null;
//					
//					// Find all objects of the same type
//					for (int j=0; j<deleteOperations.size(); j++) {
//						DeleteOperation otherDeleteOperation = deleteOperations.get(j);
//						if (j != i && checkedIndices[j] == false && otherDeleteOperation instanceof CheckedDeleteOperation) {
//							PersistentObject otherPersistentObject = ((CheckedDeleteOperation) otherDeleteOperation).getPersistentObject();
//							if (otherPersistentObject.getClass().equals(persistentObject.getClass())) {
//	  							if (bulkCheckedDeleteOperation == null) {
//	  								bulkCheckedDeleteOperation = new BulkCheckedDeleteOperation(persistentObject.getClass());
//	  								bulkCheckedDeleteOperation.addPersistentObject(persistentObject);
//	  								optimizedDeleteOperations.add(bulkCheckedDeleteOperation);
//	  							}
//	  							couldOptimize = true;
//	  							bulkCheckedDeleteOperation.addPersistentObject(otherPersistentObject);
//	  							checkedIndices[j] = true;
//							} else {
//							    // We may only optimize subsequent delete operations of the same type, to prevent messing up 
//							    // the order of deletes of related entities which may depend on the referenced entity being deleted before
//							    break;
//							}
//						}
//						
//					}
//				}
//  			}
//  		}
//  		
//   		if (!couldOptimize) {
//  			optimizedDeleteOperations.add(deleteOperation);
//  		}
//  		checkedIndices[i]=true;
//  		
//  	}
//  	return optimizedDeleteOperations;
//  }

  protected void flushDeserializedObjects() {
    for (DeserializedObject deserializedObject: deserializedObjects) {
      deserializedObject.flush();
    }
  }

  public List<PersistentObject> getUpdatedObjects() {
    List<PersistentObject> updatedObjects = new ArrayList<PersistentObject>();
    for (Class<?> clazz: cachedObjects.keySet()) {
      
      Map<String, CachedObject> classCache = cachedObjects.get(clazz);
      for (CachedObject cachedObject: classCache.values()) {
        
        PersistentObject persistentObject = cachedObject.getPersistentObject();
        if (!isPersistentObjectDeleted(persistentObject)) {
          Object originalState = cachedObject.getPersistentObjectState();
          if (persistentObject.getPersistentState() != null && 
          		!persistentObject.getPersistentState().equals(originalState)) {
            updatedObjects.add(persistentObject);
          } else {
            log.trace("loaded object '{}' was not updated", persistentObject);
          }
        }
        
      }
      
    }
    return updatedObjects;
  }
  
  protected boolean isPersistentObjectDeleted(PersistentObject persistentObject) {
    for (DeleteOperation deleteOperation : deleteOperations) {
      if (deleteOperation.sameIdentity(persistentObject)) {
        return true;
      }
    }
    return false;
  }
  
  public <T extends PersistentObject> List<T> pruneDeletedEntities(List<T> listToPrune) {
    List<T> prunedList = new ArrayList<T>(listToPrune);
    for (T potentiallyDeleted : listToPrune) {
      for (DeleteOperation deleteOperation: deleteOperations) {
          
        if (deleteOperation.sameIdentity(potentiallyDeleted)) {
          prunedList.remove(potentiallyDeleted);
        }
          
      }
    }
    return prunedList;
  }

  protected void flushInserts() {
  	
  	// Handle in entity dependency order
    for (Class<? extends PersistentObject> persistentObjectClass : EntityDependencyOrder.INSERT_ORDER) {
      if (insertedObjects.containsKey(persistentObjectClass)) {
      	flushPersistentObjects(persistentObjectClass, insertedObjects.get(persistentObjectClass));
      	insertedObjects.remove(persistentObjectClass);
      }
    }
    
    // Next, in case of custom entities or we've screwed up and forgotten some entity
    if (insertedObjects.size() > 0) {
	    for (Class<? extends PersistentObject> persistentObjectClass : insertedObjects.keySet()) {
      	flushPersistentObjects(persistentObjectClass, insertedObjects.get(persistentObjectClass));
	    }
    }
    
    insertedObjects.clear();
  }

	protected void flushPersistentObjects(Class<? extends PersistentObject> persistentObjectClass, List<PersistentObject> persistentObjectsToInsert) {
	  if (persistentObjectsToInsert.size() == 1) {
	  	flushRegularInsert(persistentObjectsToInsert.get(0), persistentObjectClass);
	  } else if (Boolean.FALSE.equals(dbSqlSessionFactory.isBulkInsertable(persistentObjectClass))) {
	  	for (PersistentObject persistentObject : persistentObjectsToInsert) {
	  		flushRegularInsert(persistentObject, persistentObjectClass);
	  	}
	  }	else {
	  	flushBulkInsert(insertedObjects.get(persistentObjectClass), persistentObjectClass);
	  }
  }
  
  protected void flushRegularInsert(PersistentObject persistentObject, Class<? extends PersistentObject> clazz) {
  	 String insertStatement = dbSqlSessionFactory.getInsertStatement(persistentObject);
     insertStatement = dbSqlSessionFactory.mapStatement(insertStatement);

     if (insertStatement==null) {
       throw new ActivitiException("no insert statement for " + persistentObject.getClass() + " in the ibatis mapping files");
     }
     
     log.debug("inserting: {}", persistentObject);
     sqlSession.insert(insertStatement, persistentObject);
     
     // See https://activiti.atlassian.net/browse/ACT-1290
     if (persistentObject instanceof HasRevision) {
       ((HasRevision) persistentObject).setRevision(((HasRevision) persistentObject).getRevisionNext());
     }
  }

  protected void flushBulkInsert(List<PersistentObject> persistentObjectList, Class<? extends PersistentObject> clazz) {
    String insertStatement = dbSqlSessionFactory.getBulkInsertStatement(clazz);
    insertStatement = dbSqlSessionFactory.mapStatement(insertStatement);

    if (insertStatement==null) {
      throw new ActivitiException("no insert statement for " + persistentObjectList.get(0).getClass() + " in the ibatis mapping files");
    }

    if (persistentObjectList.size() <= dbSqlSessionFactory.getMaxNrOfStatementsInBulkInsert()) {
      sqlSession.insert(insertStatement, persistentObjectList);
    } else {
      
      for (int start = 0; start < persistentObjectList.size(); start += dbSqlSessionFactory.getMaxNrOfStatementsInBulkInsert()) {
        List<PersistentObject> subList = persistentObjectList.subList(start, 
            Math.min(start + dbSqlSessionFactory.getMaxNrOfStatementsInBulkInsert(), persistentObjectList.size()));
        sqlSession.insert(insertStatement, subList);
      }
      
    }

    if (persistentObjectList.get(0) instanceof HasRevision) {
      for (PersistentObject insertedObject: persistentObjectList) {
        ((HasRevision) insertedObject).setRevision(((HasRevision) insertedObject).getRevisionNext());
      }
    }
  }

  protected void flushUpdates(List<PersistentObject> updatedObjects) {
    for (PersistentObject updatedObject: updatedObjects) {
      String updateStatement = dbSqlSessionFactory.getUpdateStatement(updatedObject);
      updateStatement = dbSqlSessionFactory.mapStatement(updateStatement);
      
      if (updateStatement==null) {
        throw new ActivitiException("no update statement for "+updatedObject.getClass()+" in the ibatis mapping files");
      }
      
      log.debug("updating: {}", updatedObject);
      int updatedRecords = sqlSession.update(updateStatement, updatedObject);
      if (updatedRecords!=1) {
        throw new ActivitiOptimisticLockingException(updatedObject + " was updated by another transaction concurrently");
      } 
      
      // See https://activiti.atlassian.net/browse/ACT-1290
      if (updatedObject instanceof HasRevision) {
        ((HasRevision) updatedObject).setRevision(((HasRevision) updatedObject).getRevisionNext());
      }
      
    }
    updatedObjects.clear();
  }

  protected void flushDeletes(List<DeleteOperation> removedOperations) {
    flushRegularDeletes();
    deleteOperations.clear();
  }

  protected void flushRegularDeletes() {
  	for (DeleteOperation delete : deleteOperations) {
      log.debug("executing: {}", delete);
      delete.execute();
    }
  }

  @Override
  public void close() {
    sqlSession.close();
  }

  public void commit() {
    sqlSession.commit();
  }

  public void rollback() {
    sqlSession.rollback();
  }
  
  // schema operations ////////////////////////////////////////////////////////
  
  public void dbSchemaCheckVersion() {
    try {
      String dbVersion = getDbVersion();
      if (!ProcessEngine.VERSION.equals(dbVersion)) {
        throw new ActivitiWrongDbException(ProcessEngine.VERSION, dbVersion);
      }

      String errorMessage = null;
      if (!isEngineTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "engine");
      }
      if (dbSqlSessionFactory.isDbHistoryUsed() && !isHistoryTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "history");
      }
      if (dbSqlSessionFactory.isDbIdentityUsed() && !isIdentityTablePresent()) {
        errorMessage = addMissingComponent(errorMessage, "identity");
      }
      
      if (errorMessage!=null) {
        throw new ActivitiException("Activiti database problem: "+errorMessage);
      }
      
    } catch (Exception e) {
      if (isMissingTablesException(e)) {
        throw new ActivitiException("no activiti tables in db. set <property name=\"databaseSchemaUpdate\" to value=\"true\" or value=\"create-drop\" (use create-drop for testing only!) in bean processEngineConfiguration in activiti.cfg.xml for automatic schema creation", e);
      } else {
        if (e instanceof RuntimeException) {
          throw (RuntimeException) e;
        } else {
          throw new ActivitiException("couldn't get db schema version", e);
        }
      }
    }

    log.debug("activiti db schema check successful");
  }

  protected String addMissingComponent(String missingComponents, String component) {
    if (missingComponents==null) {
      return "Tables missing for component(s) "+component;
    }
    return missingComponents+", "+component;
  }

  protected String getDbVersion() {
    String selectSchemaVersionStatement = dbSqlSessionFactory.mapStatement("selectDbSchemaVersion");
    return (String) sqlSession.selectOne(selectSchemaVersionStatement);
  }

  public void dbSchemaCreate() {
    if (isEngineTablePresent()) {
      String dbVersion = getDbVersion();
      if (!ProcessEngine.VERSION.equals(dbVersion)) {
        throw new ActivitiWrongDbException(ProcessEngine.VERSION, dbVersion);
      }
    } else {
      dbSchemaCreateEngine();
    }

    if (dbSqlSessionFactory.isDbHistoryUsed()) {
      dbSchemaCreateHistory();
    }

    if (dbSqlSessionFactory.isDbIdentityUsed()) {
      dbSchemaCreateIdentity();
    }
  }

  protected void dbSchemaCreateIdentity() {
    executeMandatorySchemaResource("create", "identity");
  }

  protected void dbSchemaCreateHistory() {
    executeMandatorySchemaResource("create", "history");
  }

  protected void dbSchemaCreateEngine() {
    executeMandatorySchemaResource("create", "engine");
  }

  public void dbSchemaDrop() {
    executeMandatorySchemaResource("drop", "engine");
    if (dbSqlSessionFactory.isDbHistoryUsed()) {
      executeMandatorySchemaResource("drop", "history");
    }
    if (dbSqlSessionFactory.isDbIdentityUsed()) {
      executeMandatorySchemaResource("drop", "identity");
    }
  }

  public void dbSchemaPrune() {
    if (isHistoryTablePresent() && !dbSqlSessionFactory.isDbHistoryUsed()) {
      executeMandatorySchemaResource("drop", "history");
    }
    if (isIdentityTablePresent() && dbSqlSessionFactory.isDbIdentityUsed()) {
      executeMandatorySchemaResource("drop", "identity");
    }
  }

  public void executeMandatorySchemaResource(String operation, String component) {
    executeSchemaResource(operation, component, getResourceForDbOperation(operation, operation, component), false);
  }

  public static String[] JDBC_METADATA_TABLE_TYPES = {"TABLE"};

	public String dbSchemaUpdate() {

		String feedback = null;
		boolean isUpgradeNeeded = false;
		int matchingVersionIndex = -1;

		if (isEngineTablePresent()) {

			PropertyEntity dbVersionProperty = selectById(PropertyEntity.class,"schema.version");
			String dbVersion = dbVersionProperty.getValue();

			// Determine index in the sequence of Activiti releases
			int index = 0;
			while (matchingVersionIndex < 0 && index < ACTIVITI_VERSIONS.size()) {
				if (ACTIVITI_VERSIONS.get(index).matches(dbVersion)) {
					matchingVersionIndex = index;
				} else {
					index++;
				}
			}

			// Exception when no match was found: unknown/unsupported version
			if (matchingVersionIndex < 0) {
				throw new ActivitiException(
				    "Could not update Activiti database schema: unknown version from database: '"
				        + dbVersion + "'");
			}

			isUpgradeNeeded = (matchingVersionIndex != (ACTIVITI_VERSIONS.size() - 1));

			if (isUpgradeNeeded) {
				dbVersionProperty.setValue(ProcessEngine.VERSION);

				PropertyEntity dbHistoryProperty;
				if ("5.0".equals(dbVersion)) {
					dbHistoryProperty = new PropertyEntity("schema.history", "create(5.0)");
					insert(dbHistoryProperty);
				} else {
					dbHistoryProperty = selectById(PropertyEntity.class, "schema.history");
				}

				// Set upgrade history
				String dbHistoryValue = dbHistoryProperty.getValue() + " upgrade(" + dbVersion + "->" + ProcessEngine.VERSION + ")";
				dbHistoryProperty.setValue(dbHistoryValue);

				// Engine upgrade
				dbSchemaUpgrade("engine", matchingVersionIndex);
				feedback = "upgraded Activiti from " + dbVersion + " to "+ ProcessEngine.VERSION;
			}

		} else {
			dbSchemaCreateEngine();
		}
		if (isHistoryTablePresent()) {
			if (isUpgradeNeeded) {
				dbSchemaUpgrade("history", matchingVersionIndex);
			}
		} else if (dbSqlSessionFactory.isDbHistoryUsed()) {
			dbSchemaCreateHistory();
		}
    
    if (isIdentityTablePresent()) {
      if (isUpgradeNeeded) {
        dbSchemaUpgrade("identity", matchingVersionIndex);
      }
    } else if (dbSqlSessionFactory.isDbIdentityUsed()) {
      dbSchemaCreateIdentity();
    }
    
    return feedback;
  }

  public boolean isEngineTablePresent(){
    return isTablePresent("ACT_RU_EXECUTION");
  }
  public boolean isHistoryTablePresent(){
    return isTablePresent("ACT_HI_PROCINST");
  }
  public boolean isIdentityTablePresent(){
    return isTablePresent("ACT_ID_USER");
  }

  public boolean isTablePresent(String tableName) {
  	// ACT-1610: in case the prefix IS the schema itself, we don't add the prefix, since the
  	// check is already aware of the schema
  	if (!dbSqlSessionFactory.isTablePrefixIsSchema()) {
  		tableName = prependDatabaseTablePrefix(tableName);
  	}
  	
    Connection connection = null;
    try {
      connection = sqlSession.getConnection();
      DatabaseMetaData databaseMetaData = connection.getMetaData();
      ResultSet tables = null;

      String catalog = this.connectionMetadataDefaultCatalog;
      if (dbSqlSessionFactory.getDatabaseCatalog() != null && dbSqlSessionFactory.getDatabaseCatalog().length() > 0) {
        catalog = dbSqlSessionFactory.getDatabaseCatalog();
      }

      String schema = this.connectionMetadataDefaultSchema;
      if (dbSqlSessionFactory.getDatabaseSchema() != null && dbSqlSessionFactory.getDatabaseSchema().length() > 0) {
        schema = dbSqlSessionFactory.getDatabaseSchema();
      }
      
      String databaseType = dbSqlSessionFactory.getDatabaseType();
      
      if ("postgres".equals(databaseType)) {
        tableName = tableName.toLowerCase();
      }
      
      try {
        tables = databaseMetaData.getTables(catalog, schema, tableName, JDBC_METADATA_TABLE_TYPES);
        return tables.next();
      } finally {
        try {
          tables.close();
        } catch (Exception e) {
          log.error("Error closing meta data tables", e);
        }
      }
      
    } catch (Exception e) {
      throw new ActivitiException("couldn't check if tables are already present using metadata: "+e.getMessage(), e);
    }
  }
  
  protected boolean isUpgradeNeeded(String versionInDatabase) {
    if(ProcessEngine.VERSION.equals(versionInDatabase)) {
      return false;
    }
    
    String cleanDbVersion = getCleanVersion(versionInDatabase);
    String[] cleanDbVersionSplitted = cleanDbVersion.split("\\.");
    int dbMajorVersion = Integer.valueOf(cleanDbVersionSplitted[0]);
    int dbMinorVersion = Integer.valueOf(cleanDbVersionSplitted[1]);
    
    String cleanEngineVersion = getCleanVersion(ProcessEngine.VERSION);
    String[] cleanEngineVersionSplitted = cleanEngineVersion.split("\\.");
    int engineMajorVersion = Integer.valueOf(cleanEngineVersionSplitted[0]);
    int engineMinorVersion = Integer.valueOf(cleanEngineVersionSplitted[1]);
      
    if((dbMajorVersion > engineMajorVersion)
            || ( (dbMajorVersion <= engineMajorVersion) && (dbMinorVersion > engineMinorVersion) )) {
      throw new ActivitiException("Version of activiti database (" + versionInDatabase + ") is more recent than the engine (" + ProcessEngine.VERSION +")");
    } else if(cleanDbVersion.compareTo(cleanEngineVersion) == 0) {
      // Versions don't match exactly, possibly snapshot is being used
      log.warn("Engine-version is the same, but not an exact match: {} vs. {}. Not performing database-upgrade.", versionInDatabase, ProcessEngine.VERSION);
      return false;
    }
    return true;
  }
  
  protected String getCleanVersion(String versionString) {
    Matcher matcher = CLEAN_VERSION_REGEX.matcher(versionString);
    if(!matcher.find()) {
      throw new ActivitiException("Illegal format for version: " + versionString);
    }
    
    String cleanString = matcher.group();
    try {
      Double.parseDouble(cleanString); // try to parse it, to see if it is really a number
      return cleanString;
    } catch(NumberFormatException nfe) {
      throw new ActivitiException("Illegal format for version: " + versionString);
    }
  }
  
  protected String prependDatabaseTablePrefix(String tableName) {
    return dbSqlSessionFactory.getDatabaseTablePrefix() + tableName;    
  }
  
  protected void dbSchemaUpgrade(final String component, final int currentDatabaseVersionsIndex) {
  	ActivitiVersion activitiVersion = ACTIVITI_VERSIONS.get(currentDatabaseVersionsIndex);
  	String dbVersion = activitiVersion.getMainVersion();
    log.info("upgrading activiti {} schema from {} to {}", component, dbVersion, ProcessEngine.VERSION);
    
    // Actual execution of schema DDL SQL
    for (int i=currentDatabaseVersionsIndex + 1; i<ACTIVITI_VERSIONS.size(); i++) {
    	String nextVersion = ACTIVITI_VERSIONS.get(i).getMainVersion();
    	
    	// Taking care of -SNAPSHOT version in development
      if (nextVersion.endsWith("-SNAPSHOT")) {
      	nextVersion = nextVersion.substring(0, nextVersion.length()-"-SNAPSHOT".length());
      }
      
      dbVersion = dbVersion.replace(".", "");
      nextVersion = nextVersion.replace(".", "");
      log.info("Upgrade needed: {} -> {}. Looking for schema update resource for component '{}'", dbVersion, nextVersion, component);
    	executeSchemaResource("upgrade", component, getResourceForDbOperation("upgrade", "upgradestep." + dbVersion + ".to." + nextVersion, component), true);
    	dbVersion = nextVersion;
    }
  }
  
  public String getResourceForDbOperation(String directory, String operation, String component) {
    String databaseType = dbSqlSessionFactory.getDatabaseType();
    return "org/activiti/db/" + directory + "/activiti." + databaseType + "." + operation + "."+component+".sql";
  }

  public void executeSchemaResource(String operation, String component, String resourceName, boolean isOptional) {
    InputStream inputStream = null;
    try {
      inputStream = ReflectUtil.getResourceAsStream(resourceName);
      if (inputStream == null) {
        if (isOptional) {
          log.info("no schema resource {} for {}", resourceName, operation);
        } else {
          throw new ActivitiException("resource '" + resourceName + "' is not available");
        }
      } else {
        executeSchemaResource(operation, component, resourceName, inputStream);
      }

    } finally {
      IoUtil.closeSilently(inputStream);
    }
  }

  private void executeSchemaResource(String operation, String component, String resourceName, InputStream inputStream) {
    log.info("performing {} on {} with resource {}", operation, component, resourceName);
    String sqlStatement = null;
    String exceptionSqlStatement = null;
    try {
      Connection connection = sqlSession.getConnection();
      Exception exception = null;
      byte[] bytes = IoUtil.readInputStream(inputStream, resourceName);
      String ddlStatements = new String(bytes);
      String databaseType = dbSqlSessionFactory.getDatabaseType();
      
      // Special DDL handling for certain databases
      try {
	    	if ("mysql".equals(databaseType)) {
	    	  DatabaseMetaData databaseMetaData = connection.getMetaData();
	    	  int majorVersion = databaseMetaData.getDatabaseMajorVersion();
	    	  int minorVersion = databaseMetaData.getDatabaseMinorVersion();
	    	  log.info("Found MySQL: majorVersion=" + majorVersion + " minorVersion=" + minorVersion);
		      
	    	  // Special care for MySQL < 5.6
	    	  if (majorVersion <= 5 && minorVersion < 6) {
	    	    ddlStatements = updateDdlForMySqlVersionLowerThan56(ddlStatements);
	    	  }
	    	}
      } catch (Exception e) {
        log.info("Could not get database metadata", e);
      }
      
      BufferedReader reader = new BufferedReader(new StringReader(ddlStatements));
      String line = readNextTrimmedLine(reader);
      boolean inOraclePlsqlBlock = false;
      while (line != null) {
        if (line.startsWith("# ")) {
          log.debug(line.substring(2));
          
        } else if (line.startsWith("-- ")) {
          log.debug(line.substring(3));
          
        } else if (line.startsWith("execute java ")) {
          String upgradestepClassName = line.substring(13).trim();
          DbUpgradeStep dbUpgradeStep = null;
          try {
            dbUpgradeStep = (DbUpgradeStep) ReflectUtil.instantiate(upgradestepClassName);
          } catch (ActivitiException e) {
            throw new ActivitiException("database update java class '"+upgradestepClassName+"' can't be instantiated: "+e.getMessage(), e);
          }
          try {
            log.debug("executing upgrade step java class {}", upgradestepClassName);
            dbUpgradeStep.execute(this);
          } catch (Exception e) {
            throw new ActivitiException("error while executing database update java class '"+upgradestepClassName+"': "+e.getMessage(), e);
          }
          
        } else if (line.length()>0) {
          
          if ("oracle".equals(databaseType) && line.startsWith("begin")) {
            inOraclePlsqlBlock = true;
            sqlStatement = addSqlStatementPiece(sqlStatement, line);
            
          } else if ((line.endsWith(";") && inOraclePlsqlBlock == false) ||
              (line.startsWith("/") && inOraclePlsqlBlock == true)) {
            
            if (inOraclePlsqlBlock) {
              inOraclePlsqlBlock = false;
            } else {
              sqlStatement = addSqlStatementPiece(sqlStatement, line.substring(0, line.length()-1));
            }

            Statement jdbcStatement = null;
            try {
              jdbcStatement = connection.createStatement();
              // no logging needed as the connection will log it
              log.debug("SQL: {}", sqlStatement);
              jdbcStatement.execute(sqlStatement);
              jdbcStatement.close();
            } catch (Exception e) {
              if (exception == null) {
                exception = e;
                exceptionSqlStatement = sqlStatement;
              }
              log.error("problem during schema {}, statement {}", operation, sqlStatement, e);
            } finally {
              try{
                jdbcStatement.close();
              } catch (Exception ex){ /* ignored */ }
              sqlStatement = null;
            }
          } else {
            sqlStatement = addSqlStatementPiece(sqlStatement, line);
          }
        }
        
        line = readNextTrimmedLine(reader);
      }

      if (exception != null) {
        throw exception;
      }
      
      log.debug("activiti db schema {} for component {} successful", operation, component);
      
    } catch (Exception e) {
      throw new ActivitiException("couldn't "+operation+" db schema: "+exceptionSqlStatement, e);
    }
  }
  
  /**
   * MySQL is funny when it comes to timestamps and dates.
   *  
   * More specifically, for a DDL statement like 'MYCOLUMN timestamp(3)':
   *   - MySQL 5.6.4+ has support for timestamps/dates with millisecond (or smaller) precision. 
   *     The DDL above works and the data in the table will have millisecond precision
   *   - MySQL < 5.5.3 allows the DDL statement, but ignores it.
   *     The DDL above works but the data won't have millisecond precision
   *   - MySQL 5.5.3 < [version] < 5.6.4 gives and exception when using the DDL above.
   *   
   * Also, the 5.5 and 5.6 branches of MySQL are both actively developed and patched.
   * 
   * Hence, when doing auto-upgrade/creation of the Activiti tables, the default 
   * MySQL DDL file is used and all timestamps/datetimes are converted to not use the 
   * millisecond precision by string replacement done in the method below.
   * 
   * If using the DDL files directly (which is a sane choice in production env.),
   * there is a distinction between MySQL version < 5.6.
   */
  protected String updateDdlForMySqlVersionLowerThan56(String ddlStatements) {
	  return ddlStatements.replace("timestamp(3)", "timestamp")
			  			  .replace("datetime(3)", "datetime")
			  			  .replace("TIMESTAMP(3)", "TIMESTAMP")
			  			  .replace("DATETIME(3)", "DATETIME");
  }

  protected String addSqlStatementPiece(String sqlStatement, String line) {
    if (sqlStatement==null) {
      return line;
    }
    return sqlStatement + " \n" + line;
  }
  
  protected String readNextTrimmedLine(BufferedReader reader) throws IOException {
    String line = reader.readLine();
    if (line!=null) {
      line = line.trim();
    }
    return line;
  }
  
  protected boolean isMissingTablesException(Exception e) {
    String exceptionMessage = e.getMessage();
    if(e.getMessage() != null) {      
      // Matches message returned from H2
      if ((exceptionMessage.indexOf("Table") != -1) && (exceptionMessage.indexOf("not found") != -1)) {
        return true;
      }
      
      // Message returned from MySQL and Oracle
      if (((exceptionMessage.indexOf("Table") != -1 || exceptionMessage.indexOf("table") != -1)) && (exceptionMessage.indexOf("doesn't exist") != -1)) {
        return true;
      }
      
      // Message returned from Postgres
      if (((exceptionMessage.indexOf("relation") != -1 || exceptionMessage.indexOf("table") != -1)) && (exceptionMessage.indexOf("does not exist") != -1)) {
        return true;
      }
    }
    return false;
  }
  
  public void performSchemaOperationsProcessEngineBuild() {
    String databaseSchemaUpdate = Context.getProcessEngineConfiguration().getDatabaseSchemaUpdate();
    if (ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_DROP_CREATE.equals(databaseSchemaUpdate)) {
      try {
        dbSchemaDrop();
      } catch (RuntimeException e) {
        // ignore
      }
    }
    if ( org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_CREATE_DROP.equals(databaseSchemaUpdate) 
         || ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_DROP_CREATE.equals(databaseSchemaUpdate)
         || ProcessEngineConfigurationImpl.DB_SCHEMA_UPDATE_CREATE.equals(databaseSchemaUpdate)
       ) {
      dbSchemaCreate();
      
    } else if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE.equals(databaseSchemaUpdate)) {
      dbSchemaCheckVersion();
      
    } else if (ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE.equals(databaseSchemaUpdate)) {
      dbSchemaUpdate();
    }
  }

  public void performSchemaOperationsProcessEngineClose() {
    String databaseSchemaUpdate = Context.getProcessEngineConfiguration().getDatabaseSchemaUpdate();
    if (org.activiti.engine.ProcessEngineConfiguration.DB_SCHEMA_UPDATE_CREATE_DROP.equals(databaseSchemaUpdate)) {
      dbSchemaDrop();
    }
  }
  
  public <T> T getCustomMapper(Class<T> type) {
	  return sqlSession.getMapper(type);
  }

  // query factory methods ////////////////////////////////////////////////////  

  public DeploymentQueryImpl createDeploymentQuery() {
    return new DeploymentQueryImpl();
  }
  public ModelQueryImpl createModelQueryImpl() {
    return new ModelQueryImpl();
  }
  public ProcessDefinitionQueryImpl createProcessDefinitionQuery() {
    return new ProcessDefinitionQueryImpl();
  }
  public ProcessInstanceQueryImpl createProcessInstanceQuery() {
    return new ProcessInstanceQueryImpl();
  }
  public ExecutionQueryImpl createExecutionQuery() {
    return new ExecutionQueryImpl();
  }
  public TaskQueryImpl createTaskQuery() {
    return new TaskQueryImpl();
  }
  public JobQueryImpl createJobQuery() {
    return new JobQueryImpl();
  }
  public HistoricProcessInstanceQueryImpl createHistoricProcessInstanceQuery() {
    return new HistoricProcessInstanceQueryImpl();
  }
  public HistoricActivityInstanceQueryImpl createHistoricActivityInstanceQuery() {
    return new HistoricActivityInstanceQueryImpl();
  }
  public HistoricTaskInstanceQueryImpl createHistoricTaskInstanceQuery() {
    return new HistoricTaskInstanceQueryImpl();
  }
  public HistoricDetailQueryImpl createHistoricDetailQuery() {
    return new HistoricDetailQueryImpl();
  }
  public HistoricVariableInstanceQueryImpl createHistoricVariableInstanceQuery() {
    return new HistoricVariableInstanceQueryImpl();
  }
  public UserQueryImpl createUserQuery() {
    return new UserQueryImpl();
  }
  public GroupQueryImpl createGroupQuery() {
    return new GroupQueryImpl();
  }

  // getters and setters //////////////////////////////////////////////////////
  
  public SqlSession getSqlSession() {
    return sqlSession;
  }
  public DbSqlSessionFactory getDbSqlSessionFactory() {
    return dbSqlSessionFactory;
  }

}
!@#$%
20190526_171720,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.db;

import java.io.File;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * @author Tom Baeyens
 */
public class DbSchemaExport {

  public static void main(String[] args) throws Exception {
    if (args == null || args.length != 1) {
      System.err.println("Syntax: java -cp ... org.activiti.engine.impl.db.DbSchemaExport <path-to-properties-file> <path-to-export-file>");
      return;
    }
    File propertiesFile = new File(args[0]);
    if (!propertiesFile.exists()) {
      System.err.println("File '" + args[0] + "' doesn't exist \n" + "Syntax: java -cp ... org.activiti.engine.impl.db.DbSchemaExport <path-to-properties-file> <path-to-export-file>\n");
      return;
    }
    Properties properties = new Properties();
    properties.load(new FileInputStream(propertiesFile));

    String jdbcDriver = properties.getProperty("jdbc.driver");
    String jdbcUrl = properties.getProperty("jdbc.url");
    String jdbcUsername = properties.getProperty("jdbc.username");
    String jdbcPassword = properties.getProperty("jdbc.password");

    Class.forName(jdbcDriver);
    Connection connection = DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword);
    try {
      DatabaseMetaData meta = connection.getMetaData();

      SortedSet<String> tableNames = new TreeSet<String>();
      ResultSet tables = meta.getTables(null, null, null, null);
      while (tables.next()) {
        String tableName = tables.getString(3);
        tableNames.add(tableName);
      }

      System.out.println("TABLES");
      for (String tableName : tableNames) {
        Map<String, String> columnDescriptions = new HashMap<String, String>();
        ResultSet columns = meta.getColumns(null, null, tableName, null);
        while (columns.next()) {
          String columnName = columns.getString(4);
          String columnTypeAndSize = columns.getString(6) + " " + columns.getInt(7);
          columnDescriptions.put(columnName, columnTypeAndSize);
        }

        System.out.println(tableName);
        for (String columnName : new TreeSet<String>(columnDescriptions.keySet())) {
          System.out.println("  " + columnName + " " + columnDescriptions.get(columnName));
        }

        System.out.println("INDEXES");
        SortedSet<String> indexNames = new TreeSet<String>();
        ResultSet indexes = meta.getIndexInfo(null, null, tableName, false, true);
        while (indexes.next()) {
          String indexName = indexes.getString(6);
          indexNames.add(indexName);
        }
        for (String indexName : indexNames) {
          System.out.println(indexName);
        }
        System.out.println();
      }

    } catch (Exception e) {
      e.printStackTrace();
      connection.close();
    }
  }
}
!@#$%
20190526_171720,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.db;

import java.io.File;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.SortedSet;
import java.util.TreeSet;


/**
 * @author Tom Baeyens
 */
public class DbSchemaExport {

  public static void main(String[] args) throws Exception {
    if (args==null || args.length!=1) {
      System.err.println("Syntax: java -cp ... org.activiti.engine.impl.db.DbSchemaExport <path-to-properties-file> <path-to-export-file>");
      return;
    }
    File propertiesFile = new File(args[0]);
    if (!propertiesFile.exists()) {
      System.err.println("File '"+args[0]+"' doesn't exist \n" +
      		               "Syntax: java -cp ... org.activiti.engine.impl.db.DbSchemaExport <path-to-properties-file> <path-to-export-file>\n");
      return;
    }
    Properties properties = new Properties();
    properties.load(new FileInputStream(propertiesFile));
    
    String jdbcDriver = properties.getProperty("jdbc.driver");
    String jdbcUrl = properties.getProperty("jdbc.url");
    String jdbcUsername = properties.getProperty("jdbc.username");
    String jdbcPassword = properties.getProperty("jdbc.password");
    
    Class.forName(jdbcDriver);
    Connection connection = DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword);
    try {
      DatabaseMetaData meta = connection.getMetaData();
      
      SortedSet<String> tableNames = new TreeSet<String>();
      ResultSet tables = meta.getTables(null, null, null, null);
      while (tables.next()) {
        String tableName = tables.getString(3);
        tableNames.add(tableName);
      }
      
      System.out.println("TABLES");
      for (String tableName: tableNames) {
        Map<String, String> columnDescriptions = new HashMap<String, String>();
        ResultSet columns = meta.getColumns(null, null, tableName, null);
        while (columns.next()) {
          String columnName = columns.getString(4);
          String columnTypeAndSize = columns.getString(6)+" "+columns.getInt(7);
          columnDescriptions.put(columnName, columnTypeAndSize);
        }
        
        System.out.println(tableName);
        for (String columnName: new TreeSet<String>(columnDescriptions.keySet())) {
          System.out.println("  "+columnName+" "+columnDescriptions.get(columnName));
        }

        System.out.println("INDEXES");
        SortedSet<String> indexNames = new TreeSet<String>();
        ResultSet indexes = meta.getIndexInfo(null, null, tableName, false, true);
        while (indexes.next()) {
          String indexName = indexes.getString(6);
          indexNames.add(indexName);
        }
        for (String indexName: indexNames) {
          System.out.println(indexName);
        }
        System.out.println();
      }


    } catch (Exception e) {
      e.printStackTrace();
      connection.close();
    }
  }
}
!@#$%
20190526_171720,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.db;

import java.io.File;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.SortedSet;
import java.util.TreeSet;


/**
 * @author Tom Baeyens
 */
public class DbSchemaExport {

  public static void main(String[] args) throws Exception {
    if (args==null || args.length!=1) {
      System.err.println("Syntax: java -cp ... org.activiti.engine.impl.db.DbSchemaExport <path-to-properties-file> <path-to-export-file>");
      return;
    }
    File propertiesFile = new File(args[0]);
    if (!propertiesFile.exists()) {
      System.err.println("File '"+args[0]+"' doesn't exist \n" +
      		               "Syntax: java -cp ... org.activiti.engine.impl.db.DbSchemaExport <path-to-properties-file> <path-to-export-file>\n");
      return;
    }
    Properties properties = new Properties();
    properties.load(new FileInputStream(propertiesFile));
    
    String jdbcDriver = properties.getProperty("jdbc.driver");
    String jdbcUrl = properties.getProperty("jdbc.url");
    String jdbcUsername = properties.getProperty("jdbc.username");
    String jdbcPassword = properties.getProperty("jdbc.password");
    
    Class.forName(jdbcDriver);
    Connection connection = null;
    try {
      connection = DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword);
      DatabaseMetaData meta = connection.getMetaData();
      
      SortedSet<String> tableNames = new TreeSet<String>();
      ResultSet tables = meta.getTables(null, null, null, null);
      while (tables.next()) {
        String tableName = tables.getString(3);
        tableNames.add(tableName);
      }
      
      System.out.println("TABLES");
      for (String tableName: tableNames) {
        Map<String, String> columnDescriptions = new HashMap<String, String>();
        ResultSet columns = meta.getColumns(null, null, tableName, null);
        while (columns.next()) {
          String columnName = columns.getString(4);
          String columnTypeAndSize = columns.getString(6)+" "+columns.getInt(7);
          columnDescriptions.put(columnName, columnTypeAndSize);
        }
        
        System.out.println(tableName);
        for (String columnName: new TreeSet<String>(columnDescriptions.keySet())) {
          System.out.println("  "+columnName+" "+columnDescriptions.get(columnName));
        }

        System.out.println("INDEXES");
        SortedSet<String> indexNames = new TreeSet<String>();
        ResultSet indexes = meta.getIndexInfo(null, null, tableName, false, true);
        while (indexes.next()) {
          String indexName = indexes.getString(6);
          indexNames.add(indexName);
        }
        for (String indexName: indexNames) {
          System.out.println(indexName);
        }
        System.out.println();
      }


    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      if (connection != null) {
        try {
          connection.close();
        } catch (SQLException e) { /* ignored */}
      }
    }
  }
}
!@#$%
20190526_171741,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.cfg.jta;

import javax.transaction.RollbackException;
import javax.transaction.Status;
import javax.transaction.Synchronization;
import javax.transaction.SystemException;
import javax.transaction.Transaction;
import javax.transaction.TransactionManager;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.impl.cfg.TransactionContext;
import org.activiti.engine.impl.cfg.TransactionListener;
import org.activiti.engine.impl.cfg.TransactionState;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.interceptor.CommandContext;

/**
 * @author Daniel Meyer
 */
public class JtaTransactionContext implements TransactionContext {

  protected final TransactionManager transactionManager;

  public JtaTransactionContext(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
  }

  public void commit() {
    // managed transaction, ignore
  }

  public void rollback() {
    // managed transaction, mark rollback-only if not done so already.
    try {
      Transaction transaction = getTransaction();
      int status = transaction.getStatus();
      if (status != Status.STATUS_NO_TRANSACTION && status != Status.STATUS_ROLLEDBACK) {
        transaction.setRollbackOnly();
      }
    } catch (IllegalStateException e) {
      throw new ActivitiException("Unexpected IllegalStateException while marking transaction rollback only");
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while marking transaction rollback only");
    }
  }

  protected Transaction getTransaction() {
    try {
      return transactionManager.getTransaction();
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while getting transaction ", e);
    }
  }

  public void addTransactionListener(TransactionState transactionState, final TransactionListener transactionListener) {
    Transaction transaction = getTransaction();
    CommandContext commandContext = Context.getCommandContext();
    try {
      transaction.registerSynchronization(new TransactionStateSynchronization(transactionState, transactionListener, commandContext));
    } catch (IllegalStateException e) {
      throw new ActivitiException("IllegalStateException while registering synchronization ", e);
    } catch (RollbackException e) {
      throw new ActivitiException("RollbackException while registering synchronization ", e);
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while registering synchronization ", e);
    }
  }

  public static class TransactionStateSynchronization implements Synchronization {

    protected final TransactionListener transactionListener;
    protected final TransactionState transactionState;
    private final CommandContext commandContext;

    public TransactionStateSynchronization(TransactionState transactionState, TransactionListener transactionListener, CommandContext commandContext) {
      this.transactionState = transactionState;
      this.transactionListener = transactionListener;
      this.commandContext = commandContext;
    }

    public void beforeCompletion() {
      if (TransactionState.COMMITTING.equals(transactionState) || TransactionState.ROLLINGBACK.equals(transactionState)) {
        transactionListener.execute(commandContext);
      }
    }

    public void afterCompletion(int status) {
      if (Status.STATUS_ROLLEDBACK == status && TransactionState.ROLLED_BACK.equals(transactionState)) {
        transactionListener.execute(commandContext);
      } else if (Status.STATUS_COMMITTED == status && TransactionState.COMMITTED.equals(transactionState)) {
        transactionListener.execute(commandContext);
      }
    }

  }

}
!@#$%
20190526_171741,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.cfg.jta;

import javax.transaction.RollbackException;
import javax.transaction.Status;
import javax.transaction.Synchronization;
import javax.transaction.SystemException;
import javax.transaction.Transaction;
import javax.transaction.TransactionManager;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.impl.cfg.TransactionContext;
import org.activiti.engine.impl.cfg.TransactionListener;
import org.activiti.engine.impl.cfg.TransactionState;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.interceptor.CommandContext;

/**
 * @author Daniel Meyer
 */
public class JtaTransactionContext implements TransactionContext {

  protected final TransactionManager transactionManager;

  public JtaTransactionContext(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
  }

  public void commit() {
    // managed transaction, ignore
  }

  public void rollback() {
    // managed transaction, mark rollback-only if not done so already.
    try {
      Transaction transaction = getTransaction();
      int status = transaction.getStatus();
      if (status != Status.STATUS_NO_TRANSACTION && status != Status.STATUS_ROLLEDBACK) {
        transaction.setRollbackOnly();
      }
    } catch (IllegalStateException e) {
      throw new ActivitiException("Unexpected IllegalStateException while marking transaction rollback only");
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while marking transaction rollback only");
    }
  }

  protected Transaction getTransaction() {
    try {
      return transactionManager.getTransaction();
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while getting transaction ", e);
    }
  }

  public void addTransactionListener(TransactionState transactionState, final TransactionListener transactionListener) {
    Transaction transaction = getTransaction();
    CommandContext commandContext = Context.getCommandContext();    
    try {
      transaction.registerSynchronization(new TransactionStateSynchronization(transactionState, transactionListener, commandContext));
    } catch (IllegalStateException e) {
      throw new ActivitiException("IllegalStateException while registering synchronization ", e);
    } catch (RollbackException e) {
      throw new ActivitiException("RollbackException while registering synchronization ", e);
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while registering synchronization ", e);
    }   
  }
  
  public static class TransactionStateSynchronization implements Synchronization {
        
    protected final TransactionListener transactionListener;
    protected final TransactionState transactionState;
    private final CommandContext commandContext;    

    public TransactionStateSynchronization(TransactionState transactionState, TransactionListener transactionListener, CommandContext commandContext) {
      this.transactionState = transactionState;
      this.transactionListener = transactionListener;
      this.commandContext = commandContext;
    }

    public void beforeCompletion() {
      if(TransactionState.COMMITTING.equals(transactionState) 
         || TransactionState.ROLLINGBACK.equals(transactionState)) {
        transactionListener.execute(commandContext);
      }
    }

    public void afterCompletion(int status) {
      if(Status.STATUS_ROLLEDBACK == status && TransactionState.ROLLED_BACK.equals(transactionState)) {
        transactionListener.execute(commandContext);
      } else if(Status.STATUS_COMMITTED == status && TransactionState.COMMITTED.equals(transactionState)) {
        transactionListener.execute(commandContext);
      }
    }
    
  }
  

}
!@#$%
20190526_171741,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl.cfg.jta;

import javax.transaction.RollbackException;
import javax.transaction.Status;
import javax.transaction.Synchronization;
import javax.transaction.SystemException;
import javax.transaction.Transaction;
import javax.transaction.TransactionManager;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.impl.cfg.TransactionContext;
import org.activiti.engine.impl.cfg.TransactionListener;
import org.activiti.engine.impl.cfg.TransactionPropagation;
import org.activiti.engine.impl.cfg.TransactionState;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.interceptor.Command;
import org.activiti.engine.impl.interceptor.CommandConfig;
import org.activiti.engine.impl.interceptor.CommandContext;
import org.activiti.engine.impl.interceptor.CommandExecutor;

/**
 * @author Daniel Meyer
 */
public class JtaTransactionContext implements TransactionContext {

  protected final TransactionManager transactionManager;

  public JtaTransactionContext(TransactionManager transactionManager) {
    this.transactionManager = transactionManager;
  }

  public void commit() {
    // managed transaction, ignore
  }

  public void rollback() {
    // managed transaction, mark rollback-only if not done so already.
    try {
      Transaction transaction = getTransaction();
      int status = transaction.getStatus();
      if (status != Status.STATUS_NO_TRANSACTION && status != Status.STATUS_ROLLEDBACK) {
        transaction.setRollbackOnly();
      }
    } catch (IllegalStateException e) {
      throw new ActivitiException("Unexpected IllegalStateException while marking transaction rollback only");
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while marking transaction rollback only");
    }
  }

  protected Transaction getTransaction() {
    try {
      return transactionManager.getTransaction();
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while getting transaction ", e);
    }
  }

  public void addTransactionListener(TransactionState transactionState, final TransactionListener transactionListener) {
    Transaction transaction = getTransaction();
    CommandContext commandContext = Context.getCommandContext();    
    try {
      transaction.registerSynchronization(new TransactionStateSynchronization(transactionState, transactionListener, commandContext));
    } catch (IllegalStateException e) {
      throw new ActivitiException("IllegalStateException while registering synchronization ", e);
    } catch (RollbackException e) {
      throw new ActivitiException("RollbackException while registering synchronization ", e);
    } catch (SystemException e) {
      throw new ActivitiException("SystemException while registering synchronization ", e);
    }   
  }
  
  public static class TransactionStateSynchronization implements Synchronization {
        
    protected final TransactionListener transactionListener;
    protected final TransactionState transactionState;
    private final CommandContext commandContext;    

    public TransactionStateSynchronization(TransactionState transactionState, TransactionListener transactionListener, CommandContext commandContext) {
      this.transactionState = transactionState;
      this.transactionListener = transactionListener;
      this.commandContext = commandContext;
    }

    public void beforeCompletion() {
      if(TransactionState.COMMITTING.equals(transactionState) 
         || TransactionState.ROLLINGBACK.equals(transactionState)) {
        transactionListener.execute(commandContext);
      }
    }

    public void afterCompletion(int status) {
      if(Status.STATUS_ROLLEDBACK == status && TransactionState.ROLLED_BACK.equals(transactionState)) {
        executeTransactionListenerInNewCommandContext();
      } else if(Status.STATUS_COMMITTED == status && TransactionState.COMMITTED.equals(transactionState)) {
        executeTransactionListenerInNewCommandContext();
      }
    }

    protected void executeTransactionListenerInNewCommandContext() {
      CommandExecutor commandExecutor = commandContext.getProcessEngineConfiguration().getCommandExecutor(); 
      CommandConfig commandConfig = new CommandConfig(false, TransactionPropagation.REQUIRES_NEW); 
      commandExecutor.execute(commandConfig, new Command<Void>() {
        public Void execute(CommandContext commandContext) {
          transactionListener.execute(commandContext);
          return null;
        }
      });
    }
    
  }
  

}
!@#$%
20190526_171745,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.calendar;

import java.util.Date;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.runtime.ClockReader;
import org.joda.time.DateTime;
import org.joda.time.Period;

public class DueDateBusinessCalendar extends BusinessCalendarImpl {

  public static final String NAME = "dueDate";

  public DueDateBusinessCalendar(ClockReader clockReader) {
    super(clockReader);
  }

  @Override
  public Date resolveDuedate(String duedate, int maxIterations) {
    try {
      // check if due period was specified
      if(duedate.startsWith("P")){
        return new DateTime(clockReader.getCurrentTime()).plus(Period.parse(duedate)).toDate();
      }

      return DateTime.parse(duedate).toDate();

    } catch (Exception e) {
      throw new ActivitiException("couldn't resolve duedate: " + e.getMessage(), e);
    }
  }
}
!@#$%
20190526_171745,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.calendar;

import java.util.Date;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.runtime.ClockReader;
import org.joda.time.DateTime;
import org.joda.time.Period;


public class DueDateBusinessCalendar extends BusinessCalendarImpl {

  public static final String NAME = "dueDate";

  public DueDateBusinessCalendar(ClockReader clockReader) {
    super(clockReader);
  }

  @Override
  public Date resolveDuedate(String duedate, int maxIterations) {
    try {
      // check if due period was specified
      if(duedate.startsWith("P")){
        return DateTime.now().plus(Period.parse(duedate)).toDate();
      }

      return DateTime.parse(duedate).toDate();

    } catch (Exception e) {
      throw new ActivitiException("couldn't resolve duedate: " + e.getMessage(), e);
    }
  }
}
!@#$%
20190526_171745,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.calendar;

import java.util.Date;

import org.activiti.engine.ActivitiException;
import org.activiti.engine.runtime.ClockReader;
import org.joda.time.DateTime;
import org.joda.time.Period;


public class DueDateBusinessCalendar extends BusinessCalendarImpl {

  public static final String NAME = "dueDate";

  public DueDateBusinessCalendar(ClockReader clockReader) {
    super(clockReader);
  }

  @Override
  public Date resolveDuedate(String duedate, int maxIterations) {
    try {
      // check if due period was specified
      if(duedate.startsWith("P")){
        return new DateTime(clockReader.getCurrentTime()).plus(Period.parse(duedate)).toDate();
      }

      return DateTime.parse(duedate).toDate();

    } catch (Exception e) {
      throw new ActivitiException("couldn't resolve duedate: " + e.getMessage(), e);
    }
  }
}
!@#$%
20190526_171836,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl;

/**
 * Used to indicate the operator that should be used to comparing values in a query clause.
 * 
 * @author Frederik Heremans
 */
public enum QueryOperator {
  EQUALS,
  NOT_EQUALS,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LIKE,
  EQUALS_IGNORE_CASE,
  NOT_EQUALS_IGNORE_CASE,
  LIKE_IGNORE_CASE,
}
!@#$%
20190526_171836,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl;


/**
 * Used to indicate the operator that should be used to comparing values in a query clause.
 * 
 * @author Frederik Heremans
 */
public enum QueryOperator {
  EQUALS,
  NOT_EQUALS,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LIKE,
  EQUALS_IGNORE_CASE,
  NOT_EQUALS_IGNORE_CASE,
}
!@#$%
20190526_171836,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl;


/**
 * Used to indicate the operator that should be used to comparing values in a query clause.
 * 
 * @author Frederik Heremans
 */
public enum QueryOperator {
  EQUALS,
  NOT_EQUALS,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LIKE,
  EQUALS_IGNORE_CASE,
  NOT_EQUALS_IGNORE_CASE,
  LIKE_IGNORE_CASE,
}
!@#$%
20190526_171849,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl;

import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.query.QueryProperty;

/**
 * Contains the possible properties which can be used in a {@link HistoricProcessInstanceQueryProperty}.
 * 
 * @author Joram Barrez
 */
public class HistoricProcessInstanceQueryProperty implements QueryProperty {

  private static final long serialVersionUID = 1L;

  private static final Map<String, HistoricProcessInstanceQueryProperty> properties = new HashMap<String, HistoricProcessInstanceQueryProperty>();

  public static final HistoricProcessInstanceQueryProperty PROCESS_INSTANCE_ID_ = new HistoricProcessInstanceQueryProperty("RES.PROC_INST_ID_");
  public static final HistoricProcessInstanceQueryProperty PROCESS_DEFINITION_ID = new HistoricProcessInstanceQueryProperty("RES.PROC_DEF_ID_");
  public static final HistoricProcessInstanceQueryProperty PROCESS_DEFINITION_KEY = new HistoricProcessInstanceQueryProperty("DEF.KEY_");
  public static final HistoricProcessInstanceQueryProperty BUSINESS_KEY = new HistoricProcessInstanceQueryProperty("RES.BUSINESS_KEY_");
  public static final HistoricProcessInstanceQueryProperty START_TIME = new HistoricProcessInstanceQueryProperty("RES.START_TIME_");
  public static final HistoricProcessInstanceQueryProperty END_TIME = new HistoricProcessInstanceQueryProperty("RES.END_TIME_");
  public static final HistoricProcessInstanceQueryProperty DURATION = new HistoricProcessInstanceQueryProperty("RES.DURATION_");
  public static final HistoricProcessInstanceQueryProperty TENANT_ID = new HistoricProcessInstanceQueryProperty("RES.TENANT_ID_");

  public static final HistoricProcessInstanceQueryProperty INCLUDED_VARIABLE_TIME = new HistoricProcessInstanceQueryProperty("VAR.LAST_UPDATED_TIME_");

  private String name;

  public HistoricProcessInstanceQueryProperty(String name) {
    this.name = name;
    properties.put(name, this);
  }

  public String getName() {
    return name;
  }

  public static HistoricProcessInstanceQueryProperty findByName(String propertyName) {
    return properties.get(propertyName);
  }

}
!@#$%
20190526_171849,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl;

import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.query.QueryProperty;


/**
 * Contains the possible properties which can be used in a {@link HistoricProcessInstanceQueryProperty}.
 * 
 * @author Joram Barrez
 */
public class HistoricProcessInstanceQueryProperty implements QueryProperty {
  
  private static final long serialVersionUID = 1L;

  private static final Map<String, HistoricProcessInstanceQueryProperty> properties = new HashMap<String, HistoricProcessInstanceQueryProperty>();

  public static final HistoricProcessInstanceQueryProperty PROCESS_INSTANCE_ID_ = new HistoricProcessInstanceQueryProperty("RES.PROC_INST_ID_");
  public static final HistoricProcessInstanceQueryProperty PROCESS_DEFINITION_ID = new HistoricProcessInstanceQueryProperty("RES.PROC_DEF_ID_");
  public static final HistoricProcessInstanceQueryProperty BUSINESS_KEY = new HistoricProcessInstanceQueryProperty("RES.BUSINESS_KEY_");
  public static final HistoricProcessInstanceQueryProperty START_TIME = new HistoricProcessInstanceQueryProperty("RES.START_TIME_");
  public static final HistoricProcessInstanceQueryProperty END_TIME = new HistoricProcessInstanceQueryProperty("RES.END_TIME_");
  public static final HistoricProcessInstanceQueryProperty DURATION = new HistoricProcessInstanceQueryProperty("RES.DURATION_");
  public static final HistoricProcessInstanceQueryProperty TENANT_ID = new HistoricProcessInstanceQueryProperty("RES.TENANT_ID_");
  
  public static final HistoricProcessInstanceQueryProperty INCLUDED_VARIABLE_TIME = new HistoricProcessInstanceQueryProperty("VAR.LAST_UPDATED_TIME_");
  
  private String name;

  public HistoricProcessInstanceQueryProperty(String name) {
    this.name = name;
    properties.put(name, this);
  }

  public String getName() {
    return name;
  }
  
  public static HistoricProcessInstanceQueryProperty findByName(String propertyName) {
    return properties.get(propertyName);
  }

}
!@#$%
20190526_171849,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.engine.impl;

import java.util.HashMap;
import java.util.Map;

import org.activiti.engine.query.QueryProperty;


/**
 * Contains the possible properties which can be used in a {@link HistoricProcessInstanceQueryProperty}.
 * 
 * @author Joram Barrez
 */
public class HistoricProcessInstanceQueryProperty implements QueryProperty {
  
  private static final long serialVersionUID = 1L;

  private static final Map<String, HistoricProcessInstanceQueryProperty> properties = new HashMap<String, HistoricProcessInstanceQueryProperty>();

  public static final HistoricProcessInstanceQueryProperty PROCESS_INSTANCE_ID_ = new HistoricProcessInstanceQueryProperty("RES.PROC_INST_ID_");
  public static final HistoricProcessInstanceQueryProperty PROCESS_DEFINITION_ID = new HistoricProcessInstanceQueryProperty("RES.PROC_DEF_ID_");
  public static final HistoricProcessInstanceQueryProperty PROCESS_DEFINITION_KEY = new HistoricProcessInstanceQueryProperty("DEF.KEY_");
  public static final HistoricProcessInstanceQueryProperty BUSINESS_KEY = new HistoricProcessInstanceQueryProperty("RES.BUSINESS_KEY_");
  public static final HistoricProcessInstanceQueryProperty START_TIME = new HistoricProcessInstanceQueryProperty("RES.START_TIME_");
  public static final HistoricProcessInstanceQueryProperty END_TIME = new HistoricProcessInstanceQueryProperty("RES.END_TIME_");
  public static final HistoricProcessInstanceQueryProperty DURATION = new HistoricProcessInstanceQueryProperty("RES.DURATION_");
  public static final HistoricProcessInstanceQueryProperty TENANT_ID = new HistoricProcessInstanceQueryProperty("RES.TENANT_ID_");
  
  public static final HistoricProcessInstanceQueryProperty INCLUDED_VARIABLE_TIME = new HistoricProcessInstanceQueryProperty("VAR.LAST_UPDATED_TIME_");
  
  private String name;

  public HistoricProcessInstanceQueryProperty(String name) {
    this.name = name;
    properties.put(name, this);
  }

  public String getName() {
    return name;
  }
  
  public static HistoricProcessInstanceQueryProperty findByName(String propertyName) {
    return properties.get(propertyName);
  }

}
!@#$%
20190526_171910,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.delegate.event.impl;

import java.util.Map;

import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.FlowNode;
import org.activiti.engine.delegate.DelegateExecution;
import org.activiti.engine.delegate.event.ActivitiActivityCancelledEvent;
import org.activiti.engine.delegate.event.ActivitiActivityEvent;
import org.activiti.engine.delegate.event.ActivitiCancelledEvent;
import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEntityWithVariablesEvent;
import org.activiti.engine.delegate.event.ActivitiErrorEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.delegate.event.ActivitiExceptionEvent;
import org.activiti.engine.delegate.event.ActivitiMembershipEvent;
import org.activiti.engine.delegate.event.ActivitiMessageEvent;
import org.activiti.engine.delegate.event.ActivitiProcessStartedEvent;
import org.activiti.engine.delegate.event.ActivitiSequenceFlowTakenEvent;
import org.activiti.engine.delegate.event.ActivitiSignalEvent;
import org.activiti.engine.delegate.event.ActivitiVariableEvent;
import org.activiti.engine.impl.context.ExecutionContext;
import org.activiti.engine.impl.persistence.entity.ExecutionEntity;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity;
import org.activiti.engine.impl.variable.VariableType;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.task.Task;

/**
 * Builder class used to create {@link ActivitiEvent} implementations.
 *
 * @author Frederik Heremans
 */
public class ActivitiEventBuilder {

  /**
   * @param type
   *          type of event
   * @return an {@link ActivitiEvent} that doesn't have it's execution context-fields filled, as the event is a global event, independent of any running execution.
   */
  public static ActivitiEvent createGlobalEvent(ActivitiEventType type) {
    ActivitiEventImpl newEvent = new ActivitiEventImpl(type);
    return newEvent;
  }

  public static ActivitiEvent createEvent(ActivitiEventType type, String executionId, String processInstanceId, String processDefinitionId) {
    ActivitiEventImpl newEvent = new ActivitiEventImpl(type);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    return newEvent;
  }

  /**
   * @param type
   *          type of event
   * @param entity
   *          the entity this event targets
   * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related event fields will be populated. If not, execution details will be retrieved from the
   *         {@link Object} if possible.
   */
  public static ActivitiEntityEvent createEntityEvent(ActivitiEventType type, Object entity) {
    ActivitiEntityEventImpl newEvent = new ActivitiEntityEventImpl(entity, type);

    // In case an execution-context is active, populate the event fields
    // related to the execution
    populateEventWithCurrentContext(newEvent);
    return newEvent;
  }

  /**
   * @param entity
   *            the entity this event targets
   * @param variables
   *            the variables associated with this entity
   * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
   *         event fields will be populated. If not, execution details will be reteived from the {@link Object} if
   *         possible.
   */
  @SuppressWarnings("rawtypes")
  public static ActivitiProcessStartedEvent createProcessStartedEvent(final Object entity,
          final Map variables, final boolean localScope) {
      final ActivitiProcessStartedEventImpl newEvent = new ActivitiProcessStartedEventImpl(entity, variables, localScope);

      // In case an execution-context is active, populate the event fields related to the execution
      populateEventWithCurrentContext(newEvent);
      return newEvent;
  }

  /**
   * @param type
   *          type of event
   * @param entity
   *          the entity this event targets
   * @param variables
   *          the variables associated with this entity
   * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related event fields will be populated. If not, execution details will be retrieved from the
   *         {@link Object} if possible.
   */
  @SuppressWarnings("rawtypes")
  public static ActivitiEntityWithVariablesEvent createEntityWithVariablesEvent(ActivitiEventType type, Object entity, Map variables, boolean localScope) {
    ActivitiEntityWithVariablesEventImpl newEvent = new ActivitiEntityWithVariablesEventImpl(entity, variables, localScope, type);

    // In case an execution-context is active, populate the event fields
    // related to the execution
    populateEventWithCurrentContext(newEvent);
    return newEvent;
  }

  public static ActivitiSequenceFlowTakenEvent createSequenceFlowTakenEvent(ExecutionEntity executionEntity, ActivitiEventType type,
      String sequenceFlowId, String sourceActivityId, String sourceActivityName, String sourceActivityType, Object sourceActivityBehavior,
      String targetActivityId, String targetActivityName, String targetActivityType, Object targetActivityBehavior) {

    ActivitiSequenceFlowTakenEventImpl newEvent = new ActivitiSequenceFlowTakenEventImpl(type);

    if (executionEntity != null) {
      newEvent.setExecutionId(executionEntity.getId());
      newEvent.setProcessInstanceId(executionEntity.getProcessInstanceId());
      newEvent.setProcessDefinitionId(executionEntity.getProcessDefinitionId());
    }

    newEvent.setId(sequenceFlowId);
    newEvent.setSourceActivityId(sourceActivityId);
    newEvent.setSourceActivityName(sourceActivityName);
    newEvent.setSourceActivityType(sourceActivityType);
    newEvent.setSourceActivityBehaviorClass(sourceActivityBehavior != null ? sourceActivityBehavior.getClass().getCanonicalName() : null);
    newEvent.setTargetActivityId(targetActivityId);
    newEvent.setTargetActivityName(targetActivityName);
    newEvent.setTargetActivityType(targetActivityType);
    newEvent.setTargetActivityBehaviorClass(targetActivityBehavior != null ? targetActivityBehavior.getClass().getCanonicalName() :  null);

    return newEvent;
  }

  /**
   * @param type
   *          type of event
   * @param entity
   *          the entity this event targets
   * @return an {@link ActivitiEntityEvent}
   */
  public static ActivitiEntityEvent createEntityEvent(ActivitiEventType type, Object entity, String executionId, String processInstanceId, String processDefinitionId) {
    ActivitiEntityEventImpl newEvent = new ActivitiEntityEventImpl(entity, type);

    newEvent.setExecutionId(executionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    return newEvent;
  }

  /**
   * @param type
   *          type of event
   * @param entity
   *          the entity this event targets
   * @param cause
   *          the cause of the event
   * @return an {@link ActivitiEntityEvent} that is also instance of {@link ActivitiExceptionEvent}. In case an {@link ExecutionContext} is active, the execution related event fields will be
   *         populated.
   */
  public static ActivitiEntityEvent createEntityExceptionEvent(ActivitiEventType type, Object entity, Throwable cause) {
    ActivitiEntityExceptionEventImpl newEvent = new ActivitiEntityExceptionEventImpl(entity, type, cause);

    // In case an execution-context is active, populate the event fields
    // related to the execution
    populateEventWithCurrentContext(newEvent);
    return newEvent;
  }

  /**
   * @param type
   *          type of event
   * @param entity
   *          the entity this event targets
   * @param cause
   *          the cause of the event
   * @return an {@link ActivitiEntityEvent} that is also instance of {@link ActivitiExceptionEvent}.
   */
  public static ActivitiEntityEvent createEntityExceptionEvent(ActivitiEventType type, Object entity, Throwable cause, String executionId, String processInstanceId, String processDefinitionId) {
    ActivitiEntityExceptionEventImpl newEvent = new ActivitiEntityExceptionEventImpl(entity, type, cause);

    newEvent.setExecutionId(executionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    return newEvent;
  }

  public static ActivitiActivityEvent createActivityEvent(ActivitiEventType type, String activityId, String activityName, String executionId,
      String processInstanceId, String processDefinitionId, FlowElement flowElement) {

    ActivitiActivityEventImpl newEvent = new ActivitiActivityEventImpl(type);
    newEvent.setActivityId(activityId);
    newEvent.setActivityName(activityName);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);

    if (flowElement instanceof FlowNode) {
      FlowNode flowNode = (FlowNode) flowElement;
      newEvent.setActivityType(parseActivityType(flowNode));
      Object behaviour = flowNode.getBehavior();
      if (behaviour != null) {
        newEvent.setBehaviorClass(behaviour.getClass().getCanonicalName());
      }
    }

    return newEvent;
  }

  protected static String parseActivityType(FlowNode flowNode) {
    String elementType = flowNode.getClass().getSimpleName();
    elementType = elementType.substring(0, 1).toLowerCase() + elementType.substring(1);
    return elementType;
  }

  public static ActivitiActivityCancelledEvent createActivityCancelledEvent(String activityId, String activityName, String executionId, 
      String processInstanceId, String processDefinitionId, String activityType, Object cause) {

    ActivitiActivityCancelledEventImpl newEvent = new ActivitiActivityCancelledEventImpl();
    newEvent.setActivityId(activityId);
    newEvent.setActivityName(activityName);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setActivityType(activityType);
    newEvent.setCause(cause);
    return newEvent;
  }

  public static ActivitiCancelledEvent createCancelledEvent(String executionId, String processInstanceId, String processDefinitionId, Object cause) {
    ActivitiProcessCancelledEventImpl newEvent = new ActivitiProcessCancelledEventImpl();
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setCause(cause);
    return newEvent;
  }

  public static ActivitiSignalEvent createSignalEvent(ActivitiEventType type, String activityId, String signalName, Object signalData, String executionId, String processInstanceId,
      String processDefinitionId) {
    ActivitiSignalEventImpl newEvent = new ActivitiSignalEventImpl(type);
    newEvent.setActivityId(activityId);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setSignalName(signalName);
    newEvent.setSignalData(signalData);
    return newEvent;
  }

  public static ActivitiMessageEvent createMessageEvent(ActivitiEventType type, String activityId, String messageName, Object payload, String executionId, String processInstanceId,
      String processDefinitionId) {
    ActivitiMessageEventImpl newEvent = new ActivitiMessageEventImpl(type);
    newEvent.setActivityId(activityId);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setMessageName(messageName);
    newEvent.setMessageData(payload);
    return newEvent;
  }

  public static ActivitiErrorEvent createErrorEvent(ActivitiEventType type, String activityId, String errorId, String errorCode,
      String executionId, String processInstanceId, String processDefinitionId) {
    ActivitiErrorEventImpl newEvent = new ActivitiErrorEventImpl(type);
    newEvent.setActivityId(activityId);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setErrorId(errorId);
    newEvent.setErrorCode(errorCode);
    return newEvent;
  }

  public static ActivitiVariableEvent createVariableEvent(ActivitiEventType type, String variableName, Object variableValue, VariableType variableType, String taskId, String executionId,
      String processInstanceId, String processDefinitionId) {
    ActivitiVariableEventImpl newEvent = new ActivitiVariableEventImpl(type);
    newEvent.setVariableName(variableName);
    newEvent.setVariableValue(variableValue);
    newEvent.setVariableType(variableType);
    newEvent.setTaskId(taskId);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    return newEvent;
  }

  public static ActivitiMembershipEvent createMembershipEvent(ActivitiEventType type, String groupId, String userId) {
    ActivitiMembershipEventImpl newEvent = new ActivitiMembershipEventImpl(type);
    newEvent.setUserId(userId);
    newEvent.setGroupId(groupId);
    return newEvent;
  }

  protected static void populateEventWithCurrentContext(ActivitiEventImpl event) {
    if (event instanceof ActivitiEntityEvent) {
      Object persistedObject = ((ActivitiEntityEvent) event).getEntity();
      if (persistedObject instanceof Job) {
        event.setExecutionId(((Job) persistedObject).getExecutionId());
        event.setProcessInstanceId(((Job) persistedObject).getProcessInstanceId());
        event.setProcessDefinitionId(((Job) persistedObject).getProcessDefinitionId());
      } else if (persistedObject instanceof DelegateExecution) {
        event.setExecutionId(((DelegateExecution) persistedObject).getId());
        event.setProcessInstanceId(((DelegateExecution) persistedObject).getProcessInstanceId());
        event.setProcessDefinitionId(((DelegateExecution) persistedObject).getProcessDefinitionId());
      } else if (persistedObject instanceof IdentityLinkEntity) {
        IdentityLinkEntity idLink = (IdentityLinkEntity) persistedObject;
        if (idLink.getProcessDefinitionId() != null) {
          event.setProcessDefinitionId(idLink.getProcessDefId());
        } else if (idLink.getProcessInstance() != null) {
          event.setProcessDefinitionId(idLink.getProcessInstance().getProcessDefinitionId());
          event.setProcessInstanceId(idLink.getProcessInstanceId());
          event.setExecutionId(idLink.getProcessInstanceId());
        } else if (idLink.getTask() != null) {
          event.setProcessDefinitionId(idLink.getTask().getProcessDefinitionId());
          event.setProcessInstanceId(idLink.getTask().getProcessInstanceId());
          event.setExecutionId(idLink.getTask().getExecutionId());
        }
      } else if (persistedObject instanceof Task) {
        event.setProcessInstanceId(((Task) persistedObject).getProcessInstanceId());
        event.setExecutionId(((Task) persistedObject).getExecutionId());
        event.setProcessDefinitionId(((Task) persistedObject).getProcessDefinitionId());
      } else if (persistedObject instanceof ProcessDefinition) {
        event.setProcessDefinitionId(((ProcessDefinition) persistedObject).getId());
      }
    }
  }
}
!@#$%
20190526_171910,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.delegate.event.impl;

import java.util.Map;

import org.activiti.engine.delegate.DelegateExecution;
import org.activiti.engine.delegate.event.ActivitiActivityCancelledEvent;
import org.activiti.engine.delegate.event.ActivitiActivityEvent;
import org.activiti.engine.delegate.event.ActivitiCancelledEvent;
import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEntityWithVariablesEvent;
import org.activiti.engine.delegate.event.ActivitiErrorEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.delegate.event.ActivitiExceptionEvent;
import org.activiti.engine.delegate.event.ActivitiMembershipEvent;
import org.activiti.engine.delegate.event.ActivitiMessageEvent;
import org.activiti.engine.delegate.event.ActivitiProcessStartedEvent;
import org.activiti.engine.delegate.event.ActivitiSequenceFlowTakenEvent;
import org.activiti.engine.delegate.event.ActivitiSignalEvent;
import org.activiti.engine.delegate.event.ActivitiVariableEvent;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.context.ExecutionContext;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity;
import org.activiti.engine.impl.variable.VariableType;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.task.Task;

/**
 * Builder class used to create {@link ActivitiEvent} implementations.
 * 
 * @author Frederik Heremans
 */
public class ActivitiEventBuilder {

	/**
	 * @param type type of event
	 * @return an {@link ActivitiEvent} that doesn't have it's execution context-fields filled,
	 * as the event is a global event, independant of any running execution.
	 */
	public static ActivitiEvent createGlobalEvent(ActivitiEventType type) {
		ActivitiEventImpl newEvent = new ActivitiEventImpl(type);
		return newEvent;
	}
	
	public static ActivitiEvent createEvent(ActivitiEventType type, String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiEventImpl newEvent = new ActivitiEventImpl(type);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
	 * event fields will be populated. If not, execution details will be reteived from the {@link Object} if possible.
	 */
	public static ActivitiEntityEvent createEntityEvent(ActivitiEventType type, Object entity) {
		ActivitiEntityEventImpl newEvent = new ActivitiEntityEventImpl(entity, type);

		// In case an execution-context is active, populate the event fields related to the execution
		populateEventWithCurrentContext(newEvent);
		return newEvent;
	}

    /**
     * @param entity
     *            the entity this event targets
     * @param variables
     *            the variables associated with this entity
     * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
     *         event fields will be populated. If not, execution details will be reteived from the {@link Object} if
     *         possible.
     */
    @SuppressWarnings("rawtypes")
    public static ActivitiProcessStartedEvent createProcessStartedEvent(final Object entity,
            final Map variables, final boolean localScope) {
        final ActivitiProcessStartedEventImpl newEvent = new ActivitiProcessStartedEventImpl(entity, variables, localScope);

        // In case an execution-context is active, populate the event fields related to the execution
        populateEventWithCurrentContext(newEvent);
        return newEvent;
    }
	
	/**
   * @param type type of event
   * @param entity the entity this event targets
   * @param variables the variables associated with this entity
   * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
   * event fields will be populated. If not, execution details will be reteived from the {@link Object} if possible.
   */
  @SuppressWarnings("rawtypes")
  public static ActivitiEntityWithVariablesEvent createEntityWithVariablesEvent(ActivitiEventType type, Object entity, Map variables, boolean localScope) {
    ActivitiEntityWithVariablesEventImpl newEvent = new ActivitiEntityWithVariablesEventImpl(entity, variables, localScope, type);

    // In case an execution-context is active, populate the event fields related to the execution
    populateEventWithCurrentContext(newEvent);
    return newEvent;
  }
	
	public static ActivitiSequenceFlowTakenEvent createSequenceFlowTakenEvent(ActivitiEventType type, String sequenceFlowId, 
			String sourceActivityId, String sourceActivityName, String sourceActivityType, String sourceActivityBehaviorClass,
			String targetActivityId, String targetActivityName, String targetActivityType, String targetActivityBehaviorClass) {
		ActivitiSequenceFlowTakenEventImpl newEvent = new ActivitiSequenceFlowTakenEventImpl(type);
		
		populateEventWithCurrentContext(newEvent);
		
		newEvent.setId(sequenceFlowId);
		newEvent.setSourceActivityId(sourceActivityId);
		newEvent.setSourceActivityName(sourceActivityName);
		newEvent.setSourceActivityType(sourceActivityType);
		newEvent.setSourceActivityBehaviorClass(sourceActivityBehaviorClass);
		newEvent.setTargetActivityId(targetActivityId);
		newEvent.setTargetActivityName(targetActivityName);
		newEvent.setTargetActivityType(targetActivityType);
		newEvent.setTargetActivityBehaviorClass(targetActivityBehaviorClass);
		
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @return an {@link ActivitiEntityEvent}
	 */
	public static ActivitiEntityEvent createEntityEvent(ActivitiEventType type, Object entity, String executionId,
			String processInstanceId, String processDefinitionId) {
		ActivitiEntityEventImpl newEvent = new ActivitiEntityEventImpl(entity, type);

		newEvent.setExecutionId(executionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @param cause the cause of the event
	 * @return an {@link ActivitiEntityEvent} that is also instance of {@link ActivitiExceptionEvent}. 
	 * In case an {@link ExecutionContext} is active, the execution related event fields will be populated.
	 */
	public static ActivitiEntityEvent createEntityExceptionEvent(ActivitiEventType type, Object entity, Throwable cause) {
		ActivitiEntityExceptionEventImpl newEvent = new ActivitiEntityExceptionEventImpl(entity, type, cause);

		// In case an execution-context is active, populate the event fields related to the execution
		populateEventWithCurrentContext(newEvent);
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @param cause the cause of the event
	 * @return an {@link ActivitiEntityEvent} that is also instance of {@link ActivitiExceptionEvent}. 
	 */
	public static ActivitiEntityEvent createEntityExceptionEvent(ActivitiEventType type, Object entity, Throwable cause, String executionId,
			String processInstanceId, String processDefinitionId) {
		ActivitiEntityExceptionEventImpl newEvent = new ActivitiEntityExceptionEventImpl(entity, type, cause);

		newEvent.setExecutionId(executionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		return newEvent;
	}
	
	public static ActivitiActivityEvent createActivityEvent(ActivitiEventType type, String activityId, String activityName,
			String executionId, String processInstanceId, String processDefinitionId, String activityType, String behaviourClass) {
		ActivitiActivityEventImpl newEvent = new ActivitiActivityEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setActivityName(activityName);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setActivityType(activityType);
		newEvent.setBehaviorClass(behaviourClass);
		return newEvent;
	}

  public static ActivitiActivityCancelledEvent createActivityCancelledEvent(String activityId, String activityName,
                                                          String executionId, String processInstanceId, String processDefinitionId, String activityType, String behaviourClass, Object cause) {
    ActivitiActivityCancelledEventImpl newEvent = new ActivitiActivityCancelledEventImpl();
    newEvent.setActivityId(activityId);
    newEvent.setActivityName(activityName);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setActivityType(activityType);
    newEvent.setBehaviorClass(behaviourClass);
    newEvent.setCause(cause);
    return newEvent;
  }

	public static ActivitiCancelledEvent createCancelledEvent(String executionId, String processInstanceId,
	                                                          String processDefinitionId, Object cause) {
		ActivitiProcessCancelledEventImpl newEvent = new ActivitiProcessCancelledEventImpl();
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setCause(cause);
		return newEvent;
	}

	public static ActivitiSignalEvent createSignalEvent(ActivitiEventType type, String activityId, String signalName, Object signalData,
			String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiSignalEventImpl newEvent = new ActivitiSignalEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setSignalName(signalName);
		newEvent.setSignalData(signalData);
		return newEvent;
	}
	
	public static ActivitiMessageEvent createMessageEvent(ActivitiEventType type, String activityId, String messageName, Object payload, 
			String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiMessageEventImpl newEvent = new ActivitiMessageEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setMessageName(messageName);
		newEvent.setMessageData(payload);
		return newEvent;
	}
	
	public static ActivitiErrorEvent createErrorEvent(ActivitiEventType type, String activityId, String errorCode, String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiErrorEventImpl newEvent = new ActivitiErrorEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setErrorCode(errorCode);
		return newEvent;
	}
	
	public static ActivitiVariableEvent createVariableEvent(ActivitiEventType type, String variableName, Object variableValue, VariableType variableType, String taskId, 
			String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiVariableEventImpl newEvent = new ActivitiVariableEventImpl(type);
		newEvent.setVariableName(variableName);
		newEvent.setVariableValue(variableValue);
		newEvent.setVariableType(variableType);
		newEvent.setTaskId(taskId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		return newEvent;
	}
	
	public static ActivitiMembershipEvent createMembershipEvent(ActivitiEventType type, String groupId, String userId) {
		ActivitiMembershipEventImpl newEvent = new ActivitiMembershipEventImpl(type);
		newEvent.setUserId(userId);
		newEvent.setGroupId(groupId);
		return newEvent;
	}
	
	protected static void populateEventWithCurrentContext(ActivitiEventImpl event) {
		boolean extractedFromContext = false;
		if(Context.isExecutionContextActive()) {
			ExecutionContext executionContext = Context.getExecutionContext();
			if(executionContext != null) {
				extractedFromContext = true;
				event.setExecutionId(executionContext.getExecution().getId());
				event.setProcessInstanceId(executionContext.getExecution().getProcessInstanceId());
				event.setProcessDefinitionId(executionContext.getExecution().getProcessDefinitionId());
			}
		} 
		
		// Fallback to fetching context from the object itself
		if(!extractedFromContext){
			if(event instanceof ActivitiEntityEvent) {
				Object persistendObject = ((ActivitiEntityEvent) event).getEntity();
				if(persistendObject instanceof Job) {
					event.setExecutionId(((Job) persistendObject).getExecutionId());
					event.setProcessInstanceId(((Job) persistendObject).getProcessInstanceId());
					event.setProcessDefinitionId(((Job) persistendObject).getProcessDefinitionId());
				} else if(persistendObject instanceof DelegateExecution) {
					event.setExecutionId(((DelegateExecution) persistendObject).getId());
					event.setProcessInstanceId(((DelegateExecution) persistendObject).getProcessInstanceId());
					event.setProcessDefinitionId(((DelegateExecution) persistendObject).getProcessDefinitionId());
				} else if(persistendObject instanceof IdentityLinkEntity) {
					IdentityLinkEntity idLink = (IdentityLinkEntity) persistendObject;
					if(idLink.getProcessDefinitionId() != null) {
						event.setProcessDefinitionId(idLink.getProcessDefId());
					} else if(idLink.getProcessInstance() != null) {
						event.setProcessDefinitionId(idLink.getProcessInstance().getProcessDefinitionId());
						event.setProcessInstanceId(idLink.getProcessInstanceId());
						event.setExecutionId(idLink.getProcessInstanceId());
					} else if(idLink.getTask() != null) {
						event.setProcessDefinitionId(idLink.getTask().getProcessDefinitionId());
						event.setProcessInstanceId(idLink.getTask().getProcessInstanceId());
						event.setExecutionId(idLink.getTask().getExecutionId());
					}
				} else if(persistendObject instanceof Task) {
					event.setProcessInstanceId(((Task)persistendObject).getProcessInstanceId());
					event.setExecutionId(((Task)persistendObject).getExecutionId());
					event.setProcessDefinitionId(((Task)persistendObject).getProcessDefinitionId());
				} else if(persistendObject instanceof ProcessDefinition) {
					event.setProcessDefinitionId(((ProcessDefinition) persistendObject).getId());
				}
			}
		}
	}
}
!@#$%
20190526_171910,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.delegate.event.impl;

import java.util.Map;

import org.activiti.engine.delegate.DelegateExecution;
import org.activiti.engine.delegate.event.ActivitiActivityCancelledEvent;
import org.activiti.engine.delegate.event.ActivitiActivityEvent;
import org.activiti.engine.delegate.event.ActivitiCancelledEvent;
import org.activiti.engine.delegate.event.ActivitiEntityEvent;
import org.activiti.engine.delegate.event.ActivitiEntityWithVariablesEvent;
import org.activiti.engine.delegate.event.ActivitiErrorEvent;
import org.activiti.engine.delegate.event.ActivitiEvent;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.delegate.event.ActivitiExceptionEvent;
import org.activiti.engine.delegate.event.ActivitiMembershipEvent;
import org.activiti.engine.delegate.event.ActivitiMessageEvent;
import org.activiti.engine.delegate.event.ActivitiProcessStartedEvent;
import org.activiti.engine.delegate.event.ActivitiSequenceFlowTakenEvent;
import org.activiti.engine.delegate.event.ActivitiSignalEvent;
import org.activiti.engine.delegate.event.ActivitiVariableEvent;
import org.activiti.engine.impl.context.Context;
import org.activiti.engine.impl.context.ExecutionContext;
import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity;
import org.activiti.engine.impl.variable.VariableType;
import org.activiti.engine.repository.ProcessDefinition;
import org.activiti.engine.runtime.Job;
import org.activiti.engine.task.Task;

/**
 * Builder class used to create {@link ActivitiEvent} implementations.
 * 
 * @author Frederik Heremans
 */
public class ActivitiEventBuilder {

	/**
	 * @param type type of event
	 * @return an {@link ActivitiEvent} that doesn't have it's execution context-fields filled,
	 * as the event is a global event, independant of any running execution.
	 */
	public static ActivitiEvent createGlobalEvent(ActivitiEventType type) {
		ActivitiEventImpl newEvent = new ActivitiEventImpl(type);
		return newEvent;
	}
	
	public static ActivitiEvent createEvent(ActivitiEventType type, String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiEventImpl newEvent = new ActivitiEventImpl(type);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
	 * event fields will be populated. If not, execution details will be reteived from the {@link Object} if possible.
	 */
	public static ActivitiEntityEvent createEntityEvent(ActivitiEventType type, Object entity) {
		ActivitiEntityEventImpl newEvent = new ActivitiEntityEventImpl(entity, type);

		// In case an execution-context is active, populate the event fields related to the execution
		populateEventWithCurrentContext(newEvent);
		return newEvent;
	}

  /**
   * @param entity
   *            the entity this event targets
   * @param variables
   *            the variables associated with this entity
   * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
   *         event fields will be populated. If not, execution details will be reteived from the {@link Object} if
   *         possible.
   */
  @SuppressWarnings("rawtypes")
  public static ActivitiProcessStartedEvent createProcessStartedEvent(final Object entity, final Map variables, final boolean localScope) {
    final ActivitiProcessStartedEventImpl newEvent = new ActivitiProcessStartedEventImpl(entity, variables, localScope);

    // In case an execution-context is active, populate the event fields related to the execution
    populateEventWithCurrentContext(newEvent);
    return newEvent;
  }
	
	/**
   * @param type type of event
   * @param entity the entity this event targets
   * @param variables the variables associated with this entity
   * @return an {@link ActivitiEntityEvent}. In case an {@link ExecutionContext} is active, the execution related
   * event fields will be populated. If not, execution details will be reteived from the {@link Object} if possible.
   */
  @SuppressWarnings("rawtypes")
  public static ActivitiEntityWithVariablesEvent createEntityWithVariablesEvent(ActivitiEventType type, Object entity, Map variables, boolean localScope) {
    ActivitiEntityWithVariablesEventImpl newEvent = new ActivitiEntityWithVariablesEventImpl(entity, variables, localScope, type);

    // In case an execution-context is active, populate the event fields related to the execution
    populateEventWithCurrentContext(newEvent);
    return newEvent;
  }
	
	public static ActivitiSequenceFlowTakenEvent createSequenceFlowTakenEvent(ActivitiEventType type, String sequenceFlowId, 
			String sourceActivityId, String sourceActivityName, String sourceActivityType, String sourceActivityBehaviorClass,
			String targetActivityId, String targetActivityName, String targetActivityType, String targetActivityBehaviorClass) {
		ActivitiSequenceFlowTakenEventImpl newEvent = new ActivitiSequenceFlowTakenEventImpl(type);
		
		populateEventWithCurrentContext(newEvent);
		
		newEvent.setId(sequenceFlowId);
		newEvent.setSourceActivityId(sourceActivityId);
		newEvent.setSourceActivityName(sourceActivityName);
		newEvent.setSourceActivityType(sourceActivityType);
		newEvent.setSourceActivityBehaviorClass(sourceActivityBehaviorClass);
		newEvent.setTargetActivityId(targetActivityId);
		newEvent.setTargetActivityName(targetActivityName);
		newEvent.setTargetActivityType(targetActivityType);
		newEvent.setTargetActivityBehaviorClass(targetActivityBehaviorClass);
		
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @return an {@link ActivitiEntityEvent}
	 */
	public static ActivitiEntityEvent createEntityEvent(ActivitiEventType type, Object entity, String executionId,
			String processInstanceId, String processDefinitionId) {
		ActivitiEntityEventImpl newEvent = new ActivitiEntityEventImpl(entity, type);

		newEvent.setExecutionId(executionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @param cause the cause of the event
	 * @return an {@link ActivitiEntityEvent} that is also instance of {@link ActivitiExceptionEvent}. 
	 * In case an {@link ExecutionContext} is active, the execution related event fields will be populated.
	 */
	public static ActivitiEntityEvent createEntityExceptionEvent(ActivitiEventType type, Object entity, Throwable cause) {
		ActivitiEntityExceptionEventImpl newEvent = new ActivitiEntityExceptionEventImpl(entity, type, cause);

		// In case an execution-context is active, populate the event fields related to the execution
		populateEventWithCurrentContext(newEvent);
		return newEvent;
	}
	
	/**
	 * @param type type of event
	 * @param entity the entity this event targets
	 * @param cause the cause of the event
	 * @return an {@link ActivitiEntityEvent} that is also instance of {@link ActivitiExceptionEvent}. 
	 */
	public static ActivitiEntityEvent createEntityExceptionEvent(ActivitiEventType type, Object entity, Throwable cause, String executionId,
			String processInstanceId, String processDefinitionId) {
		ActivitiEntityExceptionEventImpl newEvent = new ActivitiEntityExceptionEventImpl(entity, type, cause);

		newEvent.setExecutionId(executionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		return newEvent;
	}
	
	public static ActivitiActivityEvent createActivityEvent(ActivitiEventType type, String activityId, String activityName,
			String executionId, String processInstanceId, String processDefinitionId, String activityType, String behaviourClass) {
		ActivitiActivityEventImpl newEvent = new ActivitiActivityEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setActivityName(activityName);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setActivityType(activityType);
		newEvent.setBehaviorClass(behaviourClass);
		return newEvent;
	}

  public static ActivitiActivityCancelledEvent createActivityCancelledEvent(String activityId, String activityName,
                                                          String executionId, String processInstanceId, String processDefinitionId, String activityType, String behaviourClass, Object cause) {
    ActivitiActivityCancelledEventImpl newEvent = new ActivitiActivityCancelledEventImpl();
    newEvent.setActivityId(activityId);
    newEvent.setActivityName(activityName);
    newEvent.setExecutionId(executionId);
    newEvent.setProcessDefinitionId(processDefinitionId);
    newEvent.setProcessInstanceId(processInstanceId);
    newEvent.setActivityType(activityType);
    newEvent.setBehaviorClass(behaviourClass);
    newEvent.setCause(cause);
    return newEvent;
  }

	public static ActivitiCancelledEvent createCancelledEvent(String executionId, String processInstanceId,
	                                                          String processDefinitionId, Object cause) {
		ActivitiProcessCancelledEventImpl newEvent = new ActivitiProcessCancelledEventImpl();
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setCause(cause);
		return newEvent;
	}

	public static ActivitiSignalEvent createSignalEvent(ActivitiEventType type, String activityId, String signalName, Object signalData,
			String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiSignalEventImpl newEvent = new ActivitiSignalEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setSignalName(signalName);
		newEvent.setSignalData(signalData);
		return newEvent;
	}
	
	public static ActivitiMessageEvent createMessageEvent(ActivitiEventType type, String activityId, String messageName, Object payload, 
			String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiMessageEventImpl newEvent = new ActivitiMessageEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setMessageName(messageName);
		newEvent.setMessageData(payload);
		return newEvent;
	}
	
	public static ActivitiErrorEvent createErrorEvent(ActivitiEventType type, String activityId, String errorCode, String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiErrorEventImpl newEvent = new ActivitiErrorEventImpl(type);
		newEvent.setActivityId(activityId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		newEvent.setErrorCode(errorCode);
		return newEvent;
	}
	
	public static ActivitiVariableEvent createVariableEvent(ActivitiEventType type, String variableName, Object variableValue, VariableType variableType, String taskId, 
			String executionId, String processInstanceId, String processDefinitionId) {
		ActivitiVariableEventImpl newEvent = new ActivitiVariableEventImpl(type);
		newEvent.setVariableName(variableName);
		newEvent.setVariableValue(variableValue);
		newEvent.setVariableType(variableType);
		newEvent.setTaskId(taskId);
		newEvent.setExecutionId(executionId);
		newEvent.setProcessDefinitionId(processDefinitionId);
		newEvent.setProcessInstanceId(processInstanceId);
		return newEvent;
	}
	
	public static ActivitiMembershipEvent createMembershipEvent(ActivitiEventType type, String groupId, String userId) {
		ActivitiMembershipEventImpl newEvent = new ActivitiMembershipEventImpl(type);
		newEvent.setUserId(userId);
		newEvent.setGroupId(groupId);
		return newEvent;
	}
	
	protected static void populateEventWithCurrentContext(ActivitiEventImpl event) {
		boolean extractedFromContext = false;
		if(Context.isExecutionContextActive()) {
			ExecutionContext executionContext = Context.getExecutionContext();
			if(executionContext != null) {
				extractedFromContext = true;
				event.setExecutionId(executionContext.getExecution().getId());
				event.setProcessInstanceId(executionContext.getExecution().getProcessInstanceId());
				event.setProcessDefinitionId(executionContext.getExecution().getProcessDefinitionId());
			}
		} 
		
		// Fallback to fetching context from the object itself
		if(!extractedFromContext){
			if(event instanceof ActivitiEntityEvent) {
				Object persistendObject = ((ActivitiEntityEvent) event).getEntity();
				if(persistendObject instanceof Job) {
					event.setExecutionId(((Job) persistendObject).getExecutionId());
					event.setProcessInstanceId(((Job) persistendObject).getProcessInstanceId());
					event.setProcessDefinitionId(((Job) persistendObject).getProcessDefinitionId());
				} else if(persistendObject instanceof DelegateExecution) {
					event.setExecutionId(((DelegateExecution) persistendObject).getId());
					event.setProcessInstanceId(((DelegateExecution) persistendObject).getProcessInstanceId());
					event.setProcessDefinitionId(((DelegateExecution) persistendObject).getProcessDefinitionId());
				} else if(persistendObject instanceof IdentityLinkEntity) {
					IdentityLinkEntity idLink = (IdentityLinkEntity) persistendObject;
					if(idLink.getProcessDefinitionId() != null) {
						event.setProcessDefinitionId(idLink.getProcessDefId());
					} else if(idLink.getProcessInstance() != null) {
						event.setProcessDefinitionId(idLink.getProcessInstance().getProcessDefinitionId());
						event.setProcessInstanceId(idLink.getProcessInstanceId());
						event.setExecutionId(idLink.getProcessInstanceId());
					} else if(idLink.getTask() != null) {
						event.setProcessDefinitionId(idLink.getTask().getProcessDefinitionId());
						event.setProcessInstanceId(idLink.getTask().getProcessInstanceId());
						event.setExecutionId(idLink.getTask().getExecutionId());
					}
				} else if(persistendObject instanceof Task) {
					event.setProcessInstanceId(((Task)persistendObject).getProcessInstanceId());
					event.setExecutionId(((Task)persistendObject).getExecutionId());
					event.setProcessDefinitionId(((Task)persistendObject).getProcessDefinitionId());
				} else if(persistendObject instanceof ProcessDefinition) {
					event.setProcessDefinitionId(((ProcessDefinition) persistendObject).getId());
				}
			}
		}
	}
}
!@#$%
20190526_171922,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.cfg;

import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;

/**
 * @author jbarrez
 */
public abstract class AbstractProcessEngineConfigurator implements ProcessEngineConfigurator {

  public static int DEFAULT_CONFIGURATOR_PRIORITY = 10000;

  @Override
  public int getPriority() {
    return DEFAULT_CONFIGURATOR_PRIORITY;
  }
  
  public void beforeInit(ProcessEngineConfigurationImpl processEngineConfiguration) {
    
  }
  
  public void configure(ProcessEngineConfigurationImpl processEngineConfiguration) {
    
  }

}
!@#$%
20190526_171922,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.engine.cfg;

/**
 * @author jbarrez
 */
public abstract class AbstractProcessEngineConfigurator implements ProcessEngineConfigurator {
	
	public static int DEFAULT_CONFIGURATOR_PRIORITY = 10000;
	
	@Override
	public int getPriority() {
		return DEFAULT_CONFIGURATOR_PRIORITY;
	}

}
!@#$%
20190526_171922,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.cfg;

import org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl;

/**
 * @author jbarrez
 */
public abstract class AbstractProcessEngineConfigurator implements ProcessEngineConfigurator {
	
	public static int DEFAULT_CONFIGURATOR_PRIORITY = 10000;
	
	@Override
	public int getPriority() {
		return DEFAULT_CONFIGURATOR_PRIORITY;
	}
	
	public void beforeInit(ProcessEngineConfigurationImpl processEngineConfiguration) {
    
  }
	
	public void configure(ProcessEngineConfigurationImpl processEngineConfiguration) {
	  
	}

}
!@#$%
20190526_171944,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.camel;

import java.util.List;

import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.test.Deployment;
import org.activiti.spring.impl.test.SpringActivitiTestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.junit.BeforeClass;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;

@ContextConfiguration("classpath:generic-camel-activiti-context.xml")
public class EmptyProcessTest extends SpringActivitiTestCase {

  @Autowired
  protected CamelContext camelContext;

  @BeforeClass
  public void setUp() throws Exception {
    camelContext.addRoutes(new RouteBuilder() {

      @Override
      public void configure() throws Exception {
        from("direct:startEmpty").to("activiti:emptyProcess");
        from("direct:startEmptyWithHeader").setHeader("MyVar", constant("Foo")).to("activiti:emptyProcess?copyVariablesFromHeader=true");
        from("direct:startEmptyBodyAsString").to("activiti:emptyProcess?copyBodyToCamelBodyAsString=true");
      }
    });
  }

  public void tearDown() throws Exception {
    List<Route> routes = camelContext.getRoutes();
    for (Route r : routes) {
      camelContext.stopRoute(r.getId());
      camelContext.removeRoute(r.getId());
    }
  }

  @Deployment(resources = { "process/empty.bpmn20.xml" })
  public void testRunProcessWithHeader() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = camelContext.createProducerTemplate();
    String body = "body text";
    Exchange exchange = ctx.getEndpoint("direct:startEmptyWithHeader").createExchange();
    exchange.getIn().setBody(body);
    tpl.send("direct:startEmptyWithHeader", exchange);

    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");
    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(body, var.getValue());
    var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("MyVar").singleResult();
    assertNotNull(var);
    assertEquals("Foo", var.getValue());
  }

  @Deployment(resources = { "process/empty.bpmn20.xml" })
  public void testObjectAsVariable() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = ctx.createProducerTemplate();
    Object expectedObj = new Long(99);
    Exchange exchange = ctx.getEndpoint("direct:startEmpty").createExchange();
    exchange.getIn().setBody(expectedObj);
    tpl.send("direct:startEmpty", exchange);
    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");
    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(expectedObj, var.getValue());
  }

  @Deployment(resources = { "process/empty.bpmn20.xml" })
  public void testObjectAsStringVariable() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = ctx.createProducerTemplate();
    Object expectedObj = new Long(99);

    Exchange exchange = ctx.getEndpoint("direct:startEmptyBodyAsString").createExchange();
    exchange.getIn().setBody(expectedObj);
    tpl.send("direct:startEmptyBodyAsString", exchange);

    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");

    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(expectedObj.toString(), var.getValue().toString());
  }
}
!@#$%
20190526_171944,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.camel;

import java.util.List;

import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.test.Deployment;
import org.activiti.spring.impl.test.SpringActivitiTestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.junit.BeforeClass;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;

@ContextConfiguration("classpath:generic-camel-activiti-context.xml")
public class EmptyProcessTest extends SpringActivitiTestCase {

  @Autowired
  protected CamelContext camelContext;
  	
  @BeforeClass
  public void setUp() throws Exception {
	  camelContext.addRoutes(new RouteBuilder() {

	    @Override
	    public void configure() throws Exception {
	      from("direct:startEmpty").to("activiti:emptyProcess");
	      from("direct:startEmptyWithHeader").setHeader("MyVar", constant("Foo")).to("activiti:emptyProcess?copyVariablesFromHeader=true");
	      from("direct:startEmptyBodyAsString").to("activiti:emptyProcess?copyBodyToCamelBodyAsString=true");
	    }
	  });
  }
  
  public void tearDown() throws Exception {
    List<Route> routes = camelContext.getRoutes();
    for (Route r: routes) {
      camelContext.stopRoute(r.getId());
      camelContext.removeRoute(r.getId());
    }
  }
  
  @Deployment(resources = {"process/empty.bpmn20.xml"})
  public void testRunProcessWithHeader() throws Exception {
    ProducerTemplate tpl = camelContext.createProducerTemplate();
    String body = "body text";
    String instanceId = (String) tpl.requestBody("direct:startEmptyWithHeader", body);
    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(body, var.getValue());
    var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("MyVar").singleResult();
    assertNotNull(var);
    assertEquals("Foo", var.getValue());
  }
  
  @Deployment(resources = {"process/empty.bpmn20.xml"})
  public void testObjectAsVariable() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = ctx.createProducerTemplate();
    Object expectedObj = new Long(99);
    Exchange exchange = ctx.getEndpoint("direct:startEmpty").createExchange();
    exchange.getIn().setBody(expectedObj);
    tpl.send("direct:startEmpty", exchange);    
    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");
    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(expectedObj, var.getValue());
  }
  
  @Deployment(resources = {"process/empty.bpmn20.xml"})
  public void testObjectAsStringVariable() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = ctx.createProducerTemplate();
    Object expectedObj = new Long(99);
    
    Exchange exchange = ctx.getEndpoint("direct:startEmptyBodyAsString").createExchange();
    exchange.getIn().setBody(expectedObj);
    tpl.send("direct:startEmptyBodyAsString", exchange);
    
    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");

    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(expectedObj.toString(), var.getValue().toString());
  }
}
!@#$%
20190526_171944,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.activiti.camel;

import java.util.List;

import org.activiti.engine.history.HistoricVariableInstance;
import org.activiti.engine.test.Deployment;
import org.activiti.spring.impl.test.SpringActivitiTestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.Route;
import org.apache.camel.builder.RouteBuilder;
import org.junit.BeforeClass;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;

@ContextConfiguration("classpath:generic-camel-activiti-context.xml")
public class EmptyProcessTest extends SpringActivitiTestCase {

  @Autowired
  protected CamelContext camelContext;
  	
  @BeforeClass
  public void setUp() throws Exception {
	  camelContext.addRoutes(new RouteBuilder() {

	    @Override
	    public void configure() throws Exception {
	      from("direct:startEmpty").to("activiti:emptyProcess");
	      from("direct:startEmptyWithHeader").setHeader("MyVar", constant("Foo")).to("activiti:emptyProcess?copyVariablesFromHeader=true");
	      from("direct:startEmptyBodyAsString").to("activiti:emptyProcess?copyBodyToCamelBodyAsString=true");
	    }
	  });
  }
  
  public void tearDown() throws Exception {
    List<Route> routes = camelContext.getRoutes();
    for (Route r: routes) {
      camelContext.stopRoute(r.getId());
      camelContext.removeRoute(r.getId());
    }
  }
  
  @Deployment(resources = {"process/empty.bpmn20.xml"})
  public void testRunProcessWithHeader() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = camelContext.createProducerTemplate();
    String body = "body text";
    Exchange exchange = ctx.getEndpoint("direct:startEmptyWithHeader").createExchange();
    exchange.getIn().setBody(body);
    tpl.send("direct:startEmptyWithHeader", exchange);

    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");
    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(body, var.getValue());
    var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("MyVar").singleResult();
    assertNotNull(var);
    assertEquals("Foo", var.getValue());
  }
  
  @Deployment(resources = {"process/empty.bpmn20.xml"})
  public void testObjectAsVariable() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = ctx.createProducerTemplate();
    Object expectedObj = new Long(99);
    Exchange exchange = ctx.getEndpoint("direct:startEmpty").createExchange();
    exchange.getIn().setBody(expectedObj);
    tpl.send("direct:startEmpty", exchange);    
    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");
    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(expectedObj, var.getValue());
  }
  
  @Deployment(resources = {"process/empty.bpmn20.xml"})
  public void testObjectAsStringVariable() throws Exception {
    CamelContext ctx = applicationContext.getBean(CamelContext.class);
    ProducerTemplate tpl = ctx.createProducerTemplate();
    Object expectedObj = new Long(99);
    
    Exchange exchange = ctx.getEndpoint("direct:startEmptyBodyAsString").createExchange();
    exchange.getIn().setBody(expectedObj);
    tpl.send("direct:startEmptyBodyAsString", exchange);
    
    String instanceId = (String) exchange.getProperty("PROCESS_ID_PROPERTY");

    assertProcessEnded(instanceId);
    HistoricVariableInstance var = processEngine.getHistoryService().createHistoricVariableInstanceQuery().variableName("camelBody").singleResult();
    assertNotNull(var);
    assertEquals(expectedObj.toString(), var.getValue().toString());
  }
}
!@#$%
20190526_171953,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author Tijs Rademakers
 */
public class UserTask extends Task {

  protected String assignee;
  protected String owner;
  protected String priority;
  protected String formKey;
  protected String dueDate;
  protected String businessCalendarName;
  protected String category;
  protected String extensionId;
  protected List<String> candidateUsers = new ArrayList<String>();
  protected List<String> candidateGroups = new ArrayList<String>();
  protected List<FormProperty> formProperties = new ArrayList<FormProperty>();
  protected List<ActivitiListener> taskListeners = new ArrayList<ActivitiListener>();
  protected String skipExpression;

  protected Map<String, Set<String>> customUserIdentityLinks = new HashMap<String, Set<String>>(); 
  protected Map<String, Set<String>> customGroupIdentityLinks = new HashMap<String, Set<String>>();
  
  protected List<CustomProperty> customProperties = new ArrayList<CustomProperty>();

  public String getAssignee() {
    return assignee;
  }

  public void setAssignee(String assignee) {
    this.assignee = assignee;
  }

  public String getOwner() {
    return owner;
  }

  public void setOwner(String owner) {
    this.owner = owner;
  }

  public String getPriority() {
    return priority;
  }

  public void setPriority(String priority) {
    this.priority = priority;
  }

  public String getFormKey() {
    return formKey;
  }

  public void setFormKey(String formKey) {
    this.formKey = formKey;
  }

  public String getDueDate() {
    return dueDate;
  }

  public void setDueDate(String dueDate) {
    this.dueDate = dueDate;
  }

  public String getBusinessCalendarName() {
    return businessCalendarName;
  }

  public void setBusinessCalendarName(String businessCalendarName) {
    this.businessCalendarName = businessCalendarName;
  }

  public String getCategory() {
    return category;
  }

  public void setCategory(String category) {
    this.category = category;
  }

  public String getExtensionId() {
    return extensionId;
  }

  public void setExtensionId(String extensionId) {
    this.extensionId = extensionId;
  }

  public boolean isExtended() {
    return extensionId != null && !extensionId.isEmpty();
  }
	public List<String> getCandidateUsers() {
    return candidateUsers;
  }

  public void setCandidateUsers(List<String> candidateUsers) {
    this.candidateUsers = candidateUsers;
  }

  public List<String> getCandidateGroups() {
    return candidateGroups;
  }

  public void setCandidateGroups(List<String> candidateGroups) {
    this.candidateGroups = candidateGroups;
  }

  public List<FormProperty> getFormProperties() {
    return formProperties;
  }

  public void setFormProperties(List<FormProperty> formProperties) {
    this.formProperties = formProperties;
  }

  public List<ActivitiListener> getTaskListeners() {
    return taskListeners;
  }

  public void setTaskListeners(List<ActivitiListener> taskListeners) {
    this.taskListeners = taskListeners;
  }

  public void addCustomUserIdentityLink(String userId, String type) {
    Set<String> userIdentitySet = customUserIdentityLinks.get(type);

    if (userIdentitySet == null) {
      userIdentitySet = new HashSet<String>();
      customUserIdentityLinks.put(type, userIdentitySet);
    }

    userIdentitySet.add(userId);
  }

  public void addCustomGroupIdentityLink(String groupId, String type) {
    Set<String> groupIdentitySet = customGroupIdentityLinks.get(type);

    if (groupIdentitySet == null) {
      groupIdentitySet = new HashSet<String>();
      customGroupIdentityLinks.put(type, groupIdentitySet);
    }

    groupIdentitySet.add(groupId);
  }

  public Map<String, Set<String>> getCustomUserIdentityLinks() {
    return customUserIdentityLinks;
  }

  public void setCustomUserIdentityLinks(Map<String, Set<String>> customUserIdentityLinks) {
    this.customUserIdentityLinks = customUserIdentityLinks;
  }

  public Map<String, Set<String>> getCustomGroupIdentityLinks() {
    return customGroupIdentityLinks;
  }

  public void setCustomGroupIdentityLinks(Map<String, Set<String>> customGroupIdentityLinks) {
    this.customGroupIdentityLinks = customGroupIdentityLinks;
  }
  
  public List<CustomProperty> getCustomProperties() {
    return customProperties;
  }
  public void setCustomProperties(List<CustomProperty> customProperties) {
    this.customProperties = customProperties;
  }
  
  public String getSkipExpression() {
    return skipExpression;
  }

  public void setSkipExpression(String skipExpression) {
    this.skipExpression = skipExpression;
  }

  public UserTask clone() {
    UserTask clone = new UserTask();
    clone.setValues(this);
    return clone;
  }

  public void setValues(UserTask otherElement) {
    super.setValues(otherElement);
    setAssignee(otherElement.getAssignee());
    setOwner(otherElement.getOwner());
    setFormKey(otherElement.getFormKey());
    setDueDate(otherElement.getDueDate());
    setPriority(otherElement.getPriority());
    setCategory(otherElement.getCategory());
    setExtensionId(otherElement.getExtensionId());
    setSkipExpression(otherElement.getSkipExpression());
    
    setCandidateGroups(new ArrayList<String>(otherElement.getCandidateGroups()));
    setCandidateUsers(new ArrayList<String>(otherElement.getCandidateUsers()));

    setCustomGroupIdentityLinks(otherElement.customGroupIdentityLinks);
    setCustomUserIdentityLinks(otherElement.customUserIdentityLinks);

    formProperties = new ArrayList<FormProperty>();
    if (otherElement.getFormProperties() != null && !otherElement.getFormProperties().isEmpty()) {
      for (FormProperty property : otherElement.getFormProperties()) {
        formProperties.add(property.clone());
      }
    }

    taskListeners = new ArrayList<ActivitiListener>();
    if (otherElement.getTaskListeners() != null && !otherElement.getTaskListeners().isEmpty()) {
      for (ActivitiListener listener : otherElement.getTaskListeners()) {
        taskListeners.add(listener.clone());
      }
    }
  }
}
!@#$%
20190526_171953,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author Tijs Rademakers
 */
public class UserTask extends Task {

  protected String assignee;
  protected String owner;
  protected String priority;
  protected String formKey;
  protected String dueDate;
  protected String category;
  protected String extensionId;
  protected List<String> candidateUsers = new ArrayList<String>();
  protected List<String> candidateGroups = new ArrayList<String>();
  protected List<FormProperty> formProperties = new ArrayList<FormProperty>();
  protected List<ActivitiListener> taskListeners = new ArrayList<ActivitiListener>();
  protected String skipExpression;

  protected Map<String, Set<String>> customUserIdentityLinks = new HashMap<String, Set<String>>(); 
  protected Map<String, Set<String>> customGroupIdentityLinks = new HashMap<String, Set<String>>();
  
  protected List<CustomProperty> customProperties = new ArrayList<CustomProperty>();

  public String getAssignee() {
    return assignee;
  }
  public void setAssignee(String assignee) {
    this.assignee = assignee;
  }
  public String getOwner() {
    return owner;
  }
  public void setOwner(String owner) {
    this.owner = owner;
  }
  public String getPriority() {
    return priority;
  }
  public void setPriority(String priority) {
    this.priority = priority;
  }
  public String getFormKey() {
    return formKey;
  }
  public void setFormKey(String formKey) {
    this.formKey = formKey;
  }
  public String getDueDate() {
    return dueDate;
  }
  public void setDueDate(String dueDate) {
    this.dueDate = dueDate;
  }
  public String getCategory() {
		return category;
	}
	public void setCategory(String category) {
		this.category = category;
	}
	public String getExtensionId() {
    return extensionId;
  }
  public void setExtensionId(String extensionId) {
    this.extensionId = extensionId;
  }
  public boolean isExtended() {
    return extensionId != null && !extensionId.isEmpty();
  }
	public List<String> getCandidateUsers() {
    return candidateUsers;
  }
  public void setCandidateUsers(List<String> candidateUsers) {
    this.candidateUsers = candidateUsers;
  }
  public List<String> getCandidateGroups() {
    return candidateGroups;
  }
  public void setCandidateGroups(List<String> candidateGroups) {
    this.candidateGroups = candidateGroups;
  }
  public List<FormProperty> getFormProperties() {
    return formProperties;
  }
  public void setFormProperties(List<FormProperty> formProperties) {
    this.formProperties = formProperties;
  }
  public List<ActivitiListener> getTaskListeners() {
    return taskListeners;
  }
  public void setTaskListeners(List<ActivitiListener> taskListeners) {
    this.taskListeners = taskListeners;
  }
  
  public void addCustomUserIdentityLink(String userId, String type){
	  Set<String> userIdentitySet = customUserIdentityLinks.get(type);
	  
	  if(userIdentitySet == null){
		  userIdentitySet = new HashSet<String>();
		  customUserIdentityLinks.put(type, userIdentitySet);
	  }
	  
	  userIdentitySet.add(userId);
  }
  
  public void addCustomGroupIdentityLink(String groupId, String type){
	  Set<String> groupIdentitySet = customGroupIdentityLinks.get(type);
	  
	  if(groupIdentitySet == null){
		  groupIdentitySet = new HashSet<String>();
		  customGroupIdentityLinks.put(type, groupIdentitySet);
	  }
	  
	  groupIdentitySet.add(groupId);
  }
  
  public Map<String, Set<String>> getCustomUserIdentityLinks() {
	return customUserIdentityLinks;
  }
  
  public void setCustomUserIdentityLinks(
		Map<String, Set<String>> customUserIdentityLinks) {
	this.customUserIdentityLinks = customUserIdentityLinks;
  }
  
  public Map<String, Set<String>> getCustomGroupIdentityLinks() {
	return customGroupIdentityLinks;
  }
  
  public void setCustomGroupIdentityLinks(Map<String, Set<String>> customGroupIdentityLinks) {
    this.customGroupIdentityLinks = customGroupIdentityLinks;
  }
  
  public List<CustomProperty> getCustomProperties() {
    return customProperties;
  }
  public void setCustomProperties(List<CustomProperty> customProperties) {
    this.customProperties = customProperties;
  }
  
  public String getSkipExpression() {
    return skipExpression;
  }
  
  public void setSkipExpression(String skipExpression) {
    this.skipExpression = skipExpression;
  }
  public UserTask clone() {
    UserTask clone = new UserTask();
    clone.setValues(this);
    return clone;
  }
  
  public void setValues(UserTask otherElement) {
    super.setValues(otherElement);
    setAssignee(otherElement.getAssignee());
    setOwner(otherElement.getOwner());
    setFormKey(otherElement.getFormKey());
    setDueDate(otherElement.getDueDate());
    setPriority(otherElement.getPriority());
    setCategory(otherElement.getCategory());
    setExtensionId(otherElement.getExtensionId());
    
    setCandidateGroups(new ArrayList<String>(otherElement.getCandidateGroups()));
    setCandidateUsers(new ArrayList<String>(otherElement.getCandidateUsers()));
    
    setCustomGroupIdentityLinks(otherElement.customGroupIdentityLinks);
    setCustomUserIdentityLinks(otherElement.customUserIdentityLinks);
    
    formProperties = new ArrayList<FormProperty>();
    if (otherElement.getFormProperties() != null && !otherElement.getFormProperties().isEmpty()) {
      for (FormProperty property : otherElement.getFormProperties()) {
        formProperties.add(property.clone());
      }
    }
    
    taskListeners = new ArrayList<ActivitiListener>();
    if (otherElement.getTaskListeners() != null && !otherElement.getTaskListeners().isEmpty()) {
      for (ActivitiListener listener : otherElement.getTaskListeners()) {
        taskListeners.add(listener.clone());
      }
    }
  }
}
!@#$%
20190526_171953,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author Tijs Rademakers
 */
public class UserTask extends Task {

  protected String assignee;
  protected String owner;
  protected String priority;
  protected String formKey;
  protected String dueDate;
  protected String businessCalendarName;
  protected String category;
  protected String extensionId;
  protected List<String> candidateUsers = new ArrayList<String>();
  protected List<String> candidateGroups = new ArrayList<String>();
  protected List<FormProperty> formProperties = new ArrayList<FormProperty>();
  protected List<ActivitiListener> taskListeners = new ArrayList<ActivitiListener>();
  protected String skipExpression;

  protected Map<String, Set<String>> customUserIdentityLinks = new HashMap<String, Set<String>>(); 
  protected Map<String, Set<String>> customGroupIdentityLinks = new HashMap<String, Set<String>>();
  
  protected List<CustomProperty> customProperties = new ArrayList<CustomProperty>();

  public String getAssignee() {
    return assignee;
  }
  public void setAssignee(String assignee) {
    this.assignee = assignee;
  }
  public String getOwner() {
    return owner;
  }
  public void setOwner(String owner) {
    this.owner = owner;
  }
  public String getPriority() {
    return priority;
  }
  public void setPriority(String priority) {
    this.priority = priority;
  }
  public String getFormKey() {
    return formKey;
  }
  public void setFormKey(String formKey) {
    this.formKey = formKey;
  }
  public String getDueDate() {
    return dueDate;
  }
  public void setDueDate(String dueDate) {
    this.dueDate = dueDate;
  }

  public String getBusinessCalendarName() {
    return businessCalendarName;
  }

  public void setBusinessCalendarName(String businessCalendarName) {
    this.businessCalendarName = businessCalendarName;
  }

  public String getCategory() {
		return category;
	}
	public void setCategory(String category) {
		this.category = category;
	}
	public String getExtensionId() {
    return extensionId;
  }
  public void setExtensionId(String extensionId) {
    this.extensionId = extensionId;
  }
  public boolean isExtended() {
    return extensionId != null && !extensionId.isEmpty();
  }
	public List<String> getCandidateUsers() {
    return candidateUsers;
  }
  public void setCandidateUsers(List<String> candidateUsers) {
    this.candidateUsers = candidateUsers;
  }
  public List<String> getCandidateGroups() {
    return candidateGroups;
  }
  public void setCandidateGroups(List<String> candidateGroups) {
    this.candidateGroups = candidateGroups;
  }
  public List<FormProperty> getFormProperties() {
    return formProperties;
  }
  public void setFormProperties(List<FormProperty> formProperties) {
    this.formProperties = formProperties;
  }
  public List<ActivitiListener> getTaskListeners() {
    return taskListeners;
  }
  public void setTaskListeners(List<ActivitiListener> taskListeners) {
    this.taskListeners = taskListeners;
  }
  
  public void addCustomUserIdentityLink(String userId, String type){
	  Set<String> userIdentitySet = customUserIdentityLinks.get(type);
	  
	  if(userIdentitySet == null){
		  userIdentitySet = new HashSet<String>();
		  customUserIdentityLinks.put(type, userIdentitySet);
	  }
	  
	  userIdentitySet.add(userId);
  }
  
  public void addCustomGroupIdentityLink(String groupId, String type){
	  Set<String> groupIdentitySet = customGroupIdentityLinks.get(type);
	  
	  if(groupIdentitySet == null){
		  groupIdentitySet = new HashSet<String>();
		  customGroupIdentityLinks.put(type, groupIdentitySet);
	  }
	  
	  groupIdentitySet.add(groupId);
  }
  
  public Map<String, Set<String>> getCustomUserIdentityLinks() {
	return customUserIdentityLinks;
  }
  
  public void setCustomUserIdentityLinks(
		Map<String, Set<String>> customUserIdentityLinks) {
	this.customUserIdentityLinks = customUserIdentityLinks;
  }
  
  public Map<String, Set<String>> getCustomGroupIdentityLinks() {
	return customGroupIdentityLinks;
  }
  
  public void setCustomGroupIdentityLinks(Map<String, Set<String>> customGroupIdentityLinks) {
    this.customGroupIdentityLinks = customGroupIdentityLinks;
  }
  
  public List<CustomProperty> getCustomProperties() {
    return customProperties;
  }
  public void setCustomProperties(List<CustomProperty> customProperties) {
    this.customProperties = customProperties;
  }
  
  public String getSkipExpression() {
    return skipExpression;
  }
  
  public void setSkipExpression(String skipExpression) {
    this.skipExpression = skipExpression;
  }
  public UserTask clone() {
    UserTask clone = new UserTask();
    clone.setValues(this);
    return clone;
  }
  
  public void setValues(UserTask otherElement) {
    super.setValues(otherElement);
    setAssignee(otherElement.getAssignee());
    setOwner(otherElement.getOwner());
    setFormKey(otherElement.getFormKey());
    setDueDate(otherElement.getDueDate());
    setPriority(otherElement.getPriority());
    setCategory(otherElement.getCategory());
    setExtensionId(otherElement.getExtensionId());
    setSkipExpression(otherElement.getSkipExpression());
    
    setCandidateGroups(new ArrayList<String>(otherElement.getCandidateGroups()));
    setCandidateUsers(new ArrayList<String>(otherElement.getCandidateUsers()));
    
    setCustomGroupIdentityLinks(otherElement.customGroupIdentityLinks);
    setCustomUserIdentityLinks(otherElement.customUserIdentityLinks);
    
    formProperties = new ArrayList<FormProperty>();
    if (otherElement.getFormProperties() != null && !otherElement.getFormProperties().isEmpty()) {
      for (FormProperty property : otherElement.getFormProperties()) {
        formProperties.add(property.clone());
      }
    }
    
    taskListeners = new ArrayList<ActivitiListener>();
    if (otherElement.getTaskListeners() != null && !otherElement.getTaskListeners().isEmpty()) {
      for (ActivitiListener listener : otherElement.getTaskListeners()) {
        taskListeners.add(listener.clone());
      }
    }
  }
}
!@#$%
20190526_172003,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;

/**
 * @author Tijs Rademakers
 */
public class SendTask extends TaskWithFieldExtensions {

  protected String type;
  protected String implementationType;
  protected String operationRef;

  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public String getImplementationType() {
    return implementationType;
  }

  public void setImplementationType(String implementationType) {
    this.implementationType = implementationType;
  }

  public String getOperationRef() {
    return operationRef;
  }

  public void setOperationRef(String operationRef) {
    this.operationRef = operationRef;
  }

  public SendTask clone() {
    SendTask clone = new SendTask();
    clone.setValues(this);
    return clone;
  }

  public void setValues(SendTask otherElement) {
    super.setValues(otherElement);
    setType(otherElement.getType());
    setImplementationType(otherElement.getImplementationType());
    setOperationRef(otherElement.getOperationRef());

    fieldExtensions = new ArrayList<FieldExtension>();
    if (otherElement.getFieldExtensions() != null && !otherElement.getFieldExtensions().isEmpty()) {
      for (FieldExtension extension : otherElement.getFieldExtensions()) {
        fieldExtensions.add(extension.clone());
      }
    }
  }
}
!@#$%
20190526_172003,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Tijs Rademakers
 */
public class SendTask extends Task {

  protected String type;
  protected String implementationType;
  protected String operationRef;
  protected List<FieldExtension> fieldExtensions = new ArrayList<FieldExtension>();
  
  public String getType() {
    return type;
  }
  public void setType(String type) {
    this.type = type;
  }
  public String getImplementationType() {
    return implementationType;
  }
  public void setImplementationType(String implementationType) {
    this.implementationType = implementationType;
  }
  public String getOperationRef() {
    return operationRef;
  }
  public void setOperationRef(String operationRef) {
    this.operationRef = operationRef;
  }
  public List<FieldExtension> getFieldExtensions() {
    return fieldExtensions;
  }
  public void setFieldExtensions(List<FieldExtension> fieldExtensions) {
    this.fieldExtensions = fieldExtensions;
  }
  
  public SendTask clone() {
    SendTask clone = new SendTask();
    clone.setValues(this);
    return clone;
  }
  
  public void setValues(SendTask otherElement) {
    super.setValues(otherElement);
    setType(otherElement.getType());
    setImplementationType(otherElement.getImplementationType());
    setOperationRef(otherElement.getOperationRef());
    
    fieldExtensions = new ArrayList<FieldExtension>();
    if (otherElement.getFieldExtensions() != null && !otherElement.getFieldExtensions().isEmpty()) {
      for (FieldExtension extension : otherElement.getFieldExtensions()) {
        fieldExtensions.add(extension.clone());
      }
    }
  }
}
!@#$%
20190526_172003,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;

/**
 * @author Tijs Rademakers
 */
public class SendTask extends TaskWithFieldExtensions {

  protected String type;
  protected String implementationType;
  protected String operationRef;
  
  public String getType() {
    return type;
  }
  public void setType(String type) {
    this.type = type;
  }
  public String getImplementationType() {
    return implementationType;
  }
  public void setImplementationType(String implementationType) {
    this.implementationType = implementationType;
  }
  public String getOperationRef() {
    return operationRef;
  }
  public void setOperationRef(String operationRef) {
    this.operationRef = operationRef;
  }
  
  public SendTask clone() {
    SendTask clone = new SendTask();
    clone.setValues(this);
    return clone;
  }
  
  public void setValues(SendTask otherElement) {
    super.setValues(otherElement);
    setType(otherElement.getType());
    setImplementationType(otherElement.getImplementationType());
    setOperationRef(otherElement.getOperationRef());
    
    fieldExtensions = new ArrayList<FieldExtension>();
    if (otherElement.getFieldExtensions() != null && !otherElement.getFieldExtensions().isEmpty()) {
      for (FieldExtension extension : otherElement.getFieldExtensions()) {
        fieldExtensions.add(extension.clone());
      }
    }
  }
}
!@#$%
20190526_172009,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

/**
 * @author Tijs Rademakers
 */
public class GraphicInfo {

  protected double x;
  protected double y;
  protected double height;
  protected double width;
  protected BaseElement element;
  protected Boolean expanded;
  protected int xmlRowNumber;
  protected int xmlColumnNumber;

  public double getX() {
    return x;
  }

  public void setX(double x) {
    this.x = x;
  }

  public double getY() {
    return y;
  }

  public void setY(double y) {
    this.y = y;
  }

  public double getHeight() {
    return height;
  }

  public void setHeight(double height) {
    this.height = height;
  }

  public double getWidth() {
    return width;
  }

  public void setWidth(double width) {
    this.width = width;
  }

  public Boolean getExpanded() {
    return expanded;
  }

  public void setExpanded(Boolean expanded) {
    this.expanded = expanded;
  }

  public BaseElement getElement() {
    return element;
  }

  public void setElement(BaseElement element) {
    this.element = element;
  }

  public int getXmlRowNumber() {
    return xmlRowNumber;
  }

  public void setXmlRowNumber(int xmlRowNumber) {
    this.xmlRowNumber = xmlRowNumber;
  }

  public int getXmlColumnNumber() {
    return xmlColumnNumber;
  }

  public void setXmlColumnNumber(int xmlColumnNumber) {
    this.xmlColumnNumber = xmlColumnNumber;
  }
}
!@#$%
20190526_172009,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;


/**
 * @author Tijs Rademakers
 */
public class GraphicInfo {
  
  protected double x;
  protected double y;
  protected double height;
  protected double width;
  protected FlowElement element;
  protected Boolean expanded;
  protected int xmlRowNumber;
  protected int xmlColumnNumber;
  public double getX() {
    return x;
  }
  public void setX(double x) {
    this.x = x;
  }
  public double getY() {
    return y;
  }
  public void setY(double y) {
    this.y = y;
  }
  public double getHeight() {
    return height;
  }
  public void setHeight(double height) {
    this.height = height;
  }
  public double getWidth() {
    return width;
  }
  public void setWidth(double width) {
    this.width = width;
  }
  public Boolean getExpanded() {
    return expanded;
  }
  public void setExpanded(Boolean expanded) {
    this.expanded = expanded;
  }
  public FlowElement getElement() {
    return element;
  }
  public void setElement(FlowElement element) {
    this.element = element;
  }
  public int getXmlRowNumber() {
    return xmlRowNumber;
  }
  public void setXmlRowNumber(int xmlRowNumber) {
    this.xmlRowNumber = xmlRowNumber;
  }
  public int getXmlColumnNumber() {
    return xmlColumnNumber;
  }
  public void setXmlColumnNumber(int xmlColumnNumber) {
    this.xmlColumnNumber = xmlColumnNumber;
  }
}
!@#$%
20190526_172009,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;


/**
 * @author Tijs Rademakers
 */
public class GraphicInfo {
  
  protected double x;
  protected double y;
  protected double height;
  protected double width;
  protected BaseElement element;
  protected Boolean expanded;
  protected int xmlRowNumber;
  protected int xmlColumnNumber;
  public double getX() {
    return x;
  }
  public void setX(double x) {
    this.x = x;
  }
  public double getY() {
    return y;
  }
  public void setY(double y) {
    this.y = y;
  }
  public double getHeight() {
    return height;
  }
  public void setHeight(double height) {
    this.height = height;
  }
  public double getWidth() {
    return width;
  }
  public void setWidth(double width) {
    this.width = width;
  }
  public Boolean getExpanded() {
    return expanded;
  }
  public void setExpanded(Boolean expanded) {
    this.expanded = expanded;
  }
  public BaseElement getElement() {
    return element;
  }
  public void setElement(BaseElement element) {
    this.element = element;
  }
  public int getXmlRowNumber() {
    return xmlRowNumber;
  }
  public void setXmlRowNumber(int xmlRowNumber) {
    this.xmlRowNumber = xmlRowNumber;
  }
  public int getXmlColumnNumber() {
    return xmlColumnNumber;
  }
  public void setXmlColumnNumber(int xmlColumnNumber) {
    this.xmlColumnNumber = xmlColumnNumber;
  }
}
!@#$%
20190526_172015,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public abstract class BaseElement implements HasExtensionAttributes {

  protected String id;
  protected int xmlRowNumber;
  protected int xmlColumnNumber;
  protected Map<String, List<ExtensionElement>> extensionElements = new LinkedHashMap<String, List<ExtensionElement>>();
  /** extension attributes could be part of each element */
  protected Map<String, List<ExtensionAttribute>> attributes = new LinkedHashMap<String, List<ExtensionAttribute>>();

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public int getXmlRowNumber() {
    return xmlRowNumber;
  }

  public void setXmlRowNumber(int xmlRowNumber) {
    this.xmlRowNumber = xmlRowNumber;
  }

  public int getXmlColumnNumber() {
    return xmlColumnNumber;
  }

  public void setXmlColumnNumber(int xmlColumnNumber) {
    this.xmlColumnNumber = xmlColumnNumber;
  }

  public Map<String, List<ExtensionElement>> getExtensionElements() {
    return extensionElements;
  }

  public void addExtensionElement(ExtensionElement extensionElement) {
    if (extensionElement != null && StringUtils.isNotEmpty(extensionElement.getName())) {
      List<ExtensionElement> elementList = null;
      if (this.extensionElements.containsKey(extensionElement.getName()) == false) {
        elementList = new ArrayList<ExtensionElement>();
        this.extensionElements.put(extensionElement.getName(), elementList);
      }
      this.extensionElements.get(extensionElement.getName()).add(extensionElement);
    }
  }

  public void setExtensionElements(Map<String, List<ExtensionElement>> extensionElements) {
    this.extensionElements = extensionElements;
  }

  @Override
  public Map<String, List<ExtensionAttribute>> getAttributes() {
    return attributes;
  }

  @Override
  public String getAttributeValue(String namespace, String name) {
    List<ExtensionAttribute> attributes = getAttributes().get(name);
    if (attributes != null && !attributes.isEmpty()) {
      for (ExtensionAttribute attribute : attributes) {
        if ((namespace == null && attribute.getNamespace() == null) || namespace.equals(attribute.getNamespace()))
          return attribute.getValue();
      }
    }
    return null;
  }

  @Override
  public void addAttribute(ExtensionAttribute attribute) {
    if (attribute != null && StringUtils.isNotEmpty(attribute.getName())) {
      List<ExtensionAttribute> attributeList = null;
      if (this.attributes.containsKey(attribute.getName()) == false) {
        attributeList = new ArrayList<ExtensionAttribute>();
        this.attributes.put(attribute.getName(), attributeList);
      }
      this.attributes.get(attribute.getName()).add(attribute);
    }
  }

  @Override
  public void setAttributes(Map<String, List<ExtensionAttribute>> attributes) {
    this.attributes = attributes;
  }

  public void setValues(BaseElement otherElement) {
    setId(otherElement.getId());

    extensionElements = new LinkedHashMap<String, List<ExtensionElement>>();
    if (otherElement.getExtensionElements() != null && !otherElement.getExtensionElements().isEmpty()) {
      for (String key : otherElement.getExtensionElements().keySet()) {
        List<ExtensionElement> otherElementList = otherElement.getExtensionElements().get(key);
        if (otherElementList != null && !otherElementList.isEmpty()) {
          List<ExtensionElement> elementList = new ArrayList<ExtensionElement>();
          for (ExtensionElement extensionElement : otherElementList) {
            elementList.add(extensionElement.clone());
          }
          extensionElements.put(key, elementList);
        }
      }
    }

    attributes = new LinkedHashMap<String, List<ExtensionAttribute>>();
    if (otherElement.getAttributes() != null && !otherElement.getAttributes().isEmpty()) {
      for (String key : otherElement.getAttributes().keySet()) {
        List<ExtensionAttribute> otherAttributeList = otherElement.getAttributes().get(key);
        if (otherAttributeList != null && !otherAttributeList.isEmpty()) {
          List<ExtensionAttribute> attributeList = new ArrayList<ExtensionAttribute>();
          for (ExtensionAttribute extensionAttribute : otherAttributeList) {
            attributeList.add(extensionAttribute.clone());
          }
          attributes.put(key, attributeList);
        }
      }
    }
  }

  public abstract BaseElement clone();
}
!@#$%
20190526_172015,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public abstract class BaseElement implements HasExtensionAttributes {

  protected String id;
  protected int xmlRowNumber;
  protected int xmlColumnNumber;
  protected Map<String, List<ExtensionElement>> extensionElements = new LinkedHashMap<String, List<ExtensionElement>>();
  /** extension attributes could be part of each element */
  protected Map<String, List<ExtensionAttribute>> attributes = new LinkedHashMap<String, List<ExtensionAttribute>>();

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public int getXmlRowNumber() {
    return xmlRowNumber;
  }

  public void setXmlRowNumber(int xmlRowNumber) {
    this.xmlRowNumber = xmlRowNumber;
  }

  public int getXmlColumnNumber() {
    return xmlColumnNumber;
  }

  public void setXmlColumnNumber(int xmlColumnNumber) {
    this.xmlColumnNumber = xmlColumnNumber;
  }

  public Map<String, List<ExtensionElement>> getExtensionElements() {
    return extensionElements;
  }

  public void addExtensionElement(ExtensionElement extensionElement) {
    if (extensionElement != null && StringUtils.isNotEmpty(extensionElement.getName())) {
      List<ExtensionElement> elementList = null;
      if (this.extensionElements.containsKey(extensionElement.getName()) == false) {
        elementList = new ArrayList<ExtensionElement>();
        this.extensionElements.put(extensionElement.getName(), elementList);
      }
      this.extensionElements.get(extensionElement.getName()).add(extensionElement);
    }
  }

  public void setExtensionElements(Map<String, List<ExtensionElement>> extensionElements) {
    this.extensionElements = extensionElements;
  }

  @Override
  public Map<String, List<ExtensionAttribute>> getAttributes() {
    return attributes;
  }

  @Override
  public String getAttributeValue(String namespace, String name) {
    List<ExtensionAttribute> attributes = getAttributes().get(name);
    if (attributes != null && !attributes.isEmpty()) {
      for (ExtensionAttribute attribute : attributes) {
        if ( (namespace == null && attribute.getNamespace() == null)
            || namespace.equals(attribute.getNamespace()) )
          return attribute.getValue();
      }
    }
    return null;
  }

  @Override
  public void addAttribute(ExtensionAttribute attribute) {
    if (attribute != null && StringUtils.isNotEmpty(attribute.getName())) {
      List<ExtensionAttribute> attributeList = null;
      if (this.attributes.containsKey(attribute.getName()) == false) {
        attributeList = new ArrayList<ExtensionAttribute>();
        this.attributes.put(attribute.getName(), attributeList);
      }
      this.attributes.get(attribute.getName()).add(attribute);
    }
  }

  @Override
  public void setAttributes(Map<String, List<ExtensionAttribute>> attributes) {
    this.attributes = attributes;
  }

  public void setValues(BaseElement otherElement) {
    setId(otherElement.getId());

    extensionElements = new LinkedHashMap<String, List<ExtensionElement>>();
    if (otherElement.getExtensionElements() != null && !otherElement.getExtensionElements().isEmpty()) {
      for (String key : otherElement.getExtensionElements().keySet()) {
        List<ExtensionElement> otherElementList = otherElement.getExtensionElements().get(key);
        if (otherElementList != null && !otherElementList.isEmpty()) {
          List<ExtensionElement> elementList = new ArrayList<ExtensionElement>();
          for (ExtensionElement extensionElement : otherElementList) {
            elementList.add(extensionElement.clone());
          }
          extensionElements.put(key, elementList);
        }
      }
    }

    attributes = new LinkedHashMap<String, List<ExtensionAttribute>>();
    if (otherElement.getAttributes() != null && !otherElement.getAttributes().isEmpty()) {
      for (String key : otherElement.getAttributes().keySet()) {
        List<ExtensionAttribute> otherAttributeList = otherElement.getAttributes().get(key);
        if (otherAttributeList != null && !otherAttributeList.isEmpty()) {
          List<ExtensionAttribute> attributeList = new ArrayList<ExtensionAttribute>();
          for (ExtensionAttribute extensionAttribute : otherAttributeList) {
            attributeList.add(extensionAttribute.clone());
          }
          attributes.put(key, attributeList);
        }
      }
    }
  }

  public abstract BaseElement clone();
}
!@#$%
20190526_172015,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.model;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public abstract class BaseElement implements HasExtensionAttributes {

  protected String id;
  protected int xmlRowNumber;
  protected int xmlColumnNumber;
  protected Map<String, List<ExtensionElement>> extensionElements = new LinkedHashMap<String, List<ExtensionElement>>();
  /** extension attributes could be part of each element */
  protected Map<String, List<ExtensionAttribute>> attributes = new LinkedHashMap<String, List<ExtensionAttribute>>();

  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public int getXmlRowNumber() {
    return xmlRowNumber;
  }

  public void setXmlRowNumber(int xmlRowNumber) {
    this.xmlRowNumber = xmlRowNumber;
  }

  public int getXmlColumnNumber() {
    return xmlColumnNumber;
  }

  public void setXmlColumnNumber(int xmlColumnNumber) {
    this.xmlColumnNumber = xmlColumnNumber;
  }

  public Map<String, List<ExtensionElement>> getExtensionElements() {
    return extensionElements;
  }

  public void addExtensionElement(ExtensionElement extensionElement) {
    if (extensionElement != null && StringUtils.isNotEmpty(extensionElement.getName())) {
      List<ExtensionElement> elementList = null;
      if (this.extensionElements.containsKey(extensionElement.getName()) == false) {
        elementList = new ArrayList<ExtensionElement>();
        this.extensionElements.put(extensionElement.getName(), elementList);
      }
      this.extensionElements.get(extensionElement.getName()).add(extensionElement);
    }
  }

  public void setExtensionElements(Map<String, List<ExtensionElement>> extensionElements) {
    this.extensionElements = extensionElements;
  }

  @Override
  public Map<String, List<ExtensionAttribute>> getAttributes() {
    return attributes;
  }

  @Override
  public String getAttributeValue(String namespace, String name) {
    List<ExtensionAttribute> attributes = getAttributes().get(name);
    if (attributes != null && !attributes.isEmpty()) {
      for (ExtensionAttribute attribute : attributes) {
        if ( (namespace == null && attribute.getNamespace() == null)
            || (namespace!=null && namespace.equals(attribute.getNamespace())) )
          return attribute.getValue();
      }
    }
    return null;
  }

  @Override
  public void addAttribute(ExtensionAttribute attribute) {
    if (attribute != null && StringUtils.isNotEmpty(attribute.getName())) {
      List<ExtensionAttribute> attributeList = null;
      if (this.attributes.containsKey(attribute.getName()) == false) {
        attributeList = new ArrayList<ExtensionAttribute>();
        this.attributes.put(attribute.getName(), attributeList);
      }
      this.attributes.get(attribute.getName()).add(attribute);
    }
  }

  @Override
  public void setAttributes(Map<String, List<ExtensionAttribute>> attributes) {
    this.attributes = attributes;
  }

  public void setValues(BaseElement otherElement) {
    setId(otherElement.getId());

    extensionElements = new LinkedHashMap<String, List<ExtensionElement>>();
    if (otherElement.getExtensionElements() != null && !otherElement.getExtensionElements().isEmpty()) {
      for (String key : otherElement.getExtensionElements().keySet()) {
        List<ExtensionElement> otherElementList = otherElement.getExtensionElements().get(key);
        if (otherElementList != null && !otherElementList.isEmpty()) {
          List<ExtensionElement> elementList = new ArrayList<ExtensionElement>();
          for (ExtensionElement extensionElement : otherElementList) {
            elementList.add(extensionElement.clone());
          }
          extensionElements.put(key, elementList);
        }
      }
    }

    attributes = new LinkedHashMap<String, List<ExtensionAttribute>>();
    if (otherElement.getAttributes() != null && !otherElement.getAttributes().isEmpty()) {
      for (String key : otherElement.getAttributes().keySet()) {
        List<ExtensionAttribute> otherAttributeList = otherElement.getAttributes().get(key);
        if (otherAttributeList != null && !otherAttributeList.isEmpty()) {
          List<ExtensionAttribute> attributeList = new ArrayList<ExtensionAttribute>();
          for (ExtensionAttribute extensionAttribute : otherAttributeList) {
            attributeList.add(extensionAttribute.clone());
          }
          attributes.put(key, attributeList);
        }
      }
    }
  }

  public abstract BaseElement clone();
}
!@#$%
20190526_172019,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="https://activiti.atlassian.net/browse/ACT-1847">https://activiti.atlassian.net/browse/ACT-1847</a>
 */
public class ValuedDataObjectWithExtensionsConverterTest extends AbstractConverterTest {

  protected static final String YOURCO_EXTENSIONS_NAMESPACE = "http://yourco/bpmn";
  protected static final String YOURCO_EXTENSIONS_PREFIX = "yourco";

  protected static final String ELEMENT_DATA_ATTRIBUTES = "attributes";
  protected static final String ELEMENT_DATA_ATTRIBUTE = "attribute";
  protected static final String ATTRIBUTE_NAME = "name";
  protected static final String ATTRIBUTE_VALUE = "value";

  protected static final String ELEMENT_I18LN_LOCALIZATION = "i18ln";
  protected static final String ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_NAME = "resourceBundleKeyForName";
  protected static final String ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION = "resourceBundleKeyForDescription";
  protected static final String ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_NAME = "labeledEntityIdForName";
  protected static final String ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_DESCRIPTION = "labeledEntityIdForDescription";

  private Localization localization = new Localization();

  /*
   * Inner class used to hold localization DataObject extension values
   */
  public class Localization {

    private String resourceBundleKeyForName;
    private String resourceBundleKeyForDescription;
    private String labeledEntityIdForName;
    private String labeledEntityIdForDescription;

    public String getResourceBundleKeyForName() {
      return resourceBundleKeyForName;
    }

    public void setResourceBundleKeyForName(String resourceBundleKeyForName) {
      this.resourceBundleKeyForName = resourceBundleKeyForName;
    }

    public String getResourceBundleKeyForDescription() {
      return resourceBundleKeyForDescription;
    }

    public void setResourceBundleKeyForDescription(String resourceBundleKeyForDescription) {
      this.resourceBundleKeyForDescription = resourceBundleKeyForDescription;
    }

    public String getLabeledEntityIdForName() {
      return labeledEntityIdForName;
    }

    public void setLabeledEntityIdForName(String labeledEntityIdForName) {
      this.labeledEntityIdForName = labeledEntityIdForName;
    }

    public String getLabeledEntityIdForDescription() {
      return labeledEntityIdForDescription;
    }

    public void setLabeledEntityIdForDescription(String labeledEntityIdForDescription) {
      this.labeledEntityIdForDescription = labeledEntityIdForDescription;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder(100);
      sb.append("Localization: [");
      sb.append("resourceBundleKeyForName=").append(resourceBundleKeyForName);
      sb.append(", resourceBundleKeyForDescription=").append(resourceBundleKeyForDescription);
      sb.append(", labeledEntityIdForName=").append(labeledEntityIdForName);
      sb.append(", labeledEntityIdForDescription=").append(labeledEntityIdForDescription);
      sb.append("]");
      return sb.toString();
    }
  }

  /*
   * End of inner classes
   */

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "valueddataobjectmodel_with_extensions.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    // verify the main process data objects
    List<ValuedDataObject> dataObjects = model.getMainProcess().getDataObjects();
    assertEquals(1, dataObjects.size());

    Map<String, ValuedDataObject> objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    ValuedDataObject dataObj = objectMap.get("dObj1");
    assertEquals("dObj1", dataObj.getId());
    assertEquals("StringTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    assertTrue(dataObj.getValue() instanceof String);
    assertEquals("Testing123", dataObj.getValue());

    /*
     * Verify DataObject attributes extension
     */
    Map<String, String> attributes = getDataObjectAttributes(dataObj);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr1")) {
        assertTrue("1".equals(attributes.get(key)));
      } else if (key.equals("Attr2")) {
        assertTrue("2".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }

    /*
     * Verify DataObject localization extension
     */
    Localization localization = getLocalization(dataObj);
    assertEquals("rbkfn-1", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-1", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-1", localization.getLabeledEntityIdForName());
    assertEquals("leifd-1", localization.getLabeledEntityIdForDescription());

    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertEquals(6, subProcess.getFlowElements().size());

    // verify the sub process data objects
    dataObjects = subProcess.getDataObjects();
    assertEquals(1, dataObjects.size());

    objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    dataObj = objectMap.get("dObj2");
    assertEquals("dObj2", dataObj.getId());
    assertEquals("BooleanTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    assertTrue(dataObj.getValue() instanceof Boolean);
    assertEquals(Boolean.TRUE, dataObj.getValue());

    /*
     * Verify DataObject attributes extension
     */
    attributes = getDataObjectAttributes(dataObj);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr3")) {
        assertTrue("3".equals(attributes.get(key)));
      } else if (key.equals("Attr4")) {
        assertTrue("4".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }

    /*
     * Verify DataObject localization extension
     */
    localization = getLocalization(dataObj);
    assertEquals("rbkfn-2", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-2", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-2", localization.getLabeledEntityIdForName());
    assertEquals("leifd-2", localization.getLabeledEntityIdForDescription());
  }

  protected static String getExtensionValue(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0).getElementText();
    }
    return null;
  }

  protected static ExtensionElement getExtensionElement(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0);
    }
    return null;
  }

  protected Map<String, String> getDataObjectAttributes(BaseElement dObj) {
    Map<String, String> attributes = null;

    if (null != dObj) {
      List<ExtensionElement> attributesExtension = dObj.getExtensionElements().get(ELEMENT_DATA_ATTRIBUTES);

      if (null != attributesExtension && !attributesExtension.isEmpty()) {
        attributes = new HashMap<String, String>();
        List<ExtensionElement> attributeExtensions = attributesExtension.get(0).getChildElements().get(ELEMENT_DATA_ATTRIBUTE);

        for (ExtensionElement attributeExtension : attributeExtensions) {
          attributes.put(attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_NAME), attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_VALUE));
        }
      }
    }
    return attributes;
  }

  protected Localization getLocalization(BaseElement dObj) {
    List<ExtensionElement> i18lnExtension = dObj.getExtensionElements().get(ELEMENT_I18LN_LOCALIZATION);

    if (!i18lnExtension.isEmpty()) {
      Map<String, List<ExtensionAttribute>> extensionAttributes = i18lnExtension.get(0).getAttributes();
      localization.setLabeledEntityIdForName(extensionAttributes.get(ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_NAME).get(0).getValue());
      localization.setLabeledEntityIdForDescription(extensionAttributes.get(ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_DESCRIPTION).get(0).getValue());
      localization.setResourceBundleKeyForName(extensionAttributes.get(ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_NAME).get(0).getValue());
      localization.setResourceBundleKeyForDescription(extensionAttributes.get(ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION).get(0).getValue());
    }
    return localization;
  }
}
!@#$%
20190526_172019,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="http://jira.codehaus.org/browse/ACT-1847">http://jira.codehaus.org/browse/ACT-1847</a>
 */
public class ValuedDataObjectWithExtensionsConverterTest extends AbstractConverterTest {
  
  protected static final String YOURCO_EXTENSIONS_NAMESPACE = "http://yourco/bpmn";
  protected static final String YOURCO_EXTENSIONS_PREFIX = "yourco";

  protected static final String ELEMENT_DATA_ATTRIBUTES = "attributes";
  protected static final String ELEMENT_DATA_ATTRIBUTE = "attribute";
  protected static final String ATTRIBUTE_NAME = "name";
  protected static final String ATTRIBUTE_VALUE = "value";

  protected static final String ELEMENT_I18LN_LOCALIZATION = "i18ln";
  protected static final String ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_NAME = "resourceBundleKeyForName";
  protected static final String ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION = "resourceBundleKeyForDescription";
  protected static final String ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_NAME = "labeledEntityIdForName";
  protected static final String ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_DESCRIPTION = "labeledEntityIdForDescription";

  private Localization localization = new Localization();

  /*
   * Inner class used to hold localization DataObject extension values
   */
  public class Localization {
    
    private String resourceBundleKeyForName;
    private String resourceBundleKeyForDescription;
    private String labeledEntityIdForName;
    private String labeledEntityIdForDescription;

    public String getResourceBundleKeyForName() {
      return resourceBundleKeyForName;
    }

    public void setResourceBundleKeyForName(String resourceBundleKeyForName) {
      this.resourceBundleKeyForName = resourceBundleKeyForName;
    }

    public String getResourceBundleKeyForDescription() {
      return resourceBundleKeyForDescription;
    }

    public void setResourceBundleKeyForDescription(String resourceBundleKeyForDescription) {
      this.resourceBundleKeyForDescription = resourceBundleKeyForDescription;
    }

    public String getLabeledEntityIdForName() {
      return labeledEntityIdForName;
    }

    public void setLabeledEntityIdForName(String labeledEntityIdForName) {
      this.labeledEntityIdForName = labeledEntityIdForName;
    }

    public String getLabeledEntityIdForDescription() {
      return labeledEntityIdForDescription;
    }

    public void setLabeledEntityIdForDescription(String labeledEntityIdForDescription) {
      this.labeledEntityIdForDescription = labeledEntityIdForDescription;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder(100);
      sb.append("Localization: [");
      sb.append("resourceBundleKeyForName=").append(resourceBundleKeyForName);
      sb.append(", resourceBundleKeyForDescription=").append(resourceBundleKeyForDescription);
      sb.append(", labeledEntityIdForName=").append(labeledEntityIdForName);
      sb.append(", labeledEntityIdForDescription=").append(labeledEntityIdForDescription);
      sb.append("]");
      return sb.toString();
    }
  }
  /*
   * End of inner classes
   */

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "valueddataobjectmodel_with_extensions.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    // verify the main process data objects
    List<ValuedDataObject> dataObjects = model.getMainProcess().getDataObjects();
    assertEquals(1, dataObjects.size());

    Map<String, ValuedDataObject> objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    ValuedDataObject dataObj = objectMap.get("dObj1");
    assertEquals("dObj1", dataObj.getId());
    assertEquals("StringTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    assertTrue(dataObj.getValue() instanceof String);
    assertEquals("Testing123", dataObj.getValue());
    
    /*
     * Verify DataObject attributes extension
     */
    Map<String, String> attributes = getDataObjectAttributes(dataObj);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr1")) {
        assertTrue("1".equals(attributes.get(key)));
      } else if (key.equals("Attr2")) {
        assertTrue("2".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }
    
    /*
     * Verify DataObject localization extension
     */
    Localization localization = getLocalization(dataObj);
    assertEquals("rbkfn-1", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-1", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-1", localization.getLabeledEntityIdForName());
    assertEquals("leifd-1", localization.getLabeledEntityIdForDescription());

    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertEquals(6, subProcess.getFlowElements().size());

    // verify the sub process data objects
    dataObjects = subProcess.getDataObjects();
    assertEquals(1, dataObjects.size());

    objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    dataObj = objectMap.get("dObj2");
    assertEquals("dObj2", dataObj.getId());
    assertEquals("BooleanTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    assertTrue(dataObj.getValue() instanceof Boolean);
    assertEquals(Boolean.TRUE, dataObj.getValue());

    /*
     * Verify DataObject attributes extension
     */
    attributes = getDataObjectAttributes(dataObj);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr3")) {
        assertTrue("3".equals(attributes.get(key)));
      } else if (key.equals("Attr4")) {
        assertTrue("4".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }
    
    /*
     * Verify DataObject localization extension
     */
    localization = getLocalization(dataObj);
    assertEquals("rbkfn-2", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-2", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-2", localization.getLabeledEntityIdForName());
    assertEquals("leifd-2", localization.getLabeledEntityIdForDescription());
}

  protected static String getExtensionValue(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0).getElementText();
    }
    return null;
  }

  protected static ExtensionElement getExtensionElement(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0);
    }
    return null;
  }

  protected Map<String, String> getDataObjectAttributes(BaseElement dObj) {
    Map<String, String> attributes = null;

    if (null != dObj) {
      List<ExtensionElement> attributesExtension = dObj.getExtensionElements().get(ELEMENT_DATA_ATTRIBUTES);

      if (null != attributesExtension && !attributesExtension.isEmpty()) {
        attributes = new HashMap<String, String>();
        List<ExtensionElement> attributeExtensions =
                attributesExtension.get(0).getChildElements().get(ELEMENT_DATA_ATTRIBUTE);
        
        for (ExtensionElement attributeExtension : attributeExtensions) {
          attributes.put(attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_NAME),
                  attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_VALUE));
        }
      }
    }
    return attributes;
  }

  protected Localization getLocalization(BaseElement dObj) {
    List<ExtensionElement> i18lnExtension = dObj.getExtensionElements().get(ELEMENT_I18LN_LOCALIZATION);

    if (!i18lnExtension.isEmpty()) {
      Map<String, List<ExtensionAttribute>> extensionAttributes = i18lnExtension.get(0).getAttributes();
      localization.setLabeledEntityIdForName(extensionAttributes.get(ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_NAME)
              .get(0).getValue());
      localization.setLabeledEntityIdForDescription(extensionAttributes.get(ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_DESCRIPTION)
              .get(0).getValue());
      localization.setResourceBundleKeyForName(extensionAttributes.get(ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_NAME)
              .get(0).getValue());
      localization.setResourceBundleKeyForDescription(extensionAttributes.get(ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION)
              .get(0).getValue());
    }
    return localization;
  }
}
!@#$%
20190526_172019,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="https://activiti.atlassian.net/browse/ACT-1847">https://activiti.atlassian.net/browse/ACT-1847</a>
 */
public class ValuedDataObjectWithExtensionsConverterTest extends AbstractConverterTest {
  
  protected static final String YOURCO_EXTENSIONS_NAMESPACE = "http://yourco/bpmn";
  protected static final String YOURCO_EXTENSIONS_PREFIX = "yourco";

  protected static final String ELEMENT_DATA_ATTRIBUTES = "attributes";
  protected static final String ELEMENT_DATA_ATTRIBUTE = "attribute";
  protected static final String ATTRIBUTE_NAME = "name";
  protected static final String ATTRIBUTE_VALUE = "value";

  protected static final String ELEMENT_I18LN_LOCALIZATION = "i18ln";
  protected static final String ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_NAME = "resourceBundleKeyForName";
  protected static final String ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION = "resourceBundleKeyForDescription";
  protected static final String ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_NAME = "labeledEntityIdForName";
  protected static final String ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_DESCRIPTION = "labeledEntityIdForDescription";

  private Localization localization = new Localization();

  /*
   * Inner class used to hold localization DataObject extension values
   */
  public class Localization {
    
    private String resourceBundleKeyForName;
    private String resourceBundleKeyForDescription;
    private String labeledEntityIdForName;
    private String labeledEntityIdForDescription;

    public String getResourceBundleKeyForName() {
      return resourceBundleKeyForName;
    }

    public void setResourceBundleKeyForName(String resourceBundleKeyForName) {
      this.resourceBundleKeyForName = resourceBundleKeyForName;
    }

    public String getResourceBundleKeyForDescription() {
      return resourceBundleKeyForDescription;
    }

    public void setResourceBundleKeyForDescription(String resourceBundleKeyForDescription) {
      this.resourceBundleKeyForDescription = resourceBundleKeyForDescription;
    }

    public String getLabeledEntityIdForName() {
      return labeledEntityIdForName;
    }

    public void setLabeledEntityIdForName(String labeledEntityIdForName) {
      this.labeledEntityIdForName = labeledEntityIdForName;
    }

    public String getLabeledEntityIdForDescription() {
      return labeledEntityIdForDescription;
    }

    public void setLabeledEntityIdForDescription(String labeledEntityIdForDescription) {
      this.labeledEntityIdForDescription = labeledEntityIdForDescription;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder(100);
      sb.append("Localization: [");
      sb.append("resourceBundleKeyForName=").append(resourceBundleKeyForName);
      sb.append(", resourceBundleKeyForDescription=").append(resourceBundleKeyForDescription);
      sb.append(", labeledEntityIdForName=").append(labeledEntityIdForName);
      sb.append(", labeledEntityIdForDescription=").append(labeledEntityIdForDescription);
      sb.append("]");
      return sb.toString();
    }
  }
  /*
   * End of inner classes
   */

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "valueddataobjectmodel_with_extensions.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    // verify the main process data objects
    List<ValuedDataObject> dataObjects = model.getMainProcess().getDataObjects();
    assertEquals(1, dataObjects.size());

    Map<String, ValuedDataObject> objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    ValuedDataObject dataObj = objectMap.get("dObj1");
    assertEquals("dObj1", dataObj.getId());
    assertEquals("StringTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    assertTrue(dataObj.getValue() instanceof String);
    assertEquals("Testing123", dataObj.getValue());
    
    /*
     * Verify DataObject attributes extension
     */
    Map<String, String> attributes = getDataObjectAttributes(dataObj);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr1")) {
        assertTrue("1".equals(attributes.get(key)));
      } else if (key.equals("Attr2")) {
        assertTrue("2".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }
    
    /*
     * Verify DataObject localization extension
     */
    Localization localization = getLocalization(dataObj);
    assertEquals("rbkfn-1", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-1", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-1", localization.getLabeledEntityIdForName());
    assertEquals("leifd-1", localization.getLabeledEntityIdForDescription());

    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertEquals(6, subProcess.getFlowElements().size());

    // verify the sub process data objects
    dataObjects = subProcess.getDataObjects();
    assertEquals(1, dataObjects.size());

    objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    dataObj = objectMap.get("dObj2");
    assertEquals("dObj2", dataObj.getId());
    assertEquals("BooleanTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    assertTrue(dataObj.getValue() instanceof Boolean);
    assertEquals(Boolean.TRUE, dataObj.getValue());

    /*
     * Verify DataObject attributes extension
     */
    attributes = getDataObjectAttributes(dataObj);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr3")) {
        assertTrue("3".equals(attributes.get(key)));
      } else if (key.equals("Attr4")) {
        assertTrue("4".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }
    
    /*
     * Verify DataObject localization extension
     */
    localization = getLocalization(dataObj);
    assertEquals("rbkfn-2", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-2", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-2", localization.getLabeledEntityIdForName());
    assertEquals("leifd-2", localization.getLabeledEntityIdForDescription());
}

  protected static String getExtensionValue(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0).getElementText();
    }
    return null;
  }

  protected static ExtensionElement getExtensionElement(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0);
    }
    return null;
  }

  protected Map<String, String> getDataObjectAttributes(BaseElement dObj) {
    Map<String, String> attributes = null;

    if (null != dObj) {
      List<ExtensionElement> attributesExtension = dObj.getExtensionElements().get(ELEMENT_DATA_ATTRIBUTES);

      if (null != attributesExtension && !attributesExtension.isEmpty()) {
        attributes = new HashMap<String, String>();
        List<ExtensionElement> attributeExtensions =
                attributesExtension.get(0).getChildElements().get(ELEMENT_DATA_ATTRIBUTE);
        
        for (ExtensionElement attributeExtension : attributeExtensions) {
          attributes.put(attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_NAME),
                  attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_VALUE));
        }
      }
    }
    return attributes;
  }

  protected Localization getLocalization(BaseElement dObj) {
    List<ExtensionElement> i18lnExtension = dObj.getExtensionElements().get(ELEMENT_I18LN_LOCALIZATION);

    if (!i18lnExtension.isEmpty()) {
      Map<String, List<ExtensionAttribute>> extensionAttributes = i18lnExtension.get(0).getAttributes();
      localization.setLabeledEntityIdForName(extensionAttributes.get(ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_NAME)
              .get(0).getValue());
      localization.setLabeledEntityIdForDescription(extensionAttributes.get(ATTRIBUTE_DATA_LABELED_ENTITY_ID_FOR_DESCRIPTION)
              .get(0).getValue());
      localization.setResourceBundleKeyForName(extensionAttributes.get(ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_NAME)
              .get(0).getValue());
      localization.setResourceBundleKeyForDescription(extensionAttributes.get(ATTRIBUTE_DATA_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION)
              .get(0).getValue());
    }
    return localization;
  }
}
!@#$%
20190526_172024,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="https://activiti.atlassian.net/browse/ACT-2055">https://activiti.atlassian.net/browse/ACT-2055</a>
 */
public class SubProcessWithExtensionsConverterTest extends AbstractConverterTest {

  protected static final String YOURCO_EXTENSIONS_NAMESPACE = "http://yourco/bpmn";
  protected static final String YOURCO_EXTENSIONS_PREFIX = "yourco";

  protected static final String ELEMENT_ATTRIBUTES = "attributes";
  protected static final String ELEMENT_ATTRIBUTE = "attribute";
  protected static final String ATTRIBUTE_NAME = "name";
  protected static final String ATTRIBUTE_VALUE = "value";

  protected static final String ELEMENT_I18LN_LOCALIZATION = "i18ln";
  protected static final String ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_NAME = "resourceBundleKeyForName";
  protected static final String ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION = "resourceBundleKeyForDescription";
  protected static final String ATTRIBUTE_LABELED_ENTITY_ID_FOR_NAME = "labeledEntityIdForName";
  protected static final String ATTRIBUTE_LABELED_ENTITY_ID_FOR_DESCRIPTION = "labeledEntityIdForDescription";

  private Localization localization = new Localization();

  /*
   * Inner class used to hold localization DataObject extension values
   */
  public class Localization {

    private String resourceBundleKeyForName;
    private String resourceBundleKeyForDescription;
    private String labeledEntityIdForName;
    private String labeledEntityIdForDescription;

    public String getResourceBundleKeyForName() {
      return resourceBundleKeyForName;
    }

    public void setResourceBundleKeyForName(String resourceBundleKeyForName) {
      this.resourceBundleKeyForName = resourceBundleKeyForName;
    }

    public String getResourceBundleKeyForDescription() {
      return resourceBundleKeyForDescription;
    }

    public void setResourceBundleKeyForDescription(String resourceBundleKeyForDescription) {
      this.resourceBundleKeyForDescription = resourceBundleKeyForDescription;
    }

    public String getLabeledEntityIdForName() {
      return labeledEntityIdForName;
    }

    public void setLabeledEntityIdForName(String labeledEntityIdForName) {
      this.labeledEntityIdForName = labeledEntityIdForName;
    }

    public String getLabeledEntityIdForDescription() {
      return labeledEntityIdForDescription;
    }

    public void setLabeledEntityIdForDescription(String labeledEntityIdForDescription) {
      this.labeledEntityIdForDescription = labeledEntityIdForDescription;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder(100);
      sb.append("Localization: [");
      sb.append("resourceBundleKeyForName=").append(resourceBundleKeyForName);
      sb.append(", resourceBundleKeyForDescription=").append(resourceBundleKeyForDescription);
      sb.append(", labeledEntityIdForName=").append(labeledEntityIdForName);
      sb.append(", labeledEntityIdForDescription=").append(labeledEntityIdForDescription);
      sb.append("]");
      return sb.toString();
    }
  }

  /*
   * End of inner classes
   */

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "subprocessmodel_with_extensions.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertTrue(subProcess.getLoopCharacteristics().isSequential());
    assertEquals("10", subProcess.getLoopCharacteristics().getLoopCardinality());
    assertEquals("${assignee == \"\"}", subProcess.getLoopCharacteristics().getCompletionCondition());
    assertTrue(subProcess.getFlowElements().size() == 5);

    /*
     * Verify Subprocess attributes extension
     */
    Map<String, String> attributes = getSubprocessAttributes(flowElement);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr3")) {
        assertTrue("3".equals(attributes.get(key)));
      } else if (key.equals("Attr4")) {
        assertTrue("4".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }

    /*
     * Verify Subprocess localization extension
     */
    localization = getLocalization(flowElement);
    assertEquals("rbkfn-2", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-2", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-2", localization.getLabeledEntityIdForName());
    assertEquals("leifd-2", localization.getLabeledEntityIdForDescription());
  }

  protected static String getExtensionValue(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0).getElementText();
    }
    return null;
  }

  protected static ExtensionElement getExtensionElement(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0);
    }
    return null;
  }

  protected Map<String, String> getSubprocessAttributes(BaseElement bObj) {
    Map<String, String> attributes = null;

    if (null != bObj) {
      List<ExtensionElement> attributesExtension = bObj.getExtensionElements().get(ELEMENT_ATTRIBUTES);

      if (null != attributesExtension && !attributesExtension.isEmpty()) {
        attributes = new HashMap<String, String>();
        List<ExtensionElement> attributeExtensions = attributesExtension.get(0).getChildElements().get(ELEMENT_ATTRIBUTE);

        for (ExtensionElement attributeExtension : attributeExtensions) {
          attributes.put(attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_NAME), attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_VALUE));
        }
      }
    }
    return attributes;
  }

  protected Localization getLocalization(BaseElement bObj) {
    List<ExtensionElement> i18lnExtension = bObj.getExtensionElements().get(ELEMENT_I18LN_LOCALIZATION);

    if (!i18lnExtension.isEmpty()) {
      Map<String, List<ExtensionAttribute>> extensionAttributes = i18lnExtension.get(0).getAttributes();
      localization.setLabeledEntityIdForName(extensionAttributes.get(ATTRIBUTE_LABELED_ENTITY_ID_FOR_NAME).get(0).getValue());
      localization.setLabeledEntityIdForDescription(extensionAttributes.get(ATTRIBUTE_LABELED_ENTITY_ID_FOR_DESCRIPTION).get(0).getValue());
      localization.setResourceBundleKeyForName(extensionAttributes.get(ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_NAME).get(0).getValue());
      localization.setResourceBundleKeyForDescription(extensionAttributes.get(ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION).get(0).getValue());
    }
    return localization;
  }
}
!@#$%
20190526_172024,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="http://jira.codehaus.org/browse/ACT-2055">http://jira.codehaus.org/browse/ACT-2055</a>
 */
public class SubProcessWithExtensionsConverterTest extends AbstractConverterTest {
  
  protected static final String YOURCO_EXTENSIONS_NAMESPACE = "http://yourco/bpmn";
  protected static final String YOURCO_EXTENSIONS_PREFIX = "yourco";

  protected static final String ELEMENT_ATTRIBUTES = "attributes";
  protected static final String ELEMENT_ATTRIBUTE = "attribute";
  protected static final String ATTRIBUTE_NAME = "name";
  protected static final String ATTRIBUTE_VALUE = "value";

  protected static final String ELEMENT_I18LN_LOCALIZATION = "i18ln";
  protected static final String ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_NAME = "resourceBundleKeyForName";
  protected static final String ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION = "resourceBundleKeyForDescription";
  protected static final String ATTRIBUTE_LABELED_ENTITY_ID_FOR_NAME = "labeledEntityIdForName";
  protected static final String ATTRIBUTE_LABELED_ENTITY_ID_FOR_DESCRIPTION = "labeledEntityIdForDescription";

  private Localization localization = new Localization();

  /*
   * Inner class used to hold localization DataObject extension values
   */
  public class Localization {
    
    private String resourceBundleKeyForName;
    private String resourceBundleKeyForDescription;
    private String labeledEntityIdForName;
    private String labeledEntityIdForDescription;

    public String getResourceBundleKeyForName() {
      return resourceBundleKeyForName;
    }

    public void setResourceBundleKeyForName(String resourceBundleKeyForName) {
      this.resourceBundleKeyForName = resourceBundleKeyForName;
    }

    public String getResourceBundleKeyForDescription() {
      return resourceBundleKeyForDescription;
    }

    public void setResourceBundleKeyForDescription(String resourceBundleKeyForDescription) {
      this.resourceBundleKeyForDescription = resourceBundleKeyForDescription;
    }

    public String getLabeledEntityIdForName() {
      return labeledEntityIdForName;
    }

    public void setLabeledEntityIdForName(String labeledEntityIdForName) {
      this.labeledEntityIdForName = labeledEntityIdForName;
    }

    public String getLabeledEntityIdForDescription() {
      return labeledEntityIdForDescription;
    }

    public void setLabeledEntityIdForDescription(String labeledEntityIdForDescription) {
      this.labeledEntityIdForDescription = labeledEntityIdForDescription;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder(100);
      sb.append("Localization: [");
      sb.append("resourceBundleKeyForName=").append(resourceBundleKeyForName);
      sb.append(", resourceBundleKeyForDescription=").append(resourceBundleKeyForDescription);
      sb.append(", labeledEntityIdForName=").append(labeledEntityIdForName);
      sb.append(", labeledEntityIdForDescription=").append(labeledEntityIdForDescription);
      sb.append("]");
      return sb.toString();
    }
  }
  /*
   * End of inner classes
   */

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "subprocessmodel_with_extensions.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());
    
    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertTrue(subProcess.getLoopCharacteristics().isSequential());
    assertEquals("10", subProcess.getLoopCharacteristics().getLoopCardinality());
    assertEquals("${assignee == \"\"}", subProcess.getLoopCharacteristics().getCompletionCondition());
    assertTrue(subProcess.getFlowElements().size() == 5);
    
    /*
     * Verify Subprocess attributes extension
     */
    Map<String, String> attributes = getSubprocessAttributes(flowElement);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr3")) {
        assertTrue("3".equals(attributes.get(key)));
      } else if (key.equals("Attr4")) {
        assertTrue("4".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }

    /*
     * Verify Subprocess localization extension
     */
    localization = getLocalization(flowElement);
    assertEquals("rbkfn-2", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-2", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-2", localization.getLabeledEntityIdForName());
    assertEquals("leifd-2", localization.getLabeledEntityIdForDescription());
}

  protected static String getExtensionValue(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0).getElementText();
    }
    return null;
  }

  protected static ExtensionElement getExtensionElement(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0);
    }
    return null;
  }

  protected Map<String, String> getSubprocessAttributes(BaseElement bObj) {
    Map<String, String> attributes = null;

    if (null != bObj) {
      List<ExtensionElement> attributesExtension = bObj.getExtensionElements().get(ELEMENT_ATTRIBUTES);

      if (null != attributesExtension && !attributesExtension.isEmpty()) {
        attributes = new HashMap<String, String>();
        List<ExtensionElement> attributeExtensions =
                attributesExtension.get(0).getChildElements().get(ELEMENT_ATTRIBUTE);
        
        for (ExtensionElement attributeExtension : attributeExtensions) {
          attributes.put(attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_NAME),
                  attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_VALUE));
        }
      }
    }
    return attributes;
  }

  protected Localization getLocalization(BaseElement bObj) {
    List<ExtensionElement> i18lnExtension = bObj.getExtensionElements().get(ELEMENT_I18LN_LOCALIZATION);

    if (!i18lnExtension.isEmpty()) {
      Map<String, List<ExtensionAttribute>> extensionAttributes = i18lnExtension.get(0).getAttributes();
      localization.setLabeledEntityIdForName(extensionAttributes.get(ATTRIBUTE_LABELED_ENTITY_ID_FOR_NAME)
              .get(0).getValue());
      localization.setLabeledEntityIdForDescription(extensionAttributes.get(ATTRIBUTE_LABELED_ENTITY_ID_FOR_DESCRIPTION)
              .get(0).getValue());
      localization.setResourceBundleKeyForName(extensionAttributes.get(ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_NAME)
              .get(0).getValue());
      localization.setResourceBundleKeyForDescription(extensionAttributes.get(ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION)
              .get(0).getValue());
    }
    return localization;
  }
}
!@#$%
20190526_172024,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="https://activiti.atlassian.net/browse/ACT-2055">https://activiti.atlassian.net/browse/ACT-2055</a>
 */
public class SubProcessWithExtensionsConverterTest extends AbstractConverterTest {
  
  protected static final String YOURCO_EXTENSIONS_NAMESPACE = "http://yourco/bpmn";
  protected static final String YOURCO_EXTENSIONS_PREFIX = "yourco";

  protected static final String ELEMENT_ATTRIBUTES = "attributes";
  protected static final String ELEMENT_ATTRIBUTE = "attribute";
  protected static final String ATTRIBUTE_NAME = "name";
  protected static final String ATTRIBUTE_VALUE = "value";

  protected static final String ELEMENT_I18LN_LOCALIZATION = "i18ln";
  protected static final String ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_NAME = "resourceBundleKeyForName";
  protected static final String ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION = "resourceBundleKeyForDescription";
  protected static final String ATTRIBUTE_LABELED_ENTITY_ID_FOR_NAME = "labeledEntityIdForName";
  protected static final String ATTRIBUTE_LABELED_ENTITY_ID_FOR_DESCRIPTION = "labeledEntityIdForDescription";

  private Localization localization = new Localization();

  /*
   * Inner class used to hold localization DataObject extension values
   */
  public class Localization {
    
    private String resourceBundleKeyForName;
    private String resourceBundleKeyForDescription;
    private String labeledEntityIdForName;
    private String labeledEntityIdForDescription;

    public String getResourceBundleKeyForName() {
      return resourceBundleKeyForName;
    }

    public void setResourceBundleKeyForName(String resourceBundleKeyForName) {
      this.resourceBundleKeyForName = resourceBundleKeyForName;
    }

    public String getResourceBundleKeyForDescription() {
      return resourceBundleKeyForDescription;
    }

    public void setResourceBundleKeyForDescription(String resourceBundleKeyForDescription) {
      this.resourceBundleKeyForDescription = resourceBundleKeyForDescription;
    }

    public String getLabeledEntityIdForName() {
      return labeledEntityIdForName;
    }

    public void setLabeledEntityIdForName(String labeledEntityIdForName) {
      this.labeledEntityIdForName = labeledEntityIdForName;
    }

    public String getLabeledEntityIdForDescription() {
      return labeledEntityIdForDescription;
    }

    public void setLabeledEntityIdForDescription(String labeledEntityIdForDescription) {
      this.labeledEntityIdForDescription = labeledEntityIdForDescription;
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder(100);
      sb.append("Localization: [");
      sb.append("resourceBundleKeyForName=").append(resourceBundleKeyForName);
      sb.append(", resourceBundleKeyForDescription=").append(resourceBundleKeyForDescription);
      sb.append(", labeledEntityIdForName=").append(labeledEntityIdForName);
      sb.append(", labeledEntityIdForDescription=").append(labeledEntityIdForDescription);
      sb.append("]");
      return sb.toString();
    }
  }
  /*
   * End of inner classes
   */

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "subprocessmodel_with_extensions.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());
    
    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertTrue(subProcess.getLoopCharacteristics().isSequential());
    assertEquals("10", subProcess.getLoopCharacteristics().getLoopCardinality());
    assertEquals("${assignee == \"\"}", subProcess.getLoopCharacteristics().getCompletionCondition());
    assertTrue(subProcess.getFlowElements().size() == 5);
    
    /*
     * Verify Subprocess attributes extension
     */
    Map<String, String> attributes = getSubprocessAttributes(flowElement);
    assertEquals(2, attributes.size());
    for (String key : attributes.keySet()) {
      if (key.equals("Attr3")) {
        assertTrue("3".equals(attributes.get(key)));
      } else if (key.equals("Attr4")) {
        assertTrue("4".equals(attributes.get(key)));
      } else {
        fail("Unknown key value");
      }
    }

    /*
     * Verify Subprocess localization extension
     */
    localization = getLocalization(flowElement);
    assertEquals("rbkfn-2", localization.getResourceBundleKeyForName());
    assertEquals("rbkfd-2", localization.getResourceBundleKeyForDescription());
    assertEquals("leifn-2", localization.getLabeledEntityIdForName());
    assertEquals("leifd-2", localization.getLabeledEntityIdForDescription());
}

  protected static String getExtensionValue(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0).getElementText();
    }
    return null;
  }

  protected static ExtensionElement getExtensionElement(String key, ValuedDataObject dataObj) {
    Map<String, List<ExtensionElement>> extensionElements = dataObj.getExtensionElements();

    if (!extensionElements.isEmpty()) {
      return extensionElements.get(key).get(0);
    }
    return null;
  }

  protected Map<String, String> getSubprocessAttributes(BaseElement bObj) {
    Map<String, String> attributes = null;

    if (null != bObj) {
      List<ExtensionElement> attributesExtension = bObj.getExtensionElements().get(ELEMENT_ATTRIBUTES);

      if (null != attributesExtension && !attributesExtension.isEmpty()) {
        attributes = new HashMap<String, String>();
        List<ExtensionElement> attributeExtensions =
                attributesExtension.get(0).getChildElements().get(ELEMENT_ATTRIBUTE);
        
        for (ExtensionElement attributeExtension : attributeExtensions) {
          attributes.put(attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_NAME),
                  attributeExtension.getAttributeValue(YOURCO_EXTENSIONS_NAMESPACE, ATTRIBUTE_VALUE));
        }
      }
    }
    return attributes;
  }

  protected Localization getLocalization(BaseElement bObj) {
    List<ExtensionElement> i18lnExtension = bObj.getExtensionElements().get(ELEMENT_I18LN_LOCALIZATION);

    if (!i18lnExtension.isEmpty()) {
      Map<String, List<ExtensionAttribute>> extensionAttributes = i18lnExtension.get(0).getAttributes();
      localization.setLabeledEntityIdForName(extensionAttributes.get(ATTRIBUTE_LABELED_ENTITY_ID_FOR_NAME)
              .get(0).getValue());
      localization.setLabeledEntityIdForDescription(extensionAttributes.get(ATTRIBUTE_LABELED_ENTITY_ID_FOR_DESCRIPTION)
              .get(0).getValue());
      localization.setResourceBundleKeyForName(extensionAttributes.get(ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_NAME)
              .get(0).getValue());
      localization.setResourceBundleKeyForDescription(extensionAttributes.get(ATTRIBUTE_RESOURCE_BUNDLE_KEY_FOR_DESCRIPTION)
              .get(0).getValue());
    }
    return localization;
  }
}
!@#$%
20190526_172031,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.UserTask;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="https://activiti.atlassian.net/browse/ACT-1847">https://activiti.atlassian.net/browse/ACT-1847</a>
 */
public class DataObjectConverterTest extends AbstractConverterTest {

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }

  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }

  protected String getResource() {
    return "dataobjectmodel.bpmn";
  }

  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    // verify the main process data objects
    List<ValuedDataObject> dataObjects = model.getMainProcess().getDataObjects();
    assertEquals(7, dataObjects.size());

    Map<String, ValuedDataObject> objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    ValuedDataObject dataObj = objectMap.get("dObj1");
    assertEquals("dObj1", dataObj.getId());
    assertEquals("StringTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj2");
    assertEquals("BooleanTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj3");
    assertEquals("DateTest", dataObj.getName());
    assertEquals("xsd:datetime", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj4");
    assertEquals("DoubleTest", dataObj.getName());
    assertEquals("xsd:double", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj5");
    assertEquals("IntegerTest", dataObj.getName());
    assertEquals("xsd:int", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj6");
    assertEquals("LongTest", dataObj.getName());
    assertEquals("xsd:long", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObjWithoutType");
    assertEquals("UnknownTypeTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());

    flowElement = model.getMainProcess().getFlowElement("userTask1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof UserTask);
    assertEquals("userTask1", flowElement.getId());
    UserTask userTask = (UserTask) flowElement;
    assertEquals("kermit", userTask.getAssignee());

    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertEquals(11, subProcess.getFlowElements().size());

    // verify the sub process data objects
    dataObjects = subProcess.getDataObjects();
    assertEquals(6, dataObjects.size());

    objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }

    dataObj = objectMap.get("dObj7");
    assertEquals("dObj7", dataObj.getId());
    assertEquals("StringSubTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj8");
    assertEquals("dObj8", dataObj.getId());
    assertEquals("BooleanSubTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj9");
    assertEquals("dObj9", dataObj.getId());
    assertEquals("DateSubTest", dataObj.getName());
    assertEquals("xsd:datetime", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj10");
    assertEquals("dObj10", dataObj.getId());
    assertEquals("DoubleSubTest", dataObj.getName());
    assertEquals("xsd:double", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj11");
    assertEquals("dObj11", dataObj.getId());
    assertEquals("IntegerSubTest", dataObj.getName());
    assertEquals("xsd:int", dataObj.getItemSubjectRef().getStructureRef());

    dataObj = objectMap.get("dObj12");
    assertEquals("dObj12", dataObj.getId());
    assertEquals("LongSubTest", dataObj.getName());
    assertEquals("xsd:long", dataObj.getItemSubjectRef().getStructureRef());
  }
}
!@#$%
20190526_172031,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.UserTask;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="http://jira.codehaus.org/browse/ACT-1847">http://jira.codehaus.org/browse/ACT-1847</a>
 */
public class DataObjectConverterTest extends AbstractConverterTest {

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }
  
  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }
  
  protected String getResource() {
    return "dataobjectmodel.bpmn";
  }
  
  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    // verify the main process data objects
    List<ValuedDataObject> dataObjects = model.getMainProcess().getDataObjects();
    assertEquals(7, dataObjects.size());
    
    Map<String, ValuedDataObject> objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }
    
    ValuedDataObject dataObj = objectMap.get("dObj1");
    assertEquals("dObj1", dataObj.getId());
    assertEquals("StringTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj2");
    assertEquals("BooleanTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj3");
    assertEquals("DateTest", dataObj.getName());
    assertEquals("xsd:datetime", dataObj.getItemSubjectRef().getStructureRef());
   
    dataObj = objectMap.get("dObj4");
    assertEquals("DoubleTest", dataObj.getName());
    assertEquals("xsd:double", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj5");
    assertEquals("IntegerTest", dataObj.getName());
    assertEquals("xsd:int", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj6");
    assertEquals("LongTest", dataObj.getName());
    assertEquals("xsd:long", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObjWithoutType");
    assertEquals("UnknownTypeTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    
    flowElement = model.getMainProcess().getFlowElement("userTask1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof UserTask);
    assertEquals("userTask1", flowElement.getId());
    UserTask userTask = (UserTask) flowElement;
    assertEquals("kermit", userTask.getAssignee());
    
    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertEquals(11, subProcess.getFlowElements().size());

    // verify the sub process data objects
    dataObjects = subProcess.getDataObjects(); 
    assertEquals(6, dataObjects.size());
    
    objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }
    
    dataObj = objectMap.get("dObj7");
    assertEquals("dObj7", dataObj.getId());
    assertEquals("StringSubTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj8");
    assertEquals("dObj8", dataObj.getId());
    assertEquals("BooleanSubTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj9");
    assertEquals("dObj9", dataObj.getId());
    assertEquals("DateSubTest", dataObj.getName());
    assertEquals("xsd:datetime", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj10");
    assertEquals("dObj10", dataObj.getId());
    assertEquals("DoubleSubTest", dataObj.getName());
    assertEquals("xsd:double", dataObj.getItemSubjectRef().getStructureRef());
      
    dataObj = objectMap.get("dObj11");
    assertEquals("dObj11", dataObj.getId());
    assertEquals("IntegerSubTest", dataObj.getName());
    assertEquals("xsd:int", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj12");
    assertEquals("dObj12", dataObj.getId());
    assertEquals("LongSubTest", dataObj.getName());
    assertEquals("xsd:long", dataObj.getItemSubjectRef().getStructureRef());
  }
}
!@#$%
20190526_172031,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.editor.language.xml;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.StartEvent;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.UserTask;
import org.activiti.bpmn.model.ValuedDataObject;
import org.junit.Test;

/**
 * @see <a href="https://activiti.atlassian.net/browse/ACT-1847">https://activiti.atlassian.net/browse/ACT-1847</a>
 */
public class DataObjectConverterTest extends AbstractConverterTest {

  @Test
  public void convertXMLToModel() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    validateModel(bpmnModel);
  }
  
  @Test
  public void convertModelToXML() throws Exception {
    BpmnModel bpmnModel = readXMLFile();
    BpmnModel parsedModel = exportAndReadXMLFile(bpmnModel);
    validateModel(parsedModel);
    deployProcess(parsedModel);
  }
  
  protected String getResource() {
    return "dataobjectmodel.bpmn";
  }
  
  private void validateModel(BpmnModel model) {
    FlowElement flowElement = model.getMainProcess().getFlowElement("start1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof StartEvent);
    assertEquals("start1", flowElement.getId());

    // verify the main process data objects
    List<ValuedDataObject> dataObjects = model.getMainProcess().getDataObjects();
    assertEquals(7, dataObjects.size());
    
    Map<String, ValuedDataObject> objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }
    
    ValuedDataObject dataObj = objectMap.get("dObj1");
    assertEquals("dObj1", dataObj.getId());
    assertEquals("StringTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj2");
    assertEquals("BooleanTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj3");
    assertEquals("DateTest", dataObj.getName());
    assertEquals("xsd:datetime", dataObj.getItemSubjectRef().getStructureRef());
   
    dataObj = objectMap.get("dObj4");
    assertEquals("DoubleTest", dataObj.getName());
    assertEquals("xsd:double", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj5");
    assertEquals("IntegerTest", dataObj.getName());
    assertEquals("xsd:int", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj6");
    assertEquals("LongTest", dataObj.getName());
    assertEquals("xsd:long", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObjWithoutType");
    assertEquals("UnknownTypeTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    
    flowElement = model.getMainProcess().getFlowElement("userTask1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof UserTask);
    assertEquals("userTask1", flowElement.getId());
    UserTask userTask = (UserTask) flowElement;
    assertEquals("kermit", userTask.getAssignee());
    
    flowElement = model.getMainProcess().getFlowElement("subprocess1");
    assertNotNull(flowElement);
    assertTrue(flowElement instanceof SubProcess);
    assertEquals("subprocess1", flowElement.getId());
    SubProcess subProcess = (SubProcess) flowElement;
    assertEquals(11, subProcess.getFlowElements().size());

    // verify the sub process data objects
    dataObjects = subProcess.getDataObjects(); 
    assertEquals(6, dataObjects.size());
    
    objectMap = new HashMap<String, ValuedDataObject>();
    for (ValuedDataObject valueObj : dataObjects) {
      objectMap.put(valueObj.getId(), valueObj);
    }
    
    dataObj = objectMap.get("dObj7");
    assertEquals("dObj7", dataObj.getId());
    assertEquals("StringSubTest", dataObj.getName());
    assertEquals("xsd:string", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj8");
    assertEquals("dObj8", dataObj.getId());
    assertEquals("BooleanSubTest", dataObj.getName());
    assertEquals("xsd:boolean", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj9");
    assertEquals("dObj9", dataObj.getId());
    assertEquals("DateSubTest", dataObj.getName());
    assertEquals("xsd:datetime", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj10");
    assertEquals("dObj10", dataObj.getId());
    assertEquals("DoubleSubTest", dataObj.getName());
    assertEquals("xsd:double", dataObj.getItemSubjectRef().getStructureRef());
      
    dataObj = objectMap.get("dObj11");
    assertEquals("dObj11", dataObj.getId());
    assertEquals("IntegerSubTest", dataObj.getName());
    assertEquals("xsd:int", dataObj.getItemSubjectRef().getStructureRef());
    
    dataObj = objectMap.get("dObj12");
    assertEquals("dObj12", dataObj.getId());
    assertEquals("LongSubTest", dataObj.getName());
    assertEquals("xsd:long", dataObj.getItemSubjectRef().getStructureRef());
  }
}
!@#$%
20190526_172038,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.bpmn.converter.util;

import java.text.StringCharacterIterator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.converter.child.ActivitiEventListenerParser;
import org.activiti.bpmn.converter.child.ActivitiFailedjobRetryParser;
import org.activiti.bpmn.converter.child.ActivitiMapExceptionParser;
import org.activiti.bpmn.converter.child.BaseChildElementParser;
import org.activiti.bpmn.converter.child.CancelEventDefinitionParser;
import org.activiti.bpmn.converter.child.CompensateEventDefinitionParser;
import org.activiti.bpmn.converter.child.ConditionExpressionParser;
import org.activiti.bpmn.converter.child.DataInputAssociationParser;
import org.activiti.bpmn.converter.child.DataOutputAssociationParser;
import org.activiti.bpmn.converter.child.DataStateParser;
import org.activiti.bpmn.converter.child.DocumentationParser;
import org.activiti.bpmn.converter.child.ErrorEventDefinitionParser;
import org.activiti.bpmn.converter.child.ExecutionListenerParser;
import org.activiti.bpmn.converter.child.FieldExtensionParser;
import org.activiti.bpmn.converter.child.FlowNodeRefParser;
import org.activiti.bpmn.converter.child.FormPropertyParser;
import org.activiti.bpmn.converter.child.IOSpecificationParser;
import org.activiti.bpmn.converter.child.MessageEventDefinitionParser;
import org.activiti.bpmn.converter.child.MultiInstanceParser;
import org.activiti.bpmn.converter.child.SignalEventDefinitionParser;
import org.activiti.bpmn.converter.child.TaskListenerParser;
import org.activiti.bpmn.converter.child.TerminateEventDefinitionParser;
import org.activiti.bpmn.converter.child.TimeCycleParser;
import org.activiti.bpmn.converter.child.TimeDateParser;
import org.activiti.bpmn.converter.child.TimeDurationParser;
import org.activiti.bpmn.converter.child.TimerEventDefinitionParser;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.GraphicInfo;
import org.apache.commons.lang3.StringUtils;

public class BpmnXMLUtil implements BpmnXMLConstants {

  private static Map<String, BaseChildElementParser> genericChildParserMap = new HashMap<String, BaseChildElementParser>();

  static {
    addGenericParser(new ActivitiEventListenerParser());
    addGenericParser(new CancelEventDefinitionParser());
    addGenericParser(new CompensateEventDefinitionParser());
    addGenericParser(new ConditionExpressionParser());
    addGenericParser(new DataInputAssociationParser());
    addGenericParser(new DataOutputAssociationParser());
    addGenericParser(new DataStateParser());
    addGenericParser(new DocumentationParser());
    addGenericParser(new ErrorEventDefinitionParser());
    addGenericParser(new ExecutionListenerParser());
    addGenericParser(new FieldExtensionParser());
    addGenericParser(new FormPropertyParser());
    addGenericParser(new IOSpecificationParser());
    addGenericParser(new MessageEventDefinitionParser());
    addGenericParser(new MultiInstanceParser());
    addGenericParser(new SignalEventDefinitionParser());
    addGenericParser(new TaskListenerParser());
    addGenericParser(new TerminateEventDefinitionParser());
    addGenericParser(new TimerEventDefinitionParser());
    addGenericParser(new TimeDateParser());
    addGenericParser(new TimeCycleParser());
    addGenericParser(new TimeDurationParser());
    addGenericParser(new FlowNodeRefParser());
    addGenericParser(new ActivitiFailedjobRetryParser());
    addGenericParser(new ActivitiMapExceptionParser());
  }

  private static void addGenericParser(BaseChildElementParser parser) {
    genericChildParserMap.put(parser.getElementName(), parser);
  }

  public static void addXMLLocation(BaseElement element, XMLStreamReader xtr) {
    Location location = xtr.getLocation();
    element.setXmlRowNumber(location.getLineNumber());
    element.setXmlColumnNumber(location.getColumnNumber());
  }

  public static void addXMLLocation(GraphicInfo graphicInfo, XMLStreamReader xtr) {
    Location location = xtr.getLocation();
    graphicInfo.setXmlRowNumber(location.getLineNumber());
    graphicInfo.setXmlColumnNumber(location.getColumnNumber());
  }

  public static void parseChildElements(String elementName, BaseElement parentElement, XMLStreamReader xtr, BpmnModel model) throws Exception {
    parseChildElements(elementName, parentElement, xtr, null, model);
  }

  public static void parseChildElements(String elementName, BaseElement parentElement, XMLStreamReader xtr, 
      Map<String, BaseChildElementParser> childParsers, BpmnModel model) throws Exception {
    
    Map<String, BaseChildElementParser> localParserMap =
        new HashMap<String, BaseChildElementParser>(genericChildParserMap);
    if (childParsers != null) {
      localParserMap.putAll(childParsers);
    }

    boolean inExtensionElements = false;
    boolean readyWithChildElements = false;
    while (readyWithChildElements == false && xtr.hasNext()) {
      xtr.next();
      if (xtr.isStartElement()) {
        if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          inExtensionElements = true;
        } else if (localParserMap.containsKey(xtr.getLocalName())) {
          BaseChildElementParser childParser = localParserMap.get(xtr.getLocalName());
          //if we're into an extension element but the current element is not accepted by this parentElement then is read as a custom extension element
          if (inExtensionElements && !childParser.accepts(parentElement)) {
            ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
            parentElement.addExtensionElement(extensionElement);
            continue;
          }
          localParserMap.get(xtr.getLocalName()).parseChildElement(xtr, parentElement, model);
        } else if (inExtensionElements) {
          ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
          parentElement.addExtensionElement(extensionElement);
        }

      } else if (xtr.isEndElement()) {
        if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          inExtensionElements = false;
        } else if (elementName.equalsIgnoreCase(xtr.getLocalName())) {
          readyWithChildElements = true;
        }
      }
    }
  }

  public static ExtensionElement parseExtensionElement(XMLStreamReader xtr) throws Exception {
    ExtensionElement extensionElement = new ExtensionElement();
    extensionElement.setName(xtr.getLocalName());
    if (StringUtils.isNotEmpty(xtr.getNamespaceURI())) {
      extensionElement.setNamespace(xtr.getNamespaceURI());
    }
    if (StringUtils.isNotEmpty(xtr.getPrefix())) {
      extensionElement.setNamespacePrefix(xtr.getPrefix());
    }

    for (int i = 0; i < xtr.getAttributeCount(); i++) {
      ExtensionAttribute extensionAttribute = new ExtensionAttribute();
      extensionAttribute.setName(xtr.getAttributeLocalName(i));
      extensionAttribute.setValue(xtr.getAttributeValue(i));
      if (StringUtils.isNotEmpty(xtr.getAttributeNamespace(i))) {
        extensionAttribute.setNamespace(xtr.getAttributeNamespace(i));
      }
      if (StringUtils.isNotEmpty(xtr.getAttributePrefix(i))) {
        extensionAttribute.setNamespacePrefix(xtr.getAttributePrefix(i));
      }
      extensionElement.addAttribute(extensionAttribute);
    }

    boolean readyWithExtensionElement = false;
    while (readyWithExtensionElement == false && xtr.hasNext()) {
      xtr.next();
      if (xtr.isCharacters() || XMLStreamReader.CDATA == xtr.getEventType()) {
        if (StringUtils.isNotEmpty(xtr.getText().trim())) {
          extensionElement.setElementText(xtr.getText().trim());
        }
      } else if (xtr.isStartElement()) {
        ExtensionElement childExtensionElement = parseExtensionElement(xtr);
        extensionElement.addChildElement(childExtensionElement);
      } else if (xtr.isEndElement() && extensionElement.getName().equalsIgnoreCase(xtr.getLocalName())) {
        readyWithExtensionElement = true;
      }
    }
    return extensionElement;
  }

  public static void writeDefaultAttribute(String attributeName, String value, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(value) && "null".equalsIgnoreCase(value) == false) {
      xtw.writeAttribute(attributeName, value);
    }
  }

  public static void writeQualifiedAttribute(String attributeName, String value, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(value)) {
      xtw.writeAttribute(ACTIVITI_EXTENSIONS_PREFIX, ACTIVITI_EXTENSIONS_NAMESPACE, attributeName, value);
    }
  }

  public static boolean writeExtensionElements(BaseElement baseElement, boolean didWriteExtensionStartElement, XMLStreamWriter xtw) throws Exception {
    return didWriteExtensionStartElement = writeExtensionElements(baseElement, didWriteExtensionStartElement, null, xtw);
  }

  public static boolean writeExtensionElements(BaseElement baseElement, boolean didWriteExtensionStartElement, Map<String, String> namespaceMap, XMLStreamWriter xtw) throws Exception {
    if (!baseElement.getExtensionElements().isEmpty()) {
      if (didWriteExtensionStartElement == false) {
        xtw.writeStartElement(ELEMENT_EXTENSIONS);
        didWriteExtensionStartElement = true;
      }

      if (namespaceMap == null) {
        namespaceMap = new HashMap<String, String>();
      }

      for (List<ExtensionElement> extensionElements : baseElement.getExtensionElements().values()) {
        for (ExtensionElement extensionElement : extensionElements) {
          writeExtensionElement(extensionElement, namespaceMap, xtw);
        }
      }
    }
    return didWriteExtensionStartElement;
  }

  protected static void writeExtensionElement(ExtensionElement extensionElement, Map<String, String> namespaceMap, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(extensionElement.getName())) {
      Map<String, String> localNamespaceMap = new HashMap<String, String>();
      if (StringUtils.isNotEmpty(extensionElement.getNamespace())) {
        if (StringUtils.isNotEmpty(extensionElement.getNamespacePrefix())) {
          xtw.writeStartElement(extensionElement.getNamespacePrefix(), extensionElement.getName(), extensionElement.getNamespace());

          if (namespaceMap.containsKey(extensionElement.getNamespacePrefix()) == false || namespaceMap.get(extensionElement.getNamespacePrefix()).equals(extensionElement.getNamespace()) == false) {

            xtw.writeNamespace(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
            namespaceMap.put(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
            localNamespaceMap.put(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
          }
        } else {
          xtw.writeStartElement(extensionElement.getNamespace(), extensionElement.getName());
        }
      } else {
        xtw.writeStartElement(extensionElement.getName());
      }

      for (List<ExtensionAttribute> attributes : extensionElement.getAttributes().values()) {
        for (ExtensionAttribute attribute : attributes) {
          if (StringUtils.isNotEmpty(attribute.getName()) && attribute.getValue() != null) {
            if (StringUtils.isNotEmpty(attribute.getNamespace())) {
              if (StringUtils.isNotEmpty(attribute.getNamespacePrefix())) {

                if (namespaceMap.containsKey(attribute.getNamespacePrefix()) == false || namespaceMap.get(attribute.getNamespacePrefix()).equals(attribute.getNamespace()) == false) {

                  xtw.writeNamespace(attribute.getNamespacePrefix(), attribute.getNamespace());
                  namespaceMap.put(attribute.getNamespacePrefix(), attribute.getNamespace());
                }

                xtw.writeAttribute(attribute.getNamespacePrefix(), attribute.getNamespace(), attribute.getName(), attribute.getValue());
              } else {
                xtw.writeAttribute(attribute.getNamespace(), attribute.getName(), attribute.getValue());
              }
            } else {
              xtw.writeAttribute(attribute.getName(), attribute.getValue());
            }
          }
        }
      }

      if (extensionElement.getElementText() != null) {
        xtw.writeCData(extensionElement.getElementText());
      } else {
        for (List<ExtensionElement> childElements : extensionElement.getChildElements().values()) {
          for (ExtensionElement childElement : childElements) {
            writeExtensionElement(childElement, namespaceMap, xtw);
          }
        }
      }

      for (String prefix : localNamespaceMap.keySet()) {
        namespaceMap.remove(prefix);
      }

      xtw.writeEndElement();
    }
  }

  public static List<String> parseDelimitedList(String s) {
    List<String> result = new ArrayList<String>();
    if (StringUtils.isNotEmpty(s)) {

      StringCharacterIterator iterator = new StringCharacterIterator(s);
      char c = iterator.first();

      StringBuilder strb = new StringBuilder();
      boolean insideExpression = false;

      while (c != StringCharacterIterator.DONE) {
        if (c == '{' || c == '$') {
          insideExpression = true;
        } else if (c == '}') {
          insideExpression = false;
        } else if (c == ',' && !insideExpression) {
          result.add(strb.toString().trim());
          strb.delete(0, strb.length());
        }

        if (c != ',' || (insideExpression)) {
          strb.append(c);
        }

        c = iterator.next();
      }

      if (strb.length() > 0) {
        result.add(strb.toString().trim());
      }

    }
    return result;
  }

  public static String convertToDelimitedString(List<String> stringList) {
    StringBuilder resultString = new StringBuilder();

    if (stringList != null) {
      for (String result : stringList) {
        if (resultString.length() > 0) {
          resultString.append(",");
        }
        resultString.append(result);
      }
    }
    return resultString.toString();
  }

  /**
   * add all attributes from XML to element extensionAttributes (except blackListed).
   * 
   * @param xtr
   * @param element
   * @param blackList
   */
  public static void addCustomAttributes(XMLStreamReader xtr, BaseElement element, List<ExtensionAttribute>... blackLists) {
    for (int i = 0; i < xtr.getAttributeCount(); i++) {
      ExtensionAttribute extensionAttribute = new ExtensionAttribute();
      extensionAttribute.setName(xtr.getAttributeLocalName(i));
      extensionAttribute.setValue(xtr.getAttributeValue(i));
      if (StringUtils.isNotEmpty(xtr.getAttributeNamespace(i))) {
        extensionAttribute.setNamespace(xtr.getAttributeNamespace(i));
      }
      if (StringUtils.isNotEmpty(xtr.getAttributePrefix(i))) {
        extensionAttribute.setNamespacePrefix(xtr.getAttributePrefix(i));
      }
      if (!isBlacklisted(extensionAttribute, blackLists)) {
        element.addAttribute(extensionAttribute);
      }
    }
  }

  public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes, XMLStreamWriter xtw, List<ExtensionAttribute>... blackLists) throws XMLStreamException {
    writeCustomAttributes(attributes, xtw, new LinkedHashMap<String, String>(), blackLists);
  }

  /**
   * write attributes to xtw (except blacklisted)
   * 
   * @param attributes
   * @param xtw
   * @param blackList
   */
  public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes, XMLStreamWriter xtw, Map<String, String> namespaceMap, List<ExtensionAttribute>... blackLists)
      throws XMLStreamException {

    for (List<ExtensionAttribute> attributeList : attributes) {
      if (attributeList != null && !attributeList.isEmpty()) {
        for (ExtensionAttribute attribute : attributeList) {
          if (!isBlacklisted(attribute, blackLists)) {
            if (attribute.getNamespacePrefix() == null) {
              if (attribute.getNamespace() == null)
                xtw.writeAttribute(attribute.getName(), attribute.getValue());
              else {
                xtw.writeAttribute(attribute.getNamespace(), attribute.getName(), attribute.getValue());
              }
            } else {
              if (!namespaceMap.containsKey(attribute.getNamespacePrefix())) {
                namespaceMap.put(attribute.getNamespacePrefix(), attribute.getNamespace());
                xtw.writeNamespace(attribute.getNamespacePrefix(), attribute.getNamespace());
              }
              xtw.writeAttribute(attribute.getNamespacePrefix(), attribute.getNamespace(), attribute.getName(), attribute.getValue());
            }
          }
        }
      }
    }
  }

  public static boolean isBlacklisted(ExtensionAttribute attribute, List<ExtensionAttribute>... blackLists) {
    if (blackLists != null) {
      for (List<ExtensionAttribute> blackList : blackLists) {
        for (ExtensionAttribute blackAttribute : blackList) {
          if (blackAttribute.getName().equals(attribute.getName())) {
            if (blackAttribute.getNamespace() != null && attribute.getNamespace() != null && blackAttribute.getNamespace().equals(attribute.getNamespace()))
              return true;
            if (blackAttribute.getNamespace() == null && attribute.getNamespace() == null)
              return true;
          }
        }
      }
    }
    return false;
  }
}
!@#$%
20190526_172038,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.bpmn.converter.util;

import java.text.StringCharacterIterator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.converter.child.ActivitiEventListenerParser;
import org.activiti.bpmn.converter.child.ActivitiFailedjobRetryParser;
import org.activiti.bpmn.converter.child.ActivitiMapExceptionParser;
import org.activiti.bpmn.converter.child.BaseChildElementParser;
import org.activiti.bpmn.converter.child.CancelEventDefinitionParser;
import org.activiti.bpmn.converter.child.CompensateEventDefinitionParser;
import org.activiti.bpmn.converter.child.ConditionExpressionParser;
import org.activiti.bpmn.converter.child.DataInputAssociationParser;
import org.activiti.bpmn.converter.child.DataOutputAssociationParser;
import org.activiti.bpmn.converter.child.DataStateParser;
import org.activiti.bpmn.converter.child.DocumentationParser;
import org.activiti.bpmn.converter.child.ErrorEventDefinitionParser;
import org.activiti.bpmn.converter.child.ExecutionListenerParser;
import org.activiti.bpmn.converter.child.FieldExtensionParser;
import org.activiti.bpmn.converter.child.FlowNodeRefParser;
import org.activiti.bpmn.converter.child.FormPropertyParser;
import org.activiti.bpmn.converter.child.IOSpecificationParser;
import org.activiti.bpmn.converter.child.MessageEventDefinitionParser;
import org.activiti.bpmn.converter.child.MultiInstanceParser;
import org.activiti.bpmn.converter.child.SignalEventDefinitionParser;
import org.activiti.bpmn.converter.child.TaskListenerParser;
import org.activiti.bpmn.converter.child.TerminateEventDefinitionParser;
import org.activiti.bpmn.converter.child.TimeCycleParser;
import org.activiti.bpmn.converter.child.TimeDateParser;
import org.activiti.bpmn.converter.child.TimeDurationParser;
import org.activiti.bpmn.converter.child.TimerEventDefinitionParser;
import org.activiti.bpmn.converter.export.ProcessExport;
import org.activiti.bpmn.model.*;
import org.apache.commons.lang3.StringUtils;

public class BpmnXMLUtil implements BpmnXMLConstants {
  
  private static Map<String, BaseChildElementParser> genericChildParserMap = new HashMap<String, BaseChildElementParser>();
  
  static {
    addGenericParser(new ActivitiEventListenerParser());
    addGenericParser(new CancelEventDefinitionParser());
    addGenericParser(new CompensateEventDefinitionParser());
    addGenericParser(new ConditionExpressionParser());
    addGenericParser(new DataInputAssociationParser());
    addGenericParser(new DataOutputAssociationParser());
    addGenericParser(new DataStateParser());
    addGenericParser(new DocumentationParser());
    addGenericParser(new ErrorEventDefinitionParser());
    addGenericParser(new ExecutionListenerParser());
    addGenericParser(new FieldExtensionParser());
    addGenericParser(new FormPropertyParser());
    addGenericParser(new IOSpecificationParser());
    addGenericParser(new MessageEventDefinitionParser());
    addGenericParser(new MultiInstanceParser());
    addGenericParser(new SignalEventDefinitionParser());
    addGenericParser(new TaskListenerParser());
    addGenericParser(new TerminateEventDefinitionParser());
    addGenericParser(new TimerEventDefinitionParser());
    addGenericParser(new TimeDateParser());
    addGenericParser(new TimeCycleParser());
    addGenericParser(new TimeDurationParser());
    addGenericParser(new FlowNodeRefParser());
    addGenericParser(new ActivitiFailedjobRetryParser());
    addGenericParser(new ActivitiMapExceptionParser());
  }
  
  private static void addGenericParser(BaseChildElementParser parser) {
    genericChildParserMap.put(parser.getElementName(), parser);
  }

  public static void addXMLLocation(BaseElement element, XMLStreamReader xtr) {
    Location location = xtr.getLocation();
    element.setXmlRowNumber(location.getLineNumber());
    element.setXmlColumnNumber(location.getColumnNumber());
  }
  
  public static void addXMLLocation(GraphicInfo graphicInfo, XMLStreamReader xtr) {
    Location location = xtr.getLocation();
    graphicInfo.setXmlRowNumber(location.getLineNumber());
    graphicInfo.setXmlColumnNumber(location.getColumnNumber());
  }
  
  public static void parseChildElements(String elementName, BaseElement parentElement, XMLStreamReader xtr, BpmnModel model) throws Exception {
    parseChildElements(elementName, parentElement, xtr, null, model); 
  }
  
  public static void parseChildElements(String elementName, BaseElement parentElement, XMLStreamReader xtr, 
      Map<String, BaseChildElementParser> childParsers, BpmnModel model) throws Exception {
    
    Map<String, BaseChildElementParser> localParserMap =
        new HashMap<String, BaseChildElementParser>(genericChildParserMap);
    if (childParsers != null) {
      localParserMap.putAll(childParsers);
    }

    boolean inExtensionElements = false;
    boolean readyWithChildElements = false;
    while (readyWithChildElements == false && xtr.hasNext()) {
      xtr.next();
      if (xtr.isStartElement()) {
        if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          inExtensionElements = true;
        } else if (localParserMap.containsKey(xtr.getLocalName())) {
          BaseChildElementParser childParser = localParserMap.get(xtr.getLocalName());
          //if we're into an extension element but the current element is not accepted by this parentElement then is read as a custom extension element
          if (inExtensionElements && !childParser.accepts(parentElement)) {
            ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
            parentElement.addExtensionElement(extensionElement);
            continue;
          }
          localParserMap.get(xtr.getLocalName()).parseChildElement(xtr, parentElement, model);
        } else if (inExtensionElements) {
          ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
          parentElement.addExtensionElement(extensionElement);
        }

      } else if (xtr.isEndElement()) {
        if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          inExtensionElements = false;
        } else if (elementName.equalsIgnoreCase(xtr.getLocalName())) {
          readyWithChildElements = true;
        }
      }
    }
  }
  
  public static ExtensionElement parseExtensionElement(XMLStreamReader xtr) throws Exception {
    ExtensionElement extensionElement = new ExtensionElement();
    extensionElement.setName(xtr.getLocalName());
    if (StringUtils.isNotEmpty(xtr.getNamespaceURI())) {
      extensionElement.setNamespace(xtr.getNamespaceURI());
    }
    if (StringUtils.isNotEmpty(xtr.getPrefix())) {
      extensionElement.setNamespacePrefix(xtr.getPrefix());
    }
    
    for (int i = 0; i < xtr.getAttributeCount(); i++) {
      ExtensionAttribute extensionAttribute = new ExtensionAttribute();
      extensionAttribute.setName(xtr.getAttributeLocalName(i));
      extensionAttribute.setValue(xtr.getAttributeValue(i));
      if (StringUtils.isNotEmpty(xtr.getAttributeNamespace(i))) {
        extensionAttribute.setNamespace(xtr.getAttributeNamespace(i));
      }
      if (StringUtils.isNotEmpty(xtr.getAttributePrefix(i))) {
        extensionAttribute.setNamespacePrefix(xtr.getAttributePrefix(i));
      }
      extensionElement.addAttribute(extensionAttribute);
    }
    
    boolean readyWithExtensionElement = false;
    while (readyWithExtensionElement == false && xtr.hasNext()) {
      xtr.next();
      if (xtr.isCharacters() || XMLStreamReader.CDATA == xtr.getEventType()) {
        if (StringUtils.isNotEmpty(xtr.getText().trim())) {
          extensionElement.setElementText(xtr.getText().trim());
        }
      } else if (xtr.isStartElement()) {
        ExtensionElement childExtensionElement = parseExtensionElement(xtr);
        extensionElement.addChildElement(childExtensionElement);
      } else if (xtr.isEndElement() && extensionElement.getName().equalsIgnoreCase(xtr.getLocalName())) {
        readyWithExtensionElement = true;
      }
    }
    return extensionElement;
  }
  
  public static void writeDefaultAttribute(String attributeName, String value, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(value) && "null".equalsIgnoreCase(value) == false) {
      xtw.writeAttribute(attributeName, value);
    }
  }
  
  public static void writeQualifiedAttribute(String attributeName, String value, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(value)) {
      xtw.writeAttribute(ACTIVITI_EXTENSIONS_PREFIX, ACTIVITI_EXTENSIONS_NAMESPACE, attributeName, value);
    }
  }
  
  public static boolean writeExtensionElements(BaseElement baseElement, boolean didWriteExtensionStartElement, XMLStreamWriter xtw) throws Exception {
    return didWriteExtensionStartElement = writeExtensionElements(baseElement, didWriteExtensionStartElement, null, xtw);
  }
 
  public static boolean writeExtensionElements(BaseElement baseElement, boolean didWriteExtensionStartElement, Map<String, String> namespaceMap, XMLStreamWriter xtw) throws Exception {
    if (!baseElement.getExtensionElements().isEmpty()) {
      if (didWriteExtensionStartElement == false) {
        xtw.writeStartElement(ELEMENT_EXTENSIONS);
        didWriteExtensionStartElement = true;
      }
      
      if (namespaceMap == null) {
        namespaceMap = new HashMap<String, String>();
      }
      
      for (List<ExtensionElement> extensionElements : baseElement.getExtensionElements().values()) {
        for (ExtensionElement extensionElement : extensionElements) {
          writeExtensionElement(extensionElement, namespaceMap, xtw);
        }
      }
    }
    return didWriteExtensionStartElement;
  }
  
  protected static void writeExtensionElement(ExtensionElement extensionElement, Map<String, String> namespaceMap, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(extensionElement.getName())) {
      Map<String, String> localNamespaceMap = new HashMap<String, String>();
      if (StringUtils.isNotEmpty(extensionElement.getNamespace())) {
        if (StringUtils.isNotEmpty(extensionElement.getNamespacePrefix())) {
          xtw.writeStartElement(extensionElement.getNamespacePrefix(), extensionElement.getName(), extensionElement.getNamespace());
          
          if (namespaceMap.containsKey(extensionElement.getNamespacePrefix()) == false ||
              namespaceMap.get(extensionElement.getNamespacePrefix()).equals(extensionElement.getNamespace()) == false) {
            
            xtw.writeNamespace(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
            namespaceMap.put(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
            localNamespaceMap.put(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
          }
        } else {
          xtw.writeStartElement(extensionElement.getNamespace(), extensionElement.getName());
        }
      } else {
        xtw.writeStartElement(extensionElement.getName());
      }
      
      for (List<ExtensionAttribute> attributes : extensionElement.getAttributes().values()) {
        for (ExtensionAttribute attribute : attributes) {
          if (StringUtils.isNotEmpty(attribute.getName()) && attribute.getValue() != null) {
            if (StringUtils.isNotEmpty(attribute.getNamespace())) {
              if (StringUtils.isNotEmpty(attribute.getNamespacePrefix())) {
                
                if (namespaceMap.containsKey(attribute.getNamespacePrefix()) == false ||
                    namespaceMap.get(attribute.getNamespacePrefix()).equals(attribute.getNamespace()) == false) {
                  
                  xtw.writeNamespace(attribute.getNamespacePrefix(), attribute.getNamespace());
                  namespaceMap.put(attribute.getNamespacePrefix(), attribute.getNamespace());
                }
                
                xtw.writeAttribute(attribute.getNamespacePrefix(), attribute.getNamespace(), attribute.getName(), attribute.getValue());
              } else {
                xtw.writeAttribute(attribute.getNamespace(), attribute.getName(), attribute.getValue());
              }
            } else {
              xtw.writeAttribute(attribute.getName(), attribute.getValue());
            }
          }
        }
      }
      
      if (extensionElement.getElementText() != null) {
        xtw.writeCharacters(extensionElement.getElementText());
      } else {
        for (List<ExtensionElement> childElements : extensionElement.getChildElements().values()) {
          for (ExtensionElement childElement : childElements) {
            writeExtensionElement(childElement, namespaceMap, xtw);
          }
        }
      }
      
      for (String prefix : localNamespaceMap.keySet()) {
        namespaceMap.remove(prefix);
      }
      
      xtw.writeEndElement();
    }
  }
  
  public static List<String> parseDelimitedList(String s) {
    List<String> result = new ArrayList<String>();
    if (StringUtils.isNotEmpty(s)) {

      StringCharacterIterator iterator = new StringCharacterIterator(s);
      char c = iterator.first();

      StringBuilder strb = new StringBuilder();
      boolean insideExpression = false;

      while (c != StringCharacterIterator.DONE) {
        if (c == '{' || c == '$') {
          insideExpression = true;
        } else if (c == '}') {
          insideExpression = false;
        } else if (c == ',' && !insideExpression) {
          result.add(strb.toString().trim());
          strb.delete(0, strb.length());
        }

        if (c != ',' || (insideExpression)) {
          strb.append(c);
        }

        c = iterator.next();
      }

      if (strb.length() > 0) {
        result.add(strb.toString().trim());
      }

    }
    return result;
  }
  
  public static String convertToDelimitedString(List<String> stringList) {
    StringBuilder resultString = new StringBuilder();
    
    if(stringList != null) {
    	for (String result : stringList) {
    		if (resultString.length() > 0) {
    			resultString.append(",");
    		}
    		resultString.append(result);
    	}
    }
    return resultString.toString();
  }

  /**
   * add all attributes from XML to element extensionAttributes (except blackListed).
   *
   * @param xtr
   * @param element
   * @param blackList
   */
  public static void addCustomAttributes(XMLStreamReader xtr, BaseElement element, List<ExtensionAttribute>... blackLists) {
    for (int i = 0; i < xtr.getAttributeCount(); i++) {
      ExtensionAttribute extensionAttribute = new ExtensionAttribute();
      extensionAttribute.setName(xtr.getAttributeLocalName(i));
      extensionAttribute.setValue(xtr.getAttributeValue(i));
      if (StringUtils.isNotEmpty(xtr.getAttributeNamespace(i))) {
        extensionAttribute.setNamespace(xtr.getAttributeNamespace(i));
      }
      if (StringUtils.isNotEmpty(xtr.getAttributePrefix(i))) {
        extensionAttribute.setNamespacePrefix(xtr.getAttributePrefix(i));
      }
      if (!isBlacklisted(extensionAttribute, blackLists)) {
        element.addAttribute(extensionAttribute);
      }
    }
  }

  public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes, XMLStreamWriter xtw, List<ExtensionAttribute>... blackLists) throws XMLStreamException {
    writeCustomAttributes(attributes, xtw, new LinkedHashMap<String, String>(), blackLists);
  }
  
  /**
   * write attributes to xtw (except blacklisted)
   * @param attributes
   * @param xtw
   * @param blackList
   */
  public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes, XMLStreamWriter xtw, Map<String, String> namespaceMap,
      List<ExtensionAttribute>... blackLists) throws XMLStreamException {
    
    for (List<ExtensionAttribute> attributeList : attributes) {
      if (attributeList != null && !attributeList.isEmpty()) {
        for (ExtensionAttribute attribute : attributeList) {
          if (!isBlacklisted(attribute, blackLists)) {
            if (attribute.getNamespacePrefix() == null) {
              if (attribute.getNamespace() == null)
                xtw.writeAttribute(attribute.getName(), attribute.getValue());
              else {
                xtw.writeAttribute(attribute.getNamespace(), attribute.getName(), attribute.getValue());
              }
            } else {
              if (!namespaceMap.containsKey(attribute.getNamespacePrefix())) {
                namespaceMap.put(attribute.getNamespacePrefix(), attribute.getNamespace());
                xtw.writeNamespace(attribute.getNamespacePrefix(), attribute.getNamespace());
              }
              xtw.writeAttribute(attribute.getNamespacePrefix(), attribute.getNamespace(),
                  attribute.getName(), attribute.getValue());
            }
          }
        }
      }
    }
  }

  public static boolean isBlacklisted(ExtensionAttribute attribute, List<ExtensionAttribute>... blackLists) {
    if (blackLists != null) {
      for (List<ExtensionAttribute> blackList : blackLists) {
        for (ExtensionAttribute blackAttribute : blackList) {
          if (blackAttribute.getName().equals(attribute.getName())) {
            if ( blackAttribute.getNamespace() != null && attribute.getNamespace() != null
                && blackAttribute.getNamespace().equals(attribute.getNamespace()))
              return true;
            if (blackAttribute.getNamespace() == null && attribute.getNamespace() == null)
              return true;
          }
        }
      }
    }
    return false;
  }
}
!@#$%
20190526_172038,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.bpmn.converter.util;

import java.text.StringCharacterIterator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.converter.child.ActivitiEventListenerParser;
import org.activiti.bpmn.converter.child.ActivitiFailedjobRetryParser;
import org.activiti.bpmn.converter.child.ActivitiMapExceptionParser;
import org.activiti.bpmn.converter.child.BaseChildElementParser;
import org.activiti.bpmn.converter.child.CancelEventDefinitionParser;
import org.activiti.bpmn.converter.child.CompensateEventDefinitionParser;
import org.activiti.bpmn.converter.child.ConditionExpressionParser;
import org.activiti.bpmn.converter.child.DataInputAssociationParser;
import org.activiti.bpmn.converter.child.DataOutputAssociationParser;
import org.activiti.bpmn.converter.child.DataStateParser;
import org.activiti.bpmn.converter.child.DocumentationParser;
import org.activiti.bpmn.converter.child.ErrorEventDefinitionParser;
import org.activiti.bpmn.converter.child.ExecutionListenerParser;
import org.activiti.bpmn.converter.child.FieldExtensionParser;
import org.activiti.bpmn.converter.child.FlowNodeRefParser;
import org.activiti.bpmn.converter.child.FormPropertyParser;
import org.activiti.bpmn.converter.child.IOSpecificationParser;
import org.activiti.bpmn.converter.child.MessageEventDefinitionParser;
import org.activiti.bpmn.converter.child.MultiInstanceParser;
import org.activiti.bpmn.converter.child.SignalEventDefinitionParser;
import org.activiti.bpmn.converter.child.TaskListenerParser;
import org.activiti.bpmn.converter.child.TerminateEventDefinitionParser;
import org.activiti.bpmn.converter.child.TimeCycleParser;
import org.activiti.bpmn.converter.child.TimeDateParser;
import org.activiti.bpmn.converter.child.TimeDurationParser;
import org.activiti.bpmn.converter.child.TimerEventDefinitionParser;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ExtensionAttribute;
import org.activiti.bpmn.model.ExtensionElement;
import org.activiti.bpmn.model.GraphicInfo;
import org.apache.commons.lang3.StringUtils;

public class BpmnXMLUtil implements BpmnXMLConstants {
  
  private static Map<String, BaseChildElementParser> genericChildParserMap = new HashMap<String, BaseChildElementParser>();
  
  static {
    addGenericParser(new ActivitiEventListenerParser());
    addGenericParser(new CancelEventDefinitionParser());
    addGenericParser(new CompensateEventDefinitionParser());
    addGenericParser(new ConditionExpressionParser());
    addGenericParser(new DataInputAssociationParser());
    addGenericParser(new DataOutputAssociationParser());
    addGenericParser(new DataStateParser());
    addGenericParser(new DocumentationParser());
    addGenericParser(new ErrorEventDefinitionParser());
    addGenericParser(new ExecutionListenerParser());
    addGenericParser(new FieldExtensionParser());
    addGenericParser(new FormPropertyParser());
    addGenericParser(new IOSpecificationParser());
    addGenericParser(new MessageEventDefinitionParser());
    addGenericParser(new MultiInstanceParser());
    addGenericParser(new SignalEventDefinitionParser());
    addGenericParser(new TaskListenerParser());
    addGenericParser(new TerminateEventDefinitionParser());
    addGenericParser(new TimerEventDefinitionParser());
    addGenericParser(new TimeDateParser());
    addGenericParser(new TimeCycleParser());
    addGenericParser(new TimeDurationParser());
    addGenericParser(new FlowNodeRefParser());
    addGenericParser(new ActivitiFailedjobRetryParser());
    addGenericParser(new ActivitiMapExceptionParser());
  }
  
  private static void addGenericParser(BaseChildElementParser parser) {
    genericChildParserMap.put(parser.getElementName(), parser);
  }

  public static void addXMLLocation(BaseElement element, XMLStreamReader xtr) {
    Location location = xtr.getLocation();
    element.setXmlRowNumber(location.getLineNumber());
    element.setXmlColumnNumber(location.getColumnNumber());
  }
  
  public static void addXMLLocation(GraphicInfo graphicInfo, XMLStreamReader xtr) {
    Location location = xtr.getLocation();
    graphicInfo.setXmlRowNumber(location.getLineNumber());
    graphicInfo.setXmlColumnNumber(location.getColumnNumber());
  }
  
  public static void parseChildElements(String elementName, BaseElement parentElement, XMLStreamReader xtr, BpmnModel model) throws Exception {
    parseChildElements(elementName, parentElement, xtr, null, model); 
  }
  
  public static void parseChildElements(String elementName, BaseElement parentElement, XMLStreamReader xtr, 
      Map<String, BaseChildElementParser> childParsers, BpmnModel model) throws Exception {
    
    Map<String, BaseChildElementParser> localParserMap =
        new HashMap<String, BaseChildElementParser>(genericChildParserMap);
    if (childParsers != null) {
      localParserMap.putAll(childParsers);
    }

    boolean inExtensionElements = false;
    boolean readyWithChildElements = false;
    while (readyWithChildElements == false && xtr.hasNext()) {
      xtr.next();
      if (xtr.isStartElement()) {
        if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          inExtensionElements = true;
        } else if (localParserMap.containsKey(xtr.getLocalName())) {
          BaseChildElementParser childParser = localParserMap.get(xtr.getLocalName());
          //if we're into an extension element but the current element is not accepted by this parentElement then is read as a custom extension element
          if (inExtensionElements && !childParser.accepts(parentElement)) {
            ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
            parentElement.addExtensionElement(extensionElement);
            continue;
          }
          localParserMap.get(xtr.getLocalName()).parseChildElement(xtr, parentElement, model);
        } else if (inExtensionElements) {
          ExtensionElement extensionElement = BpmnXMLUtil.parseExtensionElement(xtr);
          parentElement.addExtensionElement(extensionElement);
        }

      } else if (xtr.isEndElement()) {
        if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          inExtensionElements = false;
        } else if (elementName.equalsIgnoreCase(xtr.getLocalName())) {
          readyWithChildElements = true;
        }
      }
    }
  }
  
  public static ExtensionElement parseExtensionElement(XMLStreamReader xtr) throws Exception {
    ExtensionElement extensionElement = new ExtensionElement();
    extensionElement.setName(xtr.getLocalName());
    if (StringUtils.isNotEmpty(xtr.getNamespaceURI())) {
      extensionElement.setNamespace(xtr.getNamespaceURI());
    }
    if (StringUtils.isNotEmpty(xtr.getPrefix())) {
      extensionElement.setNamespacePrefix(xtr.getPrefix());
    }
    
    for (int i = 0; i < xtr.getAttributeCount(); i++) {
      ExtensionAttribute extensionAttribute = new ExtensionAttribute();
      extensionAttribute.setName(xtr.getAttributeLocalName(i));
      extensionAttribute.setValue(xtr.getAttributeValue(i));
      if (StringUtils.isNotEmpty(xtr.getAttributeNamespace(i))) {
        extensionAttribute.setNamespace(xtr.getAttributeNamespace(i));
      }
      if (StringUtils.isNotEmpty(xtr.getAttributePrefix(i))) {
        extensionAttribute.setNamespacePrefix(xtr.getAttributePrefix(i));
      }
      extensionElement.addAttribute(extensionAttribute);
    }
    
    boolean readyWithExtensionElement = false;
    while (readyWithExtensionElement == false && xtr.hasNext()) {
      xtr.next();
      if (xtr.isCharacters() || XMLStreamReader.CDATA == xtr.getEventType()) {
        if (StringUtils.isNotEmpty(xtr.getText().trim())) {
          extensionElement.setElementText(xtr.getText().trim());
        }
      } else if (xtr.isStartElement()) {
        ExtensionElement childExtensionElement = parseExtensionElement(xtr);
        extensionElement.addChildElement(childExtensionElement);
      } else if (xtr.isEndElement() && extensionElement.getName().equalsIgnoreCase(xtr.getLocalName())) {
        readyWithExtensionElement = true;
      }
    }
    return extensionElement;
  }
  
  public static void writeDefaultAttribute(String attributeName, String value, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(value) && "null".equalsIgnoreCase(value) == false) {
      xtw.writeAttribute(attributeName, value);
    }
  }
  
  public static void writeQualifiedAttribute(String attributeName, String value, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(value)) {
      xtw.writeAttribute(ACTIVITI_EXTENSIONS_PREFIX, ACTIVITI_EXTENSIONS_NAMESPACE, attributeName, value);
    }
  }
  
  public static boolean writeExtensionElements(BaseElement baseElement, boolean didWriteExtensionStartElement, XMLStreamWriter xtw) throws Exception {
    return didWriteExtensionStartElement = writeExtensionElements(baseElement, didWriteExtensionStartElement, null, xtw);
  }
 
  public static boolean writeExtensionElements(BaseElement baseElement, boolean didWriteExtensionStartElement, Map<String, String> namespaceMap, XMLStreamWriter xtw) throws Exception {
    if (!baseElement.getExtensionElements().isEmpty()) {
      if (didWriteExtensionStartElement == false) {
        xtw.writeStartElement(ELEMENT_EXTENSIONS);
        didWriteExtensionStartElement = true;
      }
      
      if (namespaceMap == null) {
        namespaceMap = new HashMap<String, String>();
      }
      
      for (List<ExtensionElement> extensionElements : baseElement.getExtensionElements().values()) {
        for (ExtensionElement extensionElement : extensionElements) {
          writeExtensionElement(extensionElement, namespaceMap, xtw);
        }
      }
    }
    return didWriteExtensionStartElement;
  }
  
  protected static void writeExtensionElement(ExtensionElement extensionElement, Map<String, String> namespaceMap, XMLStreamWriter xtw) throws Exception {
    if (StringUtils.isNotEmpty(extensionElement.getName())) {
      Map<String, String> localNamespaceMap = new HashMap<String, String>();
      if (StringUtils.isNotEmpty(extensionElement.getNamespace())) {
        if (StringUtils.isNotEmpty(extensionElement.getNamespacePrefix())) {
          xtw.writeStartElement(extensionElement.getNamespacePrefix(), extensionElement.getName(), extensionElement.getNamespace());
          
          if (namespaceMap.containsKey(extensionElement.getNamespacePrefix()) == false ||
              namespaceMap.get(extensionElement.getNamespacePrefix()).equals(extensionElement.getNamespace()) == false) {
            
            xtw.writeNamespace(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
            namespaceMap.put(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
            localNamespaceMap.put(extensionElement.getNamespacePrefix(), extensionElement.getNamespace());
          }
        } else {
          xtw.writeStartElement(extensionElement.getNamespace(), extensionElement.getName());
        }
      } else {
        xtw.writeStartElement(extensionElement.getName());
      }
      
      for (List<ExtensionAttribute> attributes : extensionElement.getAttributes().values()) {
        for (ExtensionAttribute attribute : attributes) {
          if (StringUtils.isNotEmpty(attribute.getName()) && attribute.getValue() != null) {
            if (StringUtils.isNotEmpty(attribute.getNamespace())) {
              if (StringUtils.isNotEmpty(attribute.getNamespacePrefix())) {
                
                if (namespaceMap.containsKey(attribute.getNamespacePrefix()) == false ||
                    namespaceMap.get(attribute.getNamespacePrefix()).equals(attribute.getNamespace()) == false) {
                  
                  xtw.writeNamespace(attribute.getNamespacePrefix(), attribute.getNamespace());
                  namespaceMap.put(attribute.getNamespacePrefix(), attribute.getNamespace());
                }
                
                xtw.writeAttribute(attribute.getNamespacePrefix(), attribute.getNamespace(), attribute.getName(), attribute.getValue());
              } else {
                xtw.writeAttribute(attribute.getNamespace(), attribute.getName(), attribute.getValue());
              }
            } else {
              xtw.writeAttribute(attribute.getName(), attribute.getValue());
            }
          }
        }
      }
      
      if (extensionElement.getElementText() != null) {
        xtw.writeCData(extensionElement.getElementText());
      } else {
        for (List<ExtensionElement> childElements : extensionElement.getChildElements().values()) {
          for (ExtensionElement childElement : childElements) {
            writeExtensionElement(childElement, namespaceMap, xtw);
          }
        }
      }
      
      for (String prefix : localNamespaceMap.keySet()) {
        namespaceMap.remove(prefix);
      }
      
      xtw.writeEndElement();
    }
  }
  
  public static List<String> parseDelimitedList(String s) {
    List<String> result = new ArrayList<String>();
    if (StringUtils.isNotEmpty(s)) {

      StringCharacterIterator iterator = new StringCharacterIterator(s);
      char c = iterator.first();

      StringBuilder strb = new StringBuilder();
      boolean insideExpression = false;

      while (c != StringCharacterIterator.DONE) {
        if (c == '{' || c == '$') {
          insideExpression = true;
        } else if (c == '}') {
          insideExpression = false;
        } else if (c == ',' && !insideExpression) {
          result.add(strb.toString().trim());
          strb.delete(0, strb.length());
        }

        if (c != ',' || (insideExpression)) {
          strb.append(c);
        }

        c = iterator.next();
      }

      if (strb.length() > 0) {
        result.add(strb.toString().trim());
      }

    }
    return result;
  }
  
  public static String convertToDelimitedString(List<String> stringList) {
    StringBuilder resultString = new StringBuilder();
    
    if(stringList != null) {
    	for (String result : stringList) {
    		if (resultString.length() > 0) {
    			resultString.append(",");
    		}
    		resultString.append(result);
    	}
    }
    return resultString.toString();
  }

  /**
   * add all attributes from XML to element extensionAttributes (except blackListed).
   *
   * @param xtr
   * @param element
   * @param blackList
   */
  public static void addCustomAttributes(XMLStreamReader xtr, BaseElement element, List<ExtensionAttribute>... blackLists) {
    for (int i = 0; i < xtr.getAttributeCount(); i++) {
      ExtensionAttribute extensionAttribute = new ExtensionAttribute();
      extensionAttribute.setName(xtr.getAttributeLocalName(i));
      extensionAttribute.setValue(xtr.getAttributeValue(i));
      if (StringUtils.isNotEmpty(xtr.getAttributeNamespace(i))) {
        extensionAttribute.setNamespace(xtr.getAttributeNamespace(i));
      }
      if (StringUtils.isNotEmpty(xtr.getAttributePrefix(i))) {
        extensionAttribute.setNamespacePrefix(xtr.getAttributePrefix(i));
      }
      if (!isBlacklisted(extensionAttribute, blackLists)) {
        element.addAttribute(extensionAttribute);
      }
    }
  }

  public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes, XMLStreamWriter xtw, List<ExtensionAttribute>... blackLists) throws XMLStreamException {
    writeCustomAttributes(attributes, xtw, new LinkedHashMap<String, String>(), blackLists);
  }
  
  /**
   * write attributes to xtw (except blacklisted)
   * @param attributes
   * @param xtw
   * @param blackList
   */
  public static void writeCustomAttributes(Collection<List<ExtensionAttribute>> attributes, XMLStreamWriter xtw, Map<String, String> namespaceMap,
      List<ExtensionAttribute>... blackLists) throws XMLStreamException {
    
    for (List<ExtensionAttribute> attributeList : attributes) {
      if (attributeList != null && !attributeList.isEmpty()) {
        for (ExtensionAttribute attribute : attributeList) {
          if (!isBlacklisted(attribute, blackLists)) {
            if (attribute.getNamespacePrefix() == null) {
              if (attribute.getNamespace() == null)
                xtw.writeAttribute(attribute.getName(), attribute.getValue());
              else {
                xtw.writeAttribute(attribute.getNamespace(), attribute.getName(), attribute.getValue());
              }
            } else {
              if (!namespaceMap.containsKey(attribute.getNamespacePrefix())) {
                namespaceMap.put(attribute.getNamespacePrefix(), attribute.getNamespace());
                xtw.writeNamespace(attribute.getNamespacePrefix(), attribute.getNamespace());
              }
              xtw.writeAttribute(attribute.getNamespacePrefix(), attribute.getNamespace(),
                  attribute.getName(), attribute.getValue());
            }
          }
        }
      }
    }
  }

  public static boolean isBlacklisted(ExtensionAttribute attribute, List<ExtensionAttribute>... blackLists) {
    if (blackLists != null) {
      for (List<ExtensionAttribute> blackList : blackLists) {
        for (ExtensionAttribute blackAttribute : blackList) {
          if (blackAttribute.getName().equals(attribute.getName())) {
            if ( blackAttribute.getNamespace() != null && attribute.getNamespace() != null
                && blackAttribute.getNamespace().equals(attribute.getNamespace()))
              return true;
            if (blackAttribute.getNamespace() == null && attribute.getNamespace() == null)
              return true;
          }
        }
      }
    }
    return false;
  }
}
!@#$%
20190526_172045,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
package org.activiti.bpmn.converter.export;

import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Event;
import org.activiti.bpmn.model.EventDefinition;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.Message;
import org.activiti.bpmn.model.MessageEventDefinition;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.Signal;
import org.activiti.bpmn.model.SignalEventDefinition;
import org.apache.commons.lang3.StringUtils;

public class SignalAndMessageDefinitionExport implements BpmnXMLConstants {

  public static void writeSignalsAndMessages(BpmnModel model, XMLStreamWriter xtw) throws Exception {

    for (Process process : model.getProcesses()) {
      for (FlowElement flowElement : process.findFlowElementsOfType(Event.class)) {
        Event event = (Event) flowElement;
        if (!event.getEventDefinitions().isEmpty()) {
          EventDefinition eventDefinition = event.getEventDefinitions().get(0);
          if (eventDefinition instanceof SignalEventDefinition) {
            SignalEventDefinition signalEvent = (SignalEventDefinition) eventDefinition;
            if (StringUtils.isNotEmpty(signalEvent.getSignalRef())) {
              if (model.containsSignalId(signalEvent.getSignalRef()) == false) {
                Signal signal = new Signal(signalEvent.getSignalRef(), signalEvent.getSignalRef());
                model.addSignal(signal);
              }
            }

          } else if (eventDefinition instanceof MessageEventDefinition) {
            MessageEventDefinition messageEvent = (MessageEventDefinition) eventDefinition;
            if (StringUtils.isNotEmpty(messageEvent.getMessageRef())) {
              if (model.containsMessageId(messageEvent.getMessageRef()) == false) {
                Message message = new Message(messageEvent.getMessageRef(), messageEvent.getMessageRef(), null);
                model.addMessage(message);
              }
            }
          }
        }
      }
    }

    for (Signal signal : model.getSignals()) {
      xtw.writeStartElement(ELEMENT_SIGNAL);
      xtw.writeAttribute(ATTRIBUTE_ID, signal.getId());
      xtw.writeAttribute(ATTRIBUTE_NAME, signal.getName());
      if (signal.getScope() != null) {
        xtw.writeAttribute(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_SCOPE, signal.getScope());
      }
      xtw.writeEndElement();
    }

    for (Message message : model.getMessages()) {
      xtw.writeStartElement(ELEMENT_MESSAGE);
      String messageId = message.getId();
      // remove the namespace from the message id if set
      if (model.getTargetNamespace() != null && messageId.startsWith(model.getTargetNamespace())) {
        messageId = messageId.replace(model.getTargetNamespace(), "");
        messageId = messageId.replaceFirst(":", "");
      } else {
        for (String prefix : model.getNamespaces().keySet()) {
          String namespace = model.getNamespace(prefix);
          if (messageId.startsWith(namespace)) {
            messageId = messageId.replace(model.getTargetNamespace(), "");
            messageId = prefix + messageId;
          }
        }
      }
      xtw.writeAttribute(ATTRIBUTE_ID, messageId);
      if (StringUtils.isNotEmpty(message.getName())) {
        xtw.writeAttribute(ATTRIBUTE_NAME, message.getName());
      }
      if (StringUtils.isNotEmpty(message.getItemRef())) {
        // replace the namespace by the right prefix
        String itemRef = message.getItemRef();
        for (String prefix : model.getNamespaces().keySet()) {
          String namespace = model.getNamespace(prefix);
          if (itemRef.startsWith(namespace)) {
            if (prefix.isEmpty()) {
              itemRef = itemRef.replace(namespace + ":", "");
            } else {
              itemRef = itemRef.replace(namespace, prefix);
            }
            break;
          }
        }
        xtw.writeAttribute(ATTRIBUTE_ITEM_REF, itemRef);
      }
      xtw.writeEndElement();
    }
  }
}
!@#$%
20190526_172045,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
package org.activiti.bpmn.converter.export;

import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Event;
import org.activiti.bpmn.model.EventDefinition;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.Message;
import org.activiti.bpmn.model.MessageEventDefinition;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.Signal;
import org.activiti.bpmn.model.SignalEventDefinition;
import org.apache.commons.lang3.StringUtils;

public class SignalAndMessageDefinitionExport implements BpmnXMLConstants {

  public static void writeSignalsAndMessages(BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    for (Process process : model.getProcesses()) {
      for (FlowElement flowElement : process.findFlowElementsOfType(Event.class)) {
        Event event = (Event) flowElement;
        if (!event.getEventDefinitions().isEmpty()) {
          EventDefinition eventDefinition = event.getEventDefinitions().get(0);
          if (eventDefinition instanceof SignalEventDefinition) {
            SignalEventDefinition signalEvent = (SignalEventDefinition) eventDefinition;
            if (model.containsSignalId(signalEvent.getSignalRef()) == false) {
              Signal signal = new Signal(signalEvent.getSignalRef(), signalEvent.getSignalRef());
              model.addSignal(signal);
            }

          } else if (eventDefinition instanceof MessageEventDefinition) {
            MessageEventDefinition messageEvent = (MessageEventDefinition) eventDefinition;
            if (model.containsMessageId(messageEvent.getMessageRef()) == false) {
              Message message = new Message(messageEvent.getMessageRef(), messageEvent.getMessageRef(), null);
              model.addMessage(message);
            }
          }
        }
      }
    }
    
    for (Signal signal : model.getSignals()) {
      xtw.writeStartElement(ELEMENT_SIGNAL);
      xtw.writeAttribute(ATTRIBUTE_ID, signal.getId());
      xtw.writeAttribute(ATTRIBUTE_NAME, signal.getName());
      if (signal.getScope() != null) {
        xtw.writeAttribute(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_SCOPE, signal.getScope());
      }
      xtw.writeEndElement();
    }
    
    for (Message message : model.getMessages()) {
      xtw.writeStartElement(ELEMENT_MESSAGE);
      String messageId = message.getId();
      // remove the namespace from the message id if set
      if (model.getTargetNamespace() != null && messageId.startsWith(model.getTargetNamespace())) {
        messageId = messageId.replace(model.getTargetNamespace(), "");
        messageId = messageId.replaceFirst(":", "");
      } else {
        for (String prefix : model.getNamespaces().keySet()) {
          String namespace = model.getNamespace(prefix);
          if (messageId.startsWith(namespace)) {
            messageId = messageId.replace(model.getTargetNamespace(), "");
            messageId = prefix + messageId;
          }
        }
      }
      xtw.writeAttribute(ATTRIBUTE_ID, messageId);
      if (StringUtils.isNotEmpty(message.getName())) {
        xtw.writeAttribute(ATTRIBUTE_NAME, message.getName());
      }
      if (StringUtils.isNotEmpty(message.getItemRef())) {
        // replace the namespace by the right prefix
        String itemRef = message.getItemRef();
        for (String prefix : model.getNamespaces().keySet()) {
            String namespace = model.getNamespace(prefix);
            if (itemRef.startsWith(namespace)) {
                if (prefix.isEmpty()) {
                    itemRef = itemRef.replace(namespace + ":", "");
                } else {
                    itemRef = itemRef.replace(namespace, prefix);
                }
                break;
            }
        }
        xtw.writeAttribute(ATTRIBUTE_ITEM_REF, itemRef);
      }
      xtw.writeEndElement();
    }
  }
}
!@#$%
20190526_172045,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
package org.activiti.bpmn.converter.export;

import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Event;
import org.activiti.bpmn.model.EventDefinition;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.Message;
import org.activiti.bpmn.model.MessageEventDefinition;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.Signal;
import org.activiti.bpmn.model.SignalEventDefinition;
import org.apache.commons.lang3.StringUtils;

public class SignalAndMessageDefinitionExport implements BpmnXMLConstants {

  public static void writeSignalsAndMessages(BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    for (Process process : model.getProcesses()) {
      for (FlowElement flowElement : process.findFlowElementsOfType(Event.class)) {
        Event event = (Event) flowElement;
        if (!event.getEventDefinitions().isEmpty()) {
          EventDefinition eventDefinition = event.getEventDefinitions().get(0);
          if (eventDefinition instanceof SignalEventDefinition) {
            SignalEventDefinition signalEvent = (SignalEventDefinition) eventDefinition;
            if (StringUtils.isNotEmpty(signalEvent.getSignalRef())) {
              if (model.containsSignalId(signalEvent.getSignalRef()) == false) {
                Signal signal = new Signal(signalEvent.getSignalRef(), signalEvent.getSignalRef());
                model.addSignal(signal);
              }
            }

          } else if (eventDefinition instanceof MessageEventDefinition) {
            MessageEventDefinition messageEvent = (MessageEventDefinition) eventDefinition;
            if (StringUtils.isNotEmpty(messageEvent.getMessageRef())) {
              if (model.containsMessageId(messageEvent.getMessageRef()) == false) {
                Message message = new Message(messageEvent.getMessageRef(), messageEvent.getMessageRef(), null);
                model.addMessage(message);
              }
            }
          }
        }
      }
    }
    
    for (Signal signal : model.getSignals()) {
      xtw.writeStartElement(ELEMENT_SIGNAL);
      xtw.writeAttribute(ATTRIBUTE_ID, signal.getId());
      xtw.writeAttribute(ATTRIBUTE_NAME, signal.getName());
      if (signal.getScope() != null) {
        xtw.writeAttribute(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_SCOPE, signal.getScope());
      }
      xtw.writeEndElement();
    }
    
    for (Message message : model.getMessages()) {
      xtw.writeStartElement(ELEMENT_MESSAGE);
      String messageId = message.getId();
      // remove the namespace from the message id if set
      if (model.getTargetNamespace() != null && messageId.startsWith(model.getTargetNamespace())) {
        messageId = messageId.replace(model.getTargetNamespace(), "");
        messageId = messageId.replaceFirst(":", "");
      } else {
        for (String prefix : model.getNamespaces().keySet()) {
          String namespace = model.getNamespace(prefix);
          if (messageId.startsWith(namespace)) {
            messageId = messageId.replace(model.getTargetNamespace(), "");
            messageId = prefix + messageId;
          }
        }
      }
      xtw.writeAttribute(ATTRIBUTE_ID, messageId);
      if (StringUtils.isNotEmpty(message.getName())) {
        xtw.writeAttribute(ATTRIBUTE_NAME, message.getName());
      }
      if (StringUtils.isNotEmpty(message.getItemRef())) {
        // replace the namespace by the right prefix
        String itemRef = message.getItemRef();
        for (String prefix : model.getNamespaces().keySet()) {
            String namespace = model.getNamespace(prefix);
            if (itemRef.startsWith(namespace)) {
                if (prefix.isEmpty()) {
                    itemRef = itemRef.replace(namespace + ":", "");
                } else {
                    itemRef = itemRef.replace(namespace, prefix);
                }
                break;
            }
        }
        xtw.writeAttribute(ATTRIBUTE_ITEM_REF, itemRef);
      }
      xtw.writeEndElement();
    }
  }
}
!@#$%
20190526_172051,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter.child;

import javax.xml.stream.XMLStreamReader;

import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Event;
import org.activiti.bpmn.model.TimerEventDefinition;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class TimerEventDefinitionParser extends BaseChildElementParser {

  public String getElementName() {
    return ELEMENT_EVENT_TIMERDEFINITION;
  }

  public void parseChildElement(XMLStreamReader xtr, BaseElement parentElement, BpmnModel model) throws Exception {
    if (parentElement instanceof Event == false)
      return;

    TimerEventDefinition eventDefinition = new TimerEventDefinition();
    String calendarName = xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_CALENDAR_NAME);
    if (StringUtils.isNotEmpty(calendarName)) {
      eventDefinition.setCalendarName(calendarName);
    }
    BpmnXMLUtil.addXMLLocation(eventDefinition, xtr);
    BpmnXMLUtil.parseChildElements(ELEMENT_EVENT_TIMERDEFINITION, eventDefinition, xtr, model);

    ((Event) parentElement).getEventDefinitions().add(eventDefinition);
  }
}
!@#$%
20190526_172051,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter.child;

import javax.xml.stream.XMLStreamReader;

import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Event;
import org.activiti.bpmn.model.TimerEventDefinition;

/**
 * @author Tijs Rademakers
 */
public class TimerEventDefinitionParser extends BaseChildElementParser {

  public String getElementName() {
    return ELEMENT_EVENT_TIMERDEFINITION;
  }
  
  public void parseChildElement(XMLStreamReader xtr, BaseElement parentElement, BpmnModel model) throws Exception {
    if (parentElement instanceof Event == false) return;
    
    TimerEventDefinition eventDefinition = new TimerEventDefinition();
    BpmnXMLUtil.addXMLLocation(eventDefinition, xtr);
    BpmnXMLUtil.parseChildElements(ELEMENT_EVENT_TIMERDEFINITION, eventDefinition, xtr, model);
    
    ((Event) parentElement).getEventDefinitions().add(eventDefinition);
  }
}
!@#$%
20190526_172051,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter.child;

import javax.xml.stream.XMLStreamReader;

import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.Event;
import org.activiti.bpmn.model.TimerEventDefinition;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class TimerEventDefinitionParser extends BaseChildElementParser {

  public String getElementName() {
    return ELEMENT_EVENT_TIMERDEFINITION;
  }
  
  public void parseChildElement(XMLStreamReader xtr, BaseElement parentElement, BpmnModel model) throws Exception {
    if (parentElement instanceof Event == false) return;
    
    TimerEventDefinition eventDefinition = new TimerEventDefinition();
    String calendarName = xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_CALENDAR_NAME);
    if (StringUtils.isNotEmpty(calendarName)) {
      eventDefinition.setCalendarName(calendarName);
    }
    BpmnXMLUtil.addXMLLocation(eventDefinition, xtr);
    BpmnXMLUtil.parseChildElements(ELEMENT_EVENT_TIMERDEFINITION, eventDefinition, xtr, model);
    
    ((Event) parentElement).getEventDefinitions().add(eventDefinition);
  }
}
!@#$%
20190526_172102,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.converter.export.FieldExtensionExport;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.CustomProperty;
import org.activiti.bpmn.model.ImplementationType;
import org.activiti.bpmn.model.ServiceTask;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class ServiceTaskXMLConverter extends BaseBpmnXMLConverter {

  public Class<? extends BaseElement> getBpmnElementType() {
    return ServiceTask.class;
  }

  @Override
  protected String getXMLElementName() {
    return ELEMENT_TASK_SERVICE;
  }

  @Override
  protected BaseElement convertXMLToElement(XMLStreamReader xtr, BpmnModel model) throws Exception {
    ServiceTask serviceTask = new ServiceTask();
    BpmnXMLUtil.addXMLLocation(serviceTask, xtr);
    if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_CLASS))) {
      serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_CLASS);
      serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_CLASS));

    } else if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXPRESSION))) {
      serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_EXPRESSION);
      serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXPRESSION));

    } else if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION))) {
      serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION);
      serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION));

    } else if ("##WebService".equals(xtr.getAttributeValue(null, ATTRIBUTE_TASK_IMPLEMENTATION))) {
      serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_WEBSERVICE);
      serviceTask.setOperationRef(parseOperationRef(xtr.getAttributeValue(null, ATTRIBUTE_TASK_OPERATION_REF), model));
    }

    serviceTask.setResultVariableName(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE));
    if (StringUtils.isEmpty(serviceTask.getResultVariableName())) {
      serviceTask.setResultVariableName(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, "resultVariable"));
    }

    serviceTask.setType(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TYPE));
    serviceTask.setExtensionId(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXTENSIONID));

    if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION))) {
      serviceTask.setSkipExpression(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION));
    }
    parseChildElements(getXMLElementName(), serviceTask, model, xtr);

    return serviceTask;
  }

  @Override
  protected void writeAdditionalAttributes(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {

    ServiceTask serviceTask = (ServiceTask) element;

    if (ImplementationType.IMPLEMENTATION_TYPE_CLASS.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_CLASS, serviceTask.getImplementation(), xtw);
    } else if (ImplementationType.IMPLEMENTATION_TYPE_EXPRESSION.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_EXPRESSION, serviceTask.getImplementation(), xtw);
    } else if (ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION, serviceTask.getImplementation(), xtw);
    }

    if (StringUtils.isNotEmpty(serviceTask.getResultVariableName())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE, serviceTask.getResultVariableName(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getType())) {
      writeQualifiedAttribute(ATTRIBUTE_TYPE, serviceTask.getType(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getExtensionId())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_EXTENSIONID, serviceTask.getExtensionId(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getSkipExpression())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION, serviceTask.getSkipExpression(), xtw);
    }
  }

  @Override
  protected boolean writeExtensionChildElements(BaseElement element, boolean didWriteExtensionStartElement, XMLStreamWriter xtw) throws Exception {
    ServiceTask serviceTask = (ServiceTask) element;

    if (!serviceTask.getCustomProperties().isEmpty()) {
      for (CustomProperty customProperty : serviceTask.getCustomProperties()) {

        if (StringUtils.isEmpty(customProperty.getSimpleValue())) {
          continue;
        }

        if (didWriteExtensionStartElement == false) {
          xtw.writeStartElement(ELEMENT_EXTENSIONS);
          didWriteExtensionStartElement = true;
        }
        xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ELEMENT_FIELD, ACTIVITI_EXTENSIONS_NAMESPACE);
        xtw.writeAttribute(ATTRIBUTE_FIELD_NAME, customProperty.getName());
        if ((customProperty.getSimpleValue().contains("${") || customProperty.getSimpleValue().contains("#{")) && customProperty.getSimpleValue().contains("}")) {

          xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ATTRIBUTE_FIELD_EXPRESSION, ACTIVITI_EXTENSIONS_NAMESPACE);
        } else {
          xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ELEMENT_FIELD_STRING, ACTIVITI_EXTENSIONS_NAMESPACE);
        }
        xtw.writeCharacters(customProperty.getSimpleValue());
        xtw.writeEndElement();
        xtw.writeEndElement();
      }
    } else {
      didWriteExtensionStartElement = FieldExtensionExport.writeFieldExtensions(serviceTask.getFieldExtensions(), didWriteExtensionStartElement, xtw);
    }

    return didWriteExtensionStartElement;
  }

  @Override
  protected void writeAdditionalChildElements(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
  }

  protected String parseOperationRef(String operationRef, BpmnModel model) {
    String result = null;
    if (StringUtils.isNotEmpty(operationRef)) {
      int indexOfP = operationRef.indexOf(':');
      if (indexOfP != -1) {
        String prefix = operationRef.substring(0, indexOfP);
        String resolvedNamespace = model.getNamespace(prefix);
        result = resolvedNamespace + ":" + operationRef.substring(indexOfP + 1);
      } else {
        result = model.getTargetNamespace() + ":" + operationRef;
      }
    }
    return result;
  }
}
!@#$%
20190526_172102,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.converter.export.FieldExtensionExport;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.CustomProperty;
import org.activiti.bpmn.model.ImplementationType;
import org.activiti.bpmn.model.ServiceTask;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class ServiceTaskXMLConverter extends BaseBpmnXMLConverter {
  
  public Class<? extends BaseElement> getBpmnElementType() {
    return ServiceTask.class;
  }
  
  @Override
  protected String getXMLElementName() {
    return ELEMENT_TASK_SERVICE;
  }

  @Override
  protected BaseElement convertXMLToElement(XMLStreamReader xtr, BpmnModel model) throws Exception {
		ServiceTask serviceTask = new ServiceTask();
		BpmnXMLUtil.addXMLLocation(serviceTask, xtr);
		if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_CLASS))) {
			serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_CLASS);
			serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_CLASS));
			
		} else if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXPRESSION))) {
			serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_EXPRESSION);
			serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXPRESSION));
			
		} else if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION))) {
			serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION);
			serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION));
		
		} else if ("##WebService".equals(xtr.getAttributeValue(null, ATTRIBUTE_TASK_IMPLEMENTATION))) {
		  serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_WEBSERVICE);
		  serviceTask.setOperationRef(parseOperationRef(xtr.getAttributeValue(null, ATTRIBUTE_TASK_OPERATION_REF), model));
		}
	
		serviceTask.setResultVariableName(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE));
		if (StringUtils.isEmpty(serviceTask.getResultVariableName())) {
		  serviceTask.setResultVariableName(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, "resultVariable"));
		}
		
		serviceTask.setType(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TYPE));
		serviceTask.setExtensionId(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXTENSIONID));
	
		if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION))) {
		  serviceTask.setSkipExpression(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION));
		}
		parseChildElements(getXMLElementName(), serviceTask, model, xtr);
		
		return serviceTask;
  }
  
  @Override
  protected void writeAdditionalAttributes(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    ServiceTask serviceTask = (ServiceTask) element;
    
    if (ImplementationType.IMPLEMENTATION_TYPE_CLASS.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_CLASS, serviceTask.getImplementation(), xtw);
    } else if (ImplementationType.IMPLEMENTATION_TYPE_EXPRESSION.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_EXPRESSION, serviceTask.getImplementation(), xtw);
    } else if (ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION, serviceTask.getImplementation(), xtw);
    }
    
    if (StringUtils.isNotEmpty(serviceTask.getResultVariableName())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE, serviceTask.getResultVariableName(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getType())) {
      writeQualifiedAttribute(ATTRIBUTE_TYPE, serviceTask.getType(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getExtensionId())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_EXTENSIONID, serviceTask.getExtensionId(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getSkipExpression())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION, serviceTask.getSkipExpression(), xtw);
    }
  }
  
  @Override
  protected boolean writeExtensionChildElements(BaseElement element, boolean didWriteExtensionStartElement, XMLStreamWriter xtw) throws Exception {
    ServiceTask serviceTask = (ServiceTask) element;
    
    if (!serviceTask.getCustomProperties().isEmpty()) {
      for (CustomProperty customProperty : serviceTask.getCustomProperties()) {
        
        if (StringUtils.isEmpty(customProperty.getSimpleValue())) {
          continue;
        }
        
        if (didWriteExtensionStartElement == false) {
          xtw.writeStartElement(ELEMENT_EXTENSIONS);
          didWriteExtensionStartElement = true;
        }
        xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ELEMENT_FIELD, ACTIVITI_EXTENSIONS_NAMESPACE);
        xtw.writeAttribute(ATTRIBUTE_FIELD_NAME, customProperty.getName());
        if ((customProperty.getSimpleValue().contains("${") || customProperty.getSimpleValue().contains("#{")) &&
            customProperty.getSimpleValue().contains("}")) {
          
          xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ATTRIBUTE_FIELD_EXPRESSION, ACTIVITI_EXTENSIONS_NAMESPACE);
        } else {
          xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ELEMENT_FIELD_STRING, ACTIVITI_EXTENSIONS_NAMESPACE);
        }
        xtw.writeCharacters(customProperty.getSimpleValue());
        xtw.writeEndElement();
        xtw.writeEndElement();
      }
    } else {
      didWriteExtensionStartElement = FieldExtensionExport.writeFieldExtensions(serviceTask.getFieldExtensions(), didWriteExtensionStartElement, xtw);
    }
    
    return didWriteExtensionStartElement;
  }
  
  @Override
  protected void writeAdditionalChildElements(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
  }
  
  protected String parseOperationRef(String operationRef, BpmnModel model) {
    String result = null;
    if (StringUtils.isNotEmpty(operationRef)) {
      int indexOfP = operationRef.indexOf(':');
      if (indexOfP != -1) {
        String prefix = operationRef.substring(0, indexOfP);
        String resolvedNamespace = model.getNamespace(prefix);
        result = resolvedNamespace + ":" + operationRef.substring(indexOfP + 1);
      } else {
        result = model.getTargetNamespace() + ":" + operationRef;
      }
    }
    return result;
  }
}
!@#$%
20190526_172102,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.converter.export.FieldExtensionExport;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.CustomProperty;
import org.activiti.bpmn.model.ImplementationType;
import org.activiti.bpmn.model.ServiceTask;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class ServiceTaskXMLConverter extends BaseBpmnXMLConverter {
  
  public Class<? extends BaseElement> getBpmnElementType() {
    return ServiceTask.class;
  }
  
  @Override
  protected String getXMLElementName() {
    return ELEMENT_TASK_SERVICE;
  }

  @Override
  protected BaseElement convertXMLToElement(XMLStreamReader xtr, BpmnModel model) throws Exception {
		ServiceTask serviceTask = new ServiceTask();
		BpmnXMLUtil.addXMLLocation(serviceTask, xtr);
		if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_CLASS))) {
			serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_CLASS);
			serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_CLASS));
			
		} else if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXPRESSION))) {
			serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_EXPRESSION);
			serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXPRESSION));
			
		} else if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION))) {
			serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION);
			serviceTask.setImplementation(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION));
		
		} else if ("##WebService".equals(xtr.getAttributeValue(null, ATTRIBUTE_TASK_IMPLEMENTATION))) {
		  serviceTask.setImplementationType(ImplementationType.IMPLEMENTATION_TYPE_WEBSERVICE);
		  serviceTask.setOperationRef(parseOperationRef(xtr.getAttributeValue(null, ATTRIBUTE_TASK_OPERATION_REF), model));
		}
	
		serviceTask.setResultVariableName(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE));
		if (StringUtils.isEmpty(serviceTask.getResultVariableName())) {
		  serviceTask.setResultVariableName(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, "resultVariable"));
		}
		
		serviceTask.setType(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TYPE));
		serviceTask.setExtensionId(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_EXTENSIONID));
	
		if (StringUtils.isNotEmpty(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION))) {
		  serviceTask.setSkipExpression(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION));
		}
		parseChildElements(getXMLElementName(), serviceTask, model, xtr);
		
		return serviceTask;
  }
  
  @Override
  protected void writeAdditionalAttributes(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    ServiceTask serviceTask = (ServiceTask) element;
    
    if (ImplementationType.IMPLEMENTATION_TYPE_CLASS.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_CLASS, serviceTask.getImplementation(), xtw);
    } else if (ImplementationType.IMPLEMENTATION_TYPE_EXPRESSION.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_EXPRESSION, serviceTask.getImplementation(), xtw);
    } else if (ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION.equals(serviceTask.getImplementationType())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION, serviceTask.getImplementation(), xtw);
    }
    
    if (StringUtils.isNotEmpty(serviceTask.getResultVariableName())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE, serviceTask.getResultVariableName(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getType())) {
      writeQualifiedAttribute(ATTRIBUTE_TYPE, serviceTask.getType(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getExtensionId())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_EXTENSIONID, serviceTask.getExtensionId(), xtw);
    }
    if (StringUtils.isNotEmpty(serviceTask.getSkipExpression())) {
      writeQualifiedAttribute(ATTRIBUTE_TASK_SERVICE_SKIP_EXPRESSION, serviceTask.getSkipExpression(), xtw);
    }
  }
  
  @Override
  protected boolean writeExtensionChildElements(BaseElement element, boolean didWriteExtensionStartElement, XMLStreamWriter xtw) throws Exception {
    ServiceTask serviceTask = (ServiceTask) element;
    
    if (!serviceTask.getCustomProperties().isEmpty()) {
      for (CustomProperty customProperty : serviceTask.getCustomProperties()) {
        
        if (StringUtils.isEmpty(customProperty.getSimpleValue())) {
          continue;
        }
        
        if (didWriteExtensionStartElement == false) {
          xtw.writeStartElement(ELEMENT_EXTENSIONS);
          didWriteExtensionStartElement = true;
        }
        xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ELEMENT_FIELD, ACTIVITI_EXTENSIONS_NAMESPACE);
        xtw.writeAttribute(ATTRIBUTE_FIELD_NAME, customProperty.getName());
        if ((customProperty.getSimpleValue().contains("${") || customProperty.getSimpleValue().contains("#{")) &&
            customProperty.getSimpleValue().contains("}")) {
          
          xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ATTRIBUTE_FIELD_EXPRESSION, ACTIVITI_EXTENSIONS_NAMESPACE);
        } else {
          xtw.writeStartElement(ACTIVITI_EXTENSIONS_PREFIX, ELEMENT_FIELD_STRING, ACTIVITI_EXTENSIONS_NAMESPACE);
        }
        xtw.writeCData(customProperty.getSimpleValue());
        xtw.writeEndElement();
        xtw.writeEndElement();
      }
    } else {
      didWriteExtensionStartElement = FieldExtensionExport.writeFieldExtensions(serviceTask.getFieldExtensions(), didWriteExtensionStartElement, xtw);
    }
    
    return didWriteExtensionStartElement;
  }
  
  @Override
  protected void writeAdditionalChildElements(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
  }
  
  protected String parseOperationRef(String operationRef, BpmnModel model) {
    String result = null;
    if (StringUtils.isNotEmpty(operationRef)) {
      int indexOfP = operationRef.indexOf(':');
      if (indexOfP != -1) {
        String prefix = operationRef.substring(0, indexOfP);
        String resolvedNamespace = model.getNamespace(prefix);
        result = resolvedNamespace + ":" + operationRef.substring(indexOfP + 1);
      } else {
        result = model.getTargetNamespace() + ":" + operationRef;
      }
    }
    return result;
  }
}
!@#$%
20190526_172104,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import java.util.HashMap;
import java.util.Map;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.converter.child.BaseChildElementParser;
import org.activiti.bpmn.converter.child.ScriptTextParser;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ScriptTask;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class ScriptTaskXMLConverter extends BaseBpmnXMLConverter {

  protected Map<String, BaseChildElementParser> childParserMap = new HashMap<String, BaseChildElementParser>();

  public ScriptTaskXMLConverter() {
    ScriptTextParser scriptTextParser = new ScriptTextParser();
    childParserMap.put(scriptTextParser.getElementName(), scriptTextParser);
  }

  public Class<? extends BaseElement> getBpmnElementType() {
    return ScriptTask.class;
  }

  @Override
  protected String getXMLElementName() {
    return ELEMENT_TASK_SCRIPT;
  }

  @Override
  protected BaseElement convertXMLToElement(XMLStreamReader xtr, BpmnModel model) throws Exception {
    ScriptTask scriptTask = new ScriptTask();
    BpmnXMLUtil.addXMLLocation(scriptTask, xtr);
    scriptTask.setScriptFormat(xtr.getAttributeValue(null, ATTRIBUTE_TASK_SCRIPT_FORMAT));
    scriptTask.setResultVariable(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SCRIPT_RESULTVARIABLE));
    if (StringUtils.isEmpty(scriptTask.getResultVariable())) {
      scriptTask.setResultVariable(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE));
    }
    String autoStoreVariables = xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SCRIPT_AUTO_STORE_VARIABLE);
    if (StringUtils.isNotEmpty(autoStoreVariables)) {
      scriptTask.setAutoStoreVariables(Boolean.valueOf(autoStoreVariables));
    }
    parseChildElements(getXMLElementName(), scriptTask, childParserMap, model, xtr);
    return scriptTask;
  }

  @Override
  protected void writeAdditionalAttributes(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    ScriptTask scriptTask = (ScriptTask) element;
    writeDefaultAttribute(ATTRIBUTE_TASK_SCRIPT_FORMAT, scriptTask.getScriptFormat(), xtw);
    writeQualifiedAttribute(ATTRIBUTE_TASK_SCRIPT_RESULTVARIABLE, scriptTask.getResultVariable(), xtw);
    writeQualifiedAttribute(ATTRIBUTE_TASK_SCRIPT_AUTO_STORE_VARIABLE, String.valueOf(scriptTask.isAutoStoreVariables()), xtw);
  }

  @Override
  protected void writeAdditionalChildElements(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    ScriptTask scriptTask = (ScriptTask) element;
    if (StringUtils.isNotEmpty(scriptTask.getScript())) {
      xtw.writeStartElement(ATTRIBUTE_TASK_SCRIPT_TEXT);
      xtw.writeCData(scriptTask.getScript());
      xtw.writeEndElement();
    }
  }
}
!@#$%
20190526_172104,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import java.util.HashMap;
import java.util.Map;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.converter.child.BaseChildElementParser;
import org.activiti.bpmn.converter.child.ScriptTextParser;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ScriptTask;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class ScriptTaskXMLConverter extends BaseBpmnXMLConverter {
  
  protected Map<String, BaseChildElementParser> childParserMap = new HashMap<String, BaseChildElementParser>();
  
	public ScriptTaskXMLConverter() {
		ScriptTextParser scriptTextParser = new ScriptTextParser();
		childParserMap.put(scriptTextParser.getElementName(), scriptTextParser);
	}
	
  public Class<? extends BaseElement> getBpmnElementType() {
    return ScriptTask.class;
  }
  
  @Override
  protected String getXMLElementName() {
    return ELEMENT_TASK_SCRIPT;
  }
  
  @Override
  protected BaseElement convertXMLToElement(XMLStreamReader xtr, BpmnModel model) throws Exception {
    ScriptTask scriptTask = new ScriptTask();
    BpmnXMLUtil.addXMLLocation(scriptTask, xtr);
    scriptTask.setScriptFormat(xtr.getAttributeValue(null, ATTRIBUTE_TASK_SCRIPT_FORMAT));
    scriptTask.setResultVariable(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SCRIPT_RESULTVARIABLE));
    if (StringUtils.isEmpty(scriptTask.getResultVariable())) {
      scriptTask.setResultVariable(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE));
    }
    String autoStoreVariables = xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SCRIPT_AUTO_STORE_VARIABLE);
    if (StringUtils.isNotEmpty(autoStoreVariables)) {
      scriptTask.setAutoStoreVariables(Boolean.valueOf(autoStoreVariables));
    }
    parseChildElements(getXMLElementName(), scriptTask, childParserMap, model, xtr);
    return scriptTask;
  }

  @Override
  protected void writeAdditionalAttributes(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    ScriptTask scriptTask = (ScriptTask) element;
    writeDefaultAttribute(ATTRIBUTE_TASK_SCRIPT_FORMAT, scriptTask.getScriptFormat(), xtw);
    writeQualifiedAttribute(ATTRIBUTE_TASK_SCRIPT_RESULTVARIABLE, scriptTask.getResultVariable(), xtw);
    writeQualifiedAttribute(ATTRIBUTE_TASK_SCRIPT_AUTO_STORE_VARIABLE, String.valueOf(scriptTask.isAutoStoreVariables()), xtw);
  }
  
  @Override
  protected void writeAdditionalChildElements(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    ScriptTask scriptTask = (ScriptTask) element;
    if (StringUtils.isNotEmpty(scriptTask.getScript())) {
      xtw.writeStartElement(ATTRIBUTE_TASK_SCRIPT_TEXT);
      xtw.writeCharacters(scriptTask.getScript());
      xtw.writeEndElement();
    }
  }
}
!@#$%
20190526_172104,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import java.util.HashMap;
import java.util.Map;

import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;

import org.activiti.bpmn.converter.child.BaseChildElementParser;
import org.activiti.bpmn.converter.child.ScriptTextParser;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.ScriptTask;
import org.apache.commons.lang3.StringUtils;

/**
 * @author Tijs Rademakers
 */
public class ScriptTaskXMLConverter extends BaseBpmnXMLConverter {
  
  protected Map<String, BaseChildElementParser> childParserMap = new HashMap<String, BaseChildElementParser>();
  
	public ScriptTaskXMLConverter() {
		ScriptTextParser scriptTextParser = new ScriptTextParser();
		childParserMap.put(scriptTextParser.getElementName(), scriptTextParser);
	}
	
  public Class<? extends BaseElement> getBpmnElementType() {
    return ScriptTask.class;
  }
  
  @Override
  protected String getXMLElementName() {
    return ELEMENT_TASK_SCRIPT;
  }
  
  @Override
  protected BaseElement convertXMLToElement(XMLStreamReader xtr, BpmnModel model) throws Exception {
    ScriptTask scriptTask = new ScriptTask();
    BpmnXMLUtil.addXMLLocation(scriptTask, xtr);
    scriptTask.setScriptFormat(xtr.getAttributeValue(null, ATTRIBUTE_TASK_SCRIPT_FORMAT));
    scriptTask.setResultVariable(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SCRIPT_RESULTVARIABLE));
    if (StringUtils.isEmpty(scriptTask.getResultVariable())) {
      scriptTask.setResultVariable(xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SERVICE_RESULTVARIABLE));
    }
    String autoStoreVariables = xtr.getAttributeValue(ACTIVITI_EXTENSIONS_NAMESPACE, ATTRIBUTE_TASK_SCRIPT_AUTO_STORE_VARIABLE);
    if (StringUtils.isNotEmpty(autoStoreVariables)) {
      scriptTask.setAutoStoreVariables(Boolean.valueOf(autoStoreVariables));
    }
    parseChildElements(getXMLElementName(), scriptTask, childParserMap, model, xtr);
    return scriptTask;
  }

  @Override
  protected void writeAdditionalAttributes(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    ScriptTask scriptTask = (ScriptTask) element;
    writeDefaultAttribute(ATTRIBUTE_TASK_SCRIPT_FORMAT, scriptTask.getScriptFormat(), xtw);
    writeQualifiedAttribute(ATTRIBUTE_TASK_SCRIPT_RESULTVARIABLE, scriptTask.getResultVariable(), xtw);
    writeQualifiedAttribute(ATTRIBUTE_TASK_SCRIPT_AUTO_STORE_VARIABLE, String.valueOf(scriptTask.isAutoStoreVariables()), xtw);
  }
  
  @Override
  protected void writeAdditionalChildElements(BaseElement element, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    ScriptTask scriptTask = (ScriptTask) element;
    if (StringUtils.isNotEmpty(scriptTask.getScript())) {
      xtw.writeStartElement(ATTRIBUTE_TASK_SCRIPT_TEXT);
      xtw.writeCData(scriptTask.getScript());
      xtw.writeEndElement();
    }
  }
}
!@#$%
20190526_172117,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_b13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.XMLConstants;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.stax.StAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.converter.alfresco.AlfrescoStartEventXMLConverter;
import org.activiti.bpmn.converter.alfresco.AlfrescoUserTaskXMLConverter;
import org.activiti.bpmn.converter.child.DocumentationParser;
import org.activiti.bpmn.converter.child.IOSpecificationParser;
import org.activiti.bpmn.converter.child.MultiInstanceParser;
import org.activiti.bpmn.converter.export.ActivitiListenerExport;
import org.activiti.bpmn.converter.export.BPMNDIExport;
import org.activiti.bpmn.converter.export.CollaborationExport;
import org.activiti.bpmn.converter.export.DataStoreExport;
import org.activiti.bpmn.converter.export.DefinitionsRootExport;
import org.activiti.bpmn.converter.export.MultiInstanceExport;
import org.activiti.bpmn.converter.export.ProcessExport;
import org.activiti.bpmn.converter.export.SignalAndMessageDefinitionExport;
import org.activiti.bpmn.converter.parser.BpmnEdgeParser;
import org.activiti.bpmn.converter.parser.BpmnShapeParser;
import org.activiti.bpmn.converter.parser.DataStoreParser;
import org.activiti.bpmn.converter.parser.DefinitionsParser;
import org.activiti.bpmn.converter.parser.ExtensionElementsParser;
import org.activiti.bpmn.converter.parser.ImportParser;
import org.activiti.bpmn.converter.parser.InterfaceParser;
import org.activiti.bpmn.converter.parser.ItemDefinitionParser;
import org.activiti.bpmn.converter.parser.LaneParser;
import org.activiti.bpmn.converter.parser.MessageFlowParser;
import org.activiti.bpmn.converter.parser.MessageParser;
import org.activiti.bpmn.converter.parser.ParticipantParser;
import org.activiti.bpmn.converter.parser.PotentialStarterParser;
import org.activiti.bpmn.converter.parser.ProcessParser;
import org.activiti.bpmn.converter.parser.ResourceParser;
import org.activiti.bpmn.converter.parser.SignalParser;
import org.activiti.bpmn.converter.parser.SubProcessParser;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.converter.util.InputStreamProvider;
import org.activiti.bpmn.exceptions.XMLException;
import org.activiti.bpmn.model.Activity;
import org.activiti.bpmn.model.AdhocSubProcess;
import org.activiti.bpmn.model.Artifact;
import org.activiti.bpmn.model.Association;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BooleanDataObject;
import org.activiti.bpmn.model.BoundaryEvent;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.DateDataObject;
import org.activiti.bpmn.model.DoubleDataObject;
import org.activiti.bpmn.model.EventSubProcess;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.FlowNode;
import org.activiti.bpmn.model.IntegerDataObject;
import org.activiti.bpmn.model.LongDataObject;
import org.activiti.bpmn.model.Pool;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.SequenceFlow;
import org.activiti.bpmn.model.StringDataObject;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.TextAnnotation;
import org.activiti.bpmn.model.Transaction;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

/**
 * @author Tijs Rademakers
 * @author Joram Barrez
 */
public class BpmnXMLConverter implements BpmnXMLConstants {

  protected static final Logger LOGGER = LoggerFactory.getLogger(BpmnXMLConverter.class);

  protected static final String BPMN_XSD = "org/activiti/impl/bpmn/parser/BPMN20.xsd";
  protected static final String DEFAULT_ENCODING = "UTF-8";

  protected static Map<String, BaseBpmnXMLConverter> convertersToBpmnMap = new HashMap<String, BaseBpmnXMLConverter>();
  protected static Map<Class<? extends BaseElement>, BaseBpmnXMLConverter> convertersToXMLMap = new HashMap<Class<? extends BaseElement>, BaseBpmnXMLConverter>();

  protected ClassLoader classloader;
  protected List<String> userTaskFormTypes;
  protected List<String> startEventFormTypes;

  protected BpmnEdgeParser bpmnEdgeParser = new BpmnEdgeParser();
  protected BpmnShapeParser bpmnShapeParser = new BpmnShapeParser();
  protected DefinitionsParser definitionsParser = new DefinitionsParser();
  protected DocumentationParser documentationParser = new DocumentationParser();
  protected ExtensionElementsParser extensionElementsParser = new ExtensionElementsParser();
  protected ImportParser importParser = new ImportParser();
  protected InterfaceParser interfaceParser = new InterfaceParser();
  protected ItemDefinitionParser itemDefinitionParser = new ItemDefinitionParser();
  protected IOSpecificationParser ioSpecificationParser = new IOSpecificationParser();
  protected DataStoreParser dataStoreParser = new DataStoreParser();
  protected LaneParser laneParser = new LaneParser();
  protected MessageParser messageParser = new MessageParser();
  protected MessageFlowParser messageFlowParser = new MessageFlowParser();
  protected MultiInstanceParser multiInstanceParser = new MultiInstanceParser();
  protected ParticipantParser participantParser = new ParticipantParser();
  protected PotentialStarterParser potentialStarterParser = new PotentialStarterParser();
  protected ProcessParser processParser = new ProcessParser();
  protected ResourceParser resourceParser = new ResourceParser();
  protected SignalParser signalParser = new SignalParser();
  protected SubProcessParser subProcessParser = new SubProcessParser();

  static {
    // events
    addConverter(new EndEventXMLConverter());
    addConverter(new StartEventXMLConverter());

    // tasks
    addConverter(new BusinessRuleTaskXMLConverter());
    addConverter(new ManualTaskXMLConverter());
    addConverter(new ReceiveTaskXMLConverter());
    addConverter(new ScriptTaskXMLConverter());
    addConverter(new ServiceTaskXMLConverter());
    addConverter(new SendTaskXMLConverter());
    addConverter(new UserTaskXMLConverter());
    addConverter(new TaskXMLConverter());
    addConverter(new CallActivityXMLConverter());

    // gateways
    addConverter(new EventGatewayXMLConverter());
    addConverter(new ExclusiveGatewayXMLConverter());
    addConverter(new InclusiveGatewayXMLConverter());
    addConverter(new ParallelGatewayXMLConverter());
    addConverter(new ComplexGatewayXMLConverter());

    // connectors
    addConverter(new SequenceFlowXMLConverter());

    // catch, throw and boundary event
    addConverter(new CatchEventXMLConverter());
    addConverter(new ThrowEventXMLConverter());
    addConverter(new BoundaryEventXMLConverter());

    // artifacts
    addConverter(new TextAnnotationXMLConverter());
    addConverter(new AssociationXMLConverter());

    // data store reference
    addConverter(new DataStoreReferenceXMLConverter());

    // data objects
    addConverter(new ValuedDataObjectXMLConverter(), StringDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), BooleanDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), IntegerDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), LongDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), DoubleDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), DateDataObject.class);

    // Alfresco types
    addConverter(new AlfrescoStartEventXMLConverter());
    addConverter(new AlfrescoUserTaskXMLConverter());
  }

  public static void addConverter(BaseBpmnXMLConverter converter) {
    addConverter(converter, converter.getBpmnElementType());
  }

  public static void addConverter(BaseBpmnXMLConverter converter, Class<? extends BaseElement> elementType) {
    convertersToBpmnMap.put(converter.getXMLElementName(), converter);
    convertersToXMLMap.put(elementType, converter);
  }

  public void setClassloader(ClassLoader classloader) {
    this.classloader = classloader;
  }

  public void setUserTaskFormTypes(List<String> userTaskFormTypes) {
    this.userTaskFormTypes = userTaskFormTypes;
  }

  public void setStartEventFormTypes(List<String> startEventFormTypes) {
    this.startEventFormTypes = startEventFormTypes;
  }

  public void validateModel(InputStreamProvider inputStreamProvider) throws Exception {
    Schema schema = createSchema();

    Validator validator = schema.newValidator();
    validator.validate(new StreamSource(inputStreamProvider.getInputStream()));
  }

  public void validateModel(XMLStreamReader xmlStreamReader) throws Exception {
    Schema schema = createSchema();

    Validator validator = schema.newValidator();
    validator.validate(new StAXSource(xmlStreamReader));
  }

  protected Schema createSchema() throws SAXException {
    SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    Schema schema = null;
    if (classloader != null) {
      schema = factory.newSchema(classloader.getResource(BPMN_XSD));
    }

    if (schema == null) {
      schema = factory.newSchema(BpmnXMLConverter.class.getClassLoader().getResource(BPMN_XSD));
    }

    if (schema == null) {
      throw new XMLException("BPMN XSD could not be found");
    }
    return schema;
  }

  public BpmnModel convertToBpmnModel(InputStreamProvider inputStreamProvider, boolean validateSchema, boolean enableSafeBpmnXml) {
    return convertToBpmnModel(inputStreamProvider, validateSchema, enableSafeBpmnXml, DEFAULT_ENCODING);
  }

  public BpmnModel convertToBpmnModel(InputStreamProvider inputStreamProvider, boolean validateSchema, boolean enableSafeBpmnXml, String encoding) {
    XMLInputFactory xif = XMLInputFactory.newInstance();

    if (xif.isPropertySupported(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES)) {
      xif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);
    }

    if (xif.isPropertySupported(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES)) {
      xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    }

    if (xif.isPropertySupported(XMLInputFactory.SUPPORT_DTD)) {
      xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    }

    InputStreamReader in = null;
    try {
      in = new InputStreamReader(inputStreamProvider.getInputStream(), encoding);
      XMLStreamReader xtr = xif.createXMLStreamReader(in);

      try {
        if (validateSchema) {

          if (!enableSafeBpmnXml) {
            validateModel(inputStreamProvider);
          } else {
            validateModel(xtr);
          }

          // The input stream is closed after schema validation
          in = new InputStreamReader(inputStreamProvider.getInputStream(), encoding);
          xtr = xif.createXMLStreamReader(in);
        }

      } catch (Exception e) {
        throw new XMLException(e.getMessage(), e);
      }

      // XML conversion
      return convertToBpmnModel(xtr);
    } catch (UnsupportedEncodingException e) {
      throw new XMLException("The bpmn 2.0 xml is not UTF8 encoded", e);
    } catch (XMLStreamException e) {
      throw new XMLException("Error while reading the BPMN 2.0 XML", e);
    } finally {
      if (in != null) {
        try {
          in.close();
        } catch (IOException e) {
          LOGGER.debug("Problem closing BPMN input stream", e);
        }
      }
    }
  }

  public BpmnModel convertToBpmnModel(XMLStreamReader xtr) {
    BpmnModel model = new BpmnModel();
    model.setStartEventFormTypes(startEventFormTypes);
    model.setUserTaskFormTypes(userTaskFormTypes);
    try {
      Process activeProcess = null;
      List<SubProcess> activeSubProcessList = new ArrayList<SubProcess>();
      while (xtr.hasNext()) {
        try {
          xtr.next();
        } catch (Exception e) {
          LOGGER.debug("Error reading XML document", e);
          throw new XMLException("Error reading XML", e);
        }

        if (xtr.isEndElement() && (ELEMENT_SUBPROCESS.equals(xtr.getLocalName()) || 
            ELEMENT_TRANSACTION.equals(xtr.getLocalName()) ||
            ELEMENT_ADHOC_SUBPROCESS.equals(xtr.getLocalName()))) {
          
          activeSubProcessList.remove(activeSubProcessList.size() - 1);
        }

        if (xtr.isStartElement() == false) {
          continue;
        }

				if (ELEMENT_DEFINITIONS.equals(xtr.getLocalName())) {
				  definitionsParser.parse(xtr, model);
				  
        } else if (ELEMENT_RESOURCE.equals(xtr.getLocalName())) {
          resourceParser.parse(xtr, model);
          
				} else if (ELEMENT_SIGNAL.equals(xtr.getLocalName())) {
					signalParser.parse(xtr, model);
					
				} else if (ELEMENT_MESSAGE.equals(xtr.getLocalName())) {
          messageParser.parse(xtr, model);

        } else if (ELEMENT_ERROR.equals(xtr.getLocalName())) {

          if (StringUtils.isNotEmpty(xtr.getAttributeValue(null, ATTRIBUTE_ID))) {
            model.addError(xtr.getAttributeValue(null, ATTRIBUTE_ID), xtr.getAttributeValue(null, ATTRIBUTE_ERROR_CODE));
          }

        } else if (ELEMENT_IMPORT.equals(xtr.getLocalName())) {
          importParser.parse(xtr, model);

        } else if (ELEMENT_ITEM_DEFINITION.equals(xtr.getLocalName())) {
          itemDefinitionParser.parse(xtr, model);

        } else if (ELEMENT_DATA_STORE.equals(xtr.getLocalName())) {
          dataStoreParser.parse(xtr, model);

        } else if (ELEMENT_INTERFACE.equals(xtr.getLocalName())) {
          interfaceParser.parse(xtr, model);

        } else if (ELEMENT_IOSPECIFICATION.equals(xtr.getLocalName())) {
          ioSpecificationParser.parseChildElement(xtr, activeProcess, model);

        } else if (ELEMENT_PARTICIPANT.equals(xtr.getLocalName())) {
          participantParser.parse(xtr, model);

        } else if (ELEMENT_MESSAGE_FLOW.equals(xtr.getLocalName())) {
          messageFlowParser.parse(xtr, model);

        } else if (ELEMENT_PROCESS.equals(xtr.getLocalName())) {

          Process process = processParser.parse(xtr, model);
          if (process != null) {
            activeProcess = process;
          }

        } else if (ELEMENT_POTENTIAL_STARTER.equals(xtr.getLocalName())) {
          potentialStarterParser.parse(xtr, activeProcess);

        } else if (ELEMENT_LANE.equals(xtr.getLocalName())) {
          laneParser.parse(xtr, activeProcess, model);

        } else if (ELEMENT_DOCUMENTATION.equals(xtr.getLocalName())) {

          BaseElement parentElement = null;
          if (!activeSubProcessList.isEmpty()) {
            parentElement = activeSubProcessList.get(activeSubProcessList.size() - 1);
          } else if (activeProcess != null) {
            parentElement = activeProcess;
          }
          documentationParser.parseChildElement(xtr, parentElement, model);

        } else if (activeProcess == null && ELEMENT_TEXT_ANNOTATION.equals(xtr.getLocalName())) {
          String elementId = xtr.getAttributeValue(null, ATTRIBUTE_ID);
          TextAnnotation textAnnotation = (TextAnnotation) new TextAnnotationXMLConverter().convertXMLToElement(xtr, model);
          textAnnotation.setId(elementId);
          model.getGlobalArtifacts().add(textAnnotation);

        } else if (activeProcess == null && ELEMENT_ASSOCIATION.equals(xtr.getLocalName())) {
          String elementId = xtr.getAttributeValue(null, ATTRIBUTE_ID);
          Association association = (Association) new AssociationXMLConverter().convertXMLToElement(xtr, model);
          association.setId(elementId);
          model.getGlobalArtifacts().add(association);

        } else if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
          extensionElementsParser.parse(xtr, activeSubProcessList, activeProcess, model);

        } else if (ELEMENT_SUBPROCESS.equals(xtr.getLocalName()) || ELEMENT_TRANSACTION.equals(xtr.getLocalName()) || ELEMENT_ADHOC_SUBPROCESS.equals(xtr.getLocalName())) {
          subProcessParser.parse(xtr, activeSubProcessList, activeProcess);
          
        } else if (ELEMENT_COMPLETION_CONDITION.equals(xtr.getLocalName())) {
          if (!activeSubProcessList.isEmpty()) {
            SubProcess subProcess = activeSubProcessList.get(activeSubProcessList.size() - 1);
            if (subProcess instanceof AdhocSubProcess) {
              AdhocSubProcess adhocSubProcess = (AdhocSubProcess) subProcess;
              adhocSubProcess.setCompletionCondition(xtr.getElementText());
            }
          }

        } else if (ELEMENT_DI_SHAPE.equals(xtr.getLocalName())) {
          bpmnShapeParser.parse(xtr, model);

        } else if (ELEMENT_DI_EDGE.equals(xtr.getLocalName())) {
          bpmnEdgeParser.parse(xtr, model);

        } else {

          if (!activeSubProcessList.isEmpty() && ELEMENT_MULTIINSTANCE.equalsIgnoreCase(xtr.getLocalName())) {

            multiInstanceParser.parseChildElement(xtr, activeSubProcessList.get(activeSubProcessList.size() - 1), model);

          } else if (convertersToBpmnMap.containsKey(xtr.getLocalName())) {
            if (activeProcess != null) {
              BaseBpmnXMLConverter converter = convertersToBpmnMap.get(xtr.getLocalName());
              converter.convertToBpmnModel(xtr, model, activeProcess, activeSubProcessList);
            }
          }
        }
      }

      for (Process process : model.getProcesses()) {
        for (Pool pool : model.getPools()) {
          if (process.getId().equals(pool.getProcessRef())) {
            pool.setExecutable(process.isExecutable());
          }
        }
        processFlowElements(process.getFlowElements(), process);
      }

    } catch (XMLException e) {
      throw e;

    } catch (Exception e) {
      LOGGER.error("Error processing BPMN document", e);
      throw new XMLException("Error processing BPMN document", e);
    }
    return model;
  }

  protected void processFlowElements(Collection<FlowElement> flowElementList, BaseElement parentScope) {
    for (FlowElement flowElement : flowElementList) {
      if (flowElement instanceof SequenceFlow) {
        SequenceFlow sequenceFlow = (SequenceFlow) flowElement;
        FlowNode sourceNode = getFlowNodeFromScope(sequenceFlow.getSourceRef(), parentScope);
        if (sourceNode != null) {
          sourceNode.getOutgoingFlows().add(sequenceFlow);
          sequenceFlow.setSourceFlowElement(sourceNode);
        }
        
        FlowNode targetNode = getFlowNodeFromScope(sequenceFlow.getTargetRef(), parentScope);
        if (targetNode != null) {
          targetNode.getIncomingFlows().add(sequenceFlow);
          sequenceFlow.setTargetFlowElement(targetNode);
        }
        
      } else if (flowElement instanceof BoundaryEvent) {
        BoundaryEvent boundaryEvent = (BoundaryEvent) flowElement;
        FlowElement attachedToElement = getFlowNodeFromScope(boundaryEvent.getAttachedToRefId(), parentScope);
        if (attachedToElement instanceof Activity) {
          Activity attachedActivity = (Activity) attachedToElement;
          boundaryEvent.setAttachedToRef(attachedActivity);
          attachedActivity.getBoundaryEvents().add(boundaryEvent);
        }
        
      } else if (flowElement instanceof SubProcess) {
        SubProcess subProcess = (SubProcess) flowElement;
        processFlowElements(subProcess.getFlowElements(), subProcess);
      }
    }
  }

  protected FlowNode getFlowNodeFromScope(String elementId, BaseElement scope) {
    FlowNode flowNode = null;
    if (StringUtils.isNotEmpty(elementId)) {
      if (scope instanceof Process) {
        flowNode = (FlowNode) ((Process) scope).getFlowElement(elementId);
      } else if (scope instanceof SubProcess) {
        flowNode = (FlowNode) ((SubProcess) scope).getFlowElement(elementId);
      }
    }
    return flowNode;
  }

  public byte[] convertToXML(BpmnModel model) {
    return convertToXML(model, DEFAULT_ENCODING);
  }

  public byte[] convertToXML(BpmnModel model, String encoding) {
    try {

      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

      XMLOutputFactory xof = XMLOutputFactory.newInstance();
      OutputStreamWriter out = new OutputStreamWriter(outputStream, encoding);

      XMLStreamWriter writer = xof.createXMLStreamWriter(out);
      XMLStreamWriter xtw = new IndentingXMLStreamWriter(writer);

      DefinitionsRootExport.writeRootElement(model, xtw, encoding);
      CollaborationExport.writePools(model, xtw);
      DataStoreExport.writeDataStores(model, xtw);
      SignalAndMessageDefinitionExport.writeSignalsAndMessages(model, xtw);

      for (Process process : model.getProcesses()) {

        if (process.getFlowElements().isEmpty() && process.getLanes().isEmpty()) {
          // empty process, ignore it
          continue;
        }

        ProcessExport.writeProcess(process, xtw);

        for (FlowElement flowElement : process.getFlowElements()) {
          createXML(flowElement, model, xtw);
        }

        for (Artifact artifact : process.getArtifacts()) {
          createXML(artifact, model, xtw);
        }

        // end process element
        xtw.writeEndElement();
      }

      BPMNDIExport.writeBPMNDI(model, xtw);

      // end definitions root element
      xtw.writeEndElement();
      xtw.writeEndDocument();

      xtw.flush();

      outputStream.close();

      xtw.close();

      return outputStream.toByteArray();

    } catch (Exception e) {
      LOGGER.error("Error writing BPMN XML", e);
      throw new XMLException("Error writing BPMN XML", e);
    }
  }

  protected void createXML(FlowElement flowElement, BpmnModel model, XMLStreamWriter xtw) throws Exception {

    if (flowElement instanceof SubProcess) {

      SubProcess subProcess = (SubProcess) flowElement;
      if (flowElement instanceof Transaction) {
        xtw.writeStartElement(ELEMENT_TRANSACTION);
      } else if (flowElement instanceof AdhocSubProcess) {
        xtw.writeStartElement(ELEMENT_ADHOC_SUBPROCESS);
      } else {
        xtw.writeStartElement(ELEMENT_SUBPROCESS);
      }
      
      xtw.writeAttribute(ATTRIBUTE_ID, subProcess.getId());
      if (StringUtils.isNotEmpty(subProcess.getName())) {
        xtw.writeAttribute(ATTRIBUTE_NAME, subProcess.getName());
      } else {
        xtw.writeAttribute(ATTRIBUTE_NAME, "subProcess");
      }

      if (subProcess instanceof EventSubProcess) {
        xtw.writeAttribute(ATTRIBUTE_TRIGGERED_BY, ATTRIBUTE_VALUE_TRUE);
        
      } else if (subProcess instanceof Transaction == false) {
        if (subProcess.isAsynchronous()) {
          BpmnXMLUtil.writeQualifiedAttribute(ATTRIBUTE_ACTIVITY_ASYNCHRONOUS, ATTRIBUTE_VALUE_TRUE, xtw);
          if (subProcess.isNotExclusive()) {
            BpmnXMLUtil.writeQualifiedAttribute(ATTRIBUTE_ACTIVITY_EXCLUSIVE, ATTRIBUTE_VALUE_FALSE, xtw);
          }
        }
        
      } else if (subProcess instanceof AdhocSubProcess) {
        AdhocSubProcess adhocSubProcess = (AdhocSubProcess) subProcess;
        BpmnXMLUtil.writeDefaultAttribute(ATTRIBUTE_CANCEL_REMAINING_INSTANCES, String.valueOf(adhocSubProcess.isCancelRemainingInstances()), xtw);
        if (StringUtils.isNotEmpty(adhocSubProcess.getOrdering())) {
          BpmnXMLUtil.writeDefaultAttribute(ATTRIBUTE_ORDERING, adhocSubProcess.getOrdering(), xtw);
        }
      }

      if (StringUtils.isNotEmpty(subProcess.getDocumentation())) {

        xtw.writeStartElement(ELEMENT_DOCUMENTATION);
        xtw.writeCharacters(subProcess.getDocumentation());
        xtw.writeEndElement();
      }

      boolean didWriteExtensionStartElement = ActivitiListenerExport.writeListeners(subProcess, false, xtw);

      didWriteExtensionStartElement = BpmnXMLUtil.writeExtensionElements(subProcess, didWriteExtensionStartElement, model.getNamespaces(), xtw);
      if (didWriteExtensionStartElement) {
        // closing extensions element
        xtw.writeEndElement();
      }

      MultiInstanceExport.writeMultiInstance(subProcess, xtw);
      
      if (subProcess instanceof AdhocSubProcess) {
        AdhocSubProcess adhocSubProcess = (AdhocSubProcess) subProcess;
        if (StringUtils.isNotEmpty(adhocSubProcess.getCompletionCondition())) {
          xtw.writeStartElement(ELEMENT_COMPLETION_CONDITION);
          xtw.writeCData(adhocSubProcess.getCompletionCondition());
          xtw.writeEndElement();
        }
      }

      for (FlowElement subElement : subProcess.getFlowElements()) {
        createXML(subElement, model, xtw);
      }

      for (Artifact artifact : subProcess.getArtifacts()) {
        createXML(artifact, model, xtw);
      }

      xtw.writeEndElement();

    } else {

      BaseBpmnXMLConverter converter = convertersToXMLMap.get(flowElement.getClass());

      if (converter == null) {
        throw new XMLException("No converter for " + flowElement.getClass() + " found");
      }

      converter.convertToXML(xtw, flowElement, model);
    }
  }

  protected void createXML(Artifact artifact, BpmnModel model, XMLStreamWriter xtw) throws Exception {

    BaseBpmnXMLConverter converter = convertersToXMLMap.get(artifact.getClass());

    if (converter == null) {
      throw new XMLException("No converter for " + artifact.getClass() + " found");
    }

    converter.convertToXML(xtw, artifact, model);
  }
}
!@#$%
20190526_172117,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_a13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.XMLConstants;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.stax.StAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.converter.alfresco.AlfrescoStartEventXMLConverter;
import org.activiti.bpmn.converter.alfresco.AlfrescoUserTaskXMLConverter;
import org.activiti.bpmn.converter.child.DocumentationParser;
import org.activiti.bpmn.converter.child.IOSpecificationParser;
import org.activiti.bpmn.converter.child.MultiInstanceParser;
import org.activiti.bpmn.converter.export.ActivitiListenerExport;
import org.activiti.bpmn.converter.export.BPMNDIExport;
import org.activiti.bpmn.converter.export.CollaborationExport;
import org.activiti.bpmn.converter.export.DataStoreExport;
import org.activiti.bpmn.converter.export.DefinitionsRootExport;
import org.activiti.bpmn.converter.export.MultiInstanceExport;
import org.activiti.bpmn.converter.export.ProcessExport;
import org.activiti.bpmn.converter.export.SignalAndMessageDefinitionExport;
import org.activiti.bpmn.converter.parser.BpmnEdgeParser;
import org.activiti.bpmn.converter.parser.BpmnShapeParser;
import org.activiti.bpmn.converter.parser.DataStoreParser;
import org.activiti.bpmn.converter.parser.DefinitionsParser;
import org.activiti.bpmn.converter.parser.ExtensionElementsParser;
import org.activiti.bpmn.converter.parser.ImportParser;
import org.activiti.bpmn.converter.parser.InterfaceParser;
import org.activiti.bpmn.converter.parser.ItemDefinitionParser;
import org.activiti.bpmn.converter.parser.LaneParser;
import org.activiti.bpmn.converter.parser.MessageFlowParser;
import org.activiti.bpmn.converter.parser.MessageParser;
import org.activiti.bpmn.converter.parser.ParticipantParser;
import org.activiti.bpmn.converter.parser.PotentialStarterParser;
import org.activiti.bpmn.converter.parser.ProcessParser;
import org.activiti.bpmn.converter.parser.ResourceParser;
import org.activiti.bpmn.converter.parser.SignalParser;
import org.activiti.bpmn.converter.parser.SubProcessParser;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.converter.util.InputStreamProvider;
import org.activiti.bpmn.exceptions.XMLException;
import org.activiti.bpmn.model.Activity;
import org.activiti.bpmn.model.Artifact;
import org.activiti.bpmn.model.Association;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BooleanDataObject;
import org.activiti.bpmn.model.BoundaryEvent;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.DateDataObject;
import org.activiti.bpmn.model.DoubleDataObject;
import org.activiti.bpmn.model.EventSubProcess;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.FlowNode;
import org.activiti.bpmn.model.IntegerDataObject;
import org.activiti.bpmn.model.LongDataObject;
import org.activiti.bpmn.model.Pool;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.SequenceFlow;
import org.activiti.bpmn.model.StringDataObject;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.TextAnnotation;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

/**
 * @author Tijs Rademakers
 * @author Joram Barrez
 */
public class BpmnXMLConverter implements BpmnXMLConstants {

  protected static final Logger LOGGER = LoggerFactory.getLogger(BpmnXMLConverter.class);
	
  protected static final String BPMN_XSD = "org/activiti/impl/bpmn/parser/BPMN20.xsd";
  protected static final String DEFAULT_ENCODING = "UTF-8";
  
	protected static Map<String, BaseBpmnXMLConverter> convertersToBpmnMap = new HashMap<String, BaseBpmnXMLConverter>();
	protected static Map<Class<? extends BaseElement>, BaseBpmnXMLConverter> convertersToXMLMap = 
	    new HashMap<Class<? extends BaseElement>, BaseBpmnXMLConverter>();
	
	protected ClassLoader classloader;
	protected List<String> userTaskFormTypes;
	protected List<String> startEventFormTypes;
	
	protected BpmnEdgeParser bpmnEdgeParser = new BpmnEdgeParser();
	protected BpmnShapeParser bpmnShapeParser = new BpmnShapeParser();
	protected DefinitionsParser definitionsParser = new DefinitionsParser();
	protected DocumentationParser documentationParser = new DocumentationParser();
	protected ExtensionElementsParser extensionElementsParser = new ExtensionElementsParser();
	protected ImportParser importParser = new ImportParser();
	protected InterfaceParser interfaceParser = new InterfaceParser();
  protected ItemDefinitionParser itemDefinitionParser = new ItemDefinitionParser();
  protected IOSpecificationParser ioSpecificationParser = new IOSpecificationParser();
  protected DataStoreParser dataStoreParser = new DataStoreParser();
  protected LaneParser laneParser = new LaneParser();
  protected MessageParser messageParser = new MessageParser();
  protected MessageFlowParser messageFlowParser = new MessageFlowParser();
  protected MultiInstanceParser multiInstanceParser = new MultiInstanceParser();
  protected ParticipantParser participantParser = new ParticipantParser();
  protected PotentialStarterParser potentialStarterParser = new PotentialStarterParser();
  protected ProcessParser processParser = new ProcessParser();
  protected ResourceParser resourceParser = new ResourceParser();
  protected SignalParser signalParser = new SignalParser();
  protected SubProcessParser subProcessParser = new SubProcessParser();
	
	static {
		// events
	  addConverter(new EndEventXMLConverter());
	  addConverter(new StartEventXMLConverter());
    
    // tasks
	  addConverter(new BusinessRuleTaskXMLConverter());
    addConverter(new ManualTaskXMLConverter());
    addConverter(new ReceiveTaskXMLConverter());
    addConverter(new ScriptTaskXMLConverter());
    addConverter(new ServiceTaskXMLConverter());
    addConverter(new SendTaskXMLConverter());
    addConverter(new UserTaskXMLConverter());
    addConverter(new TaskXMLConverter());
    addConverter(new CallActivityXMLConverter());
    
    // gateways
    addConverter(new EventGatewayXMLConverter());
    addConverter(new ExclusiveGatewayXMLConverter());
    addConverter(new InclusiveGatewayXMLConverter());
    addConverter(new ParallelGatewayXMLConverter());
    addConverter(new ComplexGatewayXMLConverter());
    
    // connectors
    addConverter(new SequenceFlowXMLConverter());
    
    // catch, throw and boundary event
    addConverter(new CatchEventXMLConverter());
    addConverter(new ThrowEventXMLConverter());
    addConverter(new BoundaryEventXMLConverter());
    
    // artifacts
    addConverter(new TextAnnotationXMLConverter());
    addConverter(new AssociationXMLConverter());
    
    // data store reference
    addConverter(new DataStoreReferenceXMLConverter());
    
    // data objects
    addConverter(new ValuedDataObjectXMLConverter(), StringDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), BooleanDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), IntegerDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), LongDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), DoubleDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), DateDataObject.class);
    
    // Alfresco types
    addConverter(new AlfrescoStartEventXMLConverter());
    addConverter(new AlfrescoUserTaskXMLConverter());
  }
  
  public static void addConverter(BaseBpmnXMLConverter converter) {
    addConverter(converter, converter.getBpmnElementType());
  }
  
  public static void addConverter(BaseBpmnXMLConverter converter, Class<? extends BaseElement> elementType) {
    convertersToBpmnMap.put(converter.getXMLElementName(), converter);
    convertersToXMLMap.put(elementType, converter);
  }
  
  public void setClassloader(ClassLoader classloader) {
    this.classloader = classloader;
  }

  public void setUserTaskFormTypes(List<String> userTaskFormTypes) {
    this.userTaskFormTypes = userTaskFormTypes;
  }
  
  public void setStartEventFormTypes(List<String> startEventFormTypes) {
    this.startEventFormTypes = startEventFormTypes;
  }
  
  public void validateModel(InputStreamProvider inputStreamProvider) throws Exception {
    Schema schema = createSchema();
    
    Validator validator = schema.newValidator();
    validator.validate(new StreamSource(inputStreamProvider.getInputStream()));
  }
  
  public void validateModel(XMLStreamReader xmlStreamReader) throws Exception {
    Schema schema = createSchema();
    
    Validator validator = schema.newValidator();
    validator.validate(new StAXSource(xmlStreamReader));
  }

  protected Schema createSchema() throws SAXException {
    SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    Schema schema = null;
    if (classloader != null) {
      schema = factory.newSchema(classloader.getResource(BPMN_XSD));
    }
    
    if (schema == null) {
      schema = factory.newSchema(BpmnXMLConverter.class.getClassLoader().getResource(BPMN_XSD));
    }
    
    if (schema == null) {
      throw new XMLException("BPMN XSD could not be found");
    }
    return schema;
  }
  
  public BpmnModel convertToBpmnModel(InputStreamProvider inputStreamProvider, boolean validateSchema, boolean enableSafeBpmnXml) {
    return convertToBpmnModel(inputStreamProvider, validateSchema, enableSafeBpmnXml, DEFAULT_ENCODING);
  }
  
  public BpmnModel convertToBpmnModel(InputStreamProvider inputStreamProvider, boolean validateSchema, boolean enableSafeBpmnXml, String encoding) {
    XMLInputFactory xif = XMLInputFactory.newInstance();

    if (xif.isPropertySupported(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES)) {
      xif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);
    }

    if (xif.isPropertySupported(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES)) {
      xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    }

    if (xif.isPropertySupported(XMLInputFactory.SUPPORT_DTD)) {
      xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    }

    InputStreamReader in = null;
    try {
      in = new InputStreamReader(inputStreamProvider.getInputStream(), encoding);
      XMLStreamReader xtr = xif.createXMLStreamReader(in);
  
      try {
        if (validateSchema) {
          
          if (!enableSafeBpmnXml) {
            validateModel(inputStreamProvider);
          } else {
            validateModel(xtr);
          }
  
          // The input stream is closed after schema validation
          in = new InputStreamReader(inputStreamProvider.getInputStream(), encoding);
          xtr = xif.createXMLStreamReader(in);
        }
  
      } catch (Exception e) {
        throw new XMLException(e.getMessage(), e);
      }
  
      // XML conversion
      return convertToBpmnModel(xtr);
    } catch (UnsupportedEncodingException e) {
      throw new XMLException("The bpmn 2.0 xml is not UTF8 encoded", e);
    } catch (XMLStreamException e) {
      throw new XMLException("Error while reading the BPMN 2.0 XML", e);
    } finally {
      if (in != null) {
        try {
          in.close();
        } catch (IOException e) {
          LOGGER.debug("Problem closing BPMN input stream", e);
        }
      }
    }
  }

	public BpmnModel convertToBpmnModel(XMLStreamReader xtr) { 
	  BpmnModel model = new BpmnModel();
	  model.setStartEventFormTypes(startEventFormTypes);
	  model.setUserTaskFormTypes(userTaskFormTypes);
		try {
			Process activeProcess = null;
			List<SubProcess> activeSubProcessList = new ArrayList<SubProcess>();
			while (xtr.hasNext()) {
				try {
					xtr.next();
				} catch(Exception e) {
					LOGGER.debug("Error reading XML document", e);
					throw new XMLException("Error reading XML", e);
				}

				if (xtr.isEndElement()  && ELEMENT_SUBPROCESS.equals(xtr.getLocalName())) {
					activeSubProcessList.remove(activeSubProcessList.size() - 1);
				}
				
				if (xtr.isEndElement()  && ELEMENT_TRANSACTION.equals(xtr.getLocalName())) {
          activeSubProcessList.remove(activeSubProcessList.size() - 1);
        }

				if (xtr.isStartElement() == false)
					continue;

				if (ELEMENT_DEFINITIONS.equals(xtr.getLocalName())) {
				  definitionsParser.parse(xtr, model);
                } else if (ELEMENT_RESOURCE.equals(xtr.getLocalName())) {
                    resourceParser.parse(xtr, model);
				} else if (ELEMENT_SIGNAL.equals(xtr.getLocalName())) {
					signalParser.parse(xtr, model);
					
				} else if (ELEMENT_MESSAGE.equals(xtr.getLocalName())) {
          messageParser.parse(xtr, model);
          
				} else if (ELEMENT_ERROR.equals(xtr.getLocalName())) {
          
          if (StringUtils.isNotEmpty(xtr.getAttributeValue(null, ATTRIBUTE_ID))) {
            model.addError(xtr.getAttributeValue(null, ATTRIBUTE_ID),
                xtr.getAttributeValue(null, ATTRIBUTE_ERROR_CODE));
          }
          
				} else if (ELEMENT_IMPORT.equals(xtr.getLocalName())) {
				  importParser.parse(xtr, model);
          
				} else if (ELEMENT_ITEM_DEFINITION.equals(xtr.getLocalName())) {
				  itemDefinitionParser.parse(xtr, model);
          
				} else if (ELEMENT_DATA_STORE.equals(xtr.getLocalName())) {
				  dataStoreParser.parse(xtr, model);
				  
				} else if (ELEMENT_INTERFACE.equals(xtr.getLocalName())) {
				  interfaceParser.parse(xtr, model);
				  
				} else if (ELEMENT_IOSPECIFICATION.equals(xtr.getLocalName())) {
				  ioSpecificationParser.parseChildElement(xtr, activeProcess, model);
					
				} else if (ELEMENT_PARTICIPANT.equals(xtr.getLocalName())) {
				  participantParser.parse(xtr, model);
				  
				} else if (ELEMENT_MESSAGE_FLOW.equals(xtr.getLocalName())) {
          messageFlowParser.parse(xtr, model);

				} else if (ELEMENT_PROCESS.equals(xtr.getLocalName())) {
					
				  Process process = processParser.parse(xtr, model);
				  if (process != null) {
            activeProcess = process;	
				  }
				
				} else if (ELEMENT_POTENTIAL_STARTER.equals(xtr.getLocalName())) {
				  potentialStarterParser.parse(xtr, activeProcess);
				  
				} else if (ELEMENT_LANE.equals(xtr.getLocalName())) {
          laneParser.parse(xtr, activeProcess, model);
					
				} else if (ELEMENT_DOCUMENTATION.equals(xtr.getLocalName())) {
				  
					BaseElement parentElement = null;
					if (!activeSubProcessList.isEmpty()) {
						parentElement = activeSubProcessList.get(activeSubProcessList.size() - 1);
					} else if (activeProcess != null) {
						parentElement = activeProcess;
					}
					documentationParser.parseChildElement(xtr, parentElement, model);
				
				} else if (activeProcess == null && ELEMENT_TEXT_ANNOTATION.equals(xtr.getLocalName())) {
				  String elementId = xtr.getAttributeValue(null, ATTRIBUTE_ID);
          TextAnnotation textAnnotation = (TextAnnotation) new TextAnnotationXMLConverter().convertXMLToElement(xtr, model);
          textAnnotation.setId(elementId);
          model.getGlobalArtifacts().add(textAnnotation);
          
				} else if (activeProcess == null && ELEMENT_ASSOCIATION.equals(xtr.getLocalName())) {
          String elementId = xtr.getAttributeValue(null, ATTRIBUTE_ID);
          Association association = (Association) new AssociationXMLConverter().convertXMLToElement(xtr, model);
          association.setId(elementId);
          model.getGlobalArtifacts().add(association);
				
				} else if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
				  extensionElementsParser.parse(xtr, activeSubProcessList, activeProcess, model);
				
				} else if (ELEMENT_SUBPROCESS.equals(xtr.getLocalName())) {
          subProcessParser.parse(xtr, activeSubProcessList, activeProcess);
          
				} else if (ELEMENT_TRANSACTION.equals(xtr.getLocalName())) {
          subProcessParser.parse(xtr, activeSubProcessList, activeProcess);
					
				} else if (ELEMENT_DI_SHAPE.equals(xtr.getLocalName())) {
          bpmnShapeParser.parse(xtr, model);
				
				} else if (ELEMENT_DI_EDGE.equals(xtr.getLocalName())) {
				  bpmnEdgeParser.parse(xtr, model);

				} else {

					if (!activeSubProcessList.isEmpty() && ELEMENT_MULTIINSTANCE.equalsIgnoreCase(xtr.getLocalName())) {
						
					  multiInstanceParser.parseChildElement(xtr, activeSubProcessList.get(activeSubProcessList.size() - 1), model);
					  
					} else if (convertersToBpmnMap.containsKey(xtr.getLocalName())) {
					  if (activeProcess != null) {
  					  BaseBpmnXMLConverter converter = convertersToBpmnMap.get(xtr.getLocalName());
  					  converter.convertToBpmnModel(xtr, model, activeProcess, activeSubProcessList);
					  }
					}
				}
			}

			for (Process process : model.getProcesses()) {
			  for (Pool pool : model.getPools()) {
			    if (process.getId().equals(pool.getProcessRef())) {
			      pool.setExecutable(process.isExecutable());
			    }
			  }
			  processFlowElements(process.getFlowElements(), process);
			}
		
		} catch (XMLException e) {
		  throw e;
		  
		} catch (Exception e) {
			LOGGER.error("Error processing BPMN document", e);
			throw new XMLException("Error processing BPMN document", e);
		}
		return model;
	}
	
	private void processFlowElements(Collection<FlowElement> flowElementList, BaseElement parentScope) {
	  for (FlowElement flowElement : flowElementList) {
  	  if (flowElement instanceof SequenceFlow) {
        SequenceFlow sequenceFlow = (SequenceFlow) flowElement;
        FlowNode sourceNode = getFlowNodeFromScope(sequenceFlow.getSourceRef(), parentScope);
        if (sourceNode != null) {
          sourceNode.getOutgoingFlows().add(sequenceFlow);
        }
        FlowNode targetNode = getFlowNodeFromScope(sequenceFlow.getTargetRef(), parentScope);
        if (targetNode != null) {
          targetNode.getIncomingFlows().add(sequenceFlow);
        }
      } else if (flowElement instanceof BoundaryEvent) {
        BoundaryEvent boundaryEvent = (BoundaryEvent) flowElement;
        FlowElement attachedToElement = getFlowNodeFromScope(boundaryEvent.getAttachedToRefId(), parentScope);
        if(attachedToElement != null) {
          boundaryEvent.setAttachedToRef((Activity) attachedToElement);
          ((Activity) attachedToElement).getBoundaryEvents().add(boundaryEvent);
        }
      } else if(flowElement instanceof SubProcess) {
        SubProcess subProcess = (SubProcess) flowElement;
        processFlowElements(subProcess.getFlowElements(), subProcess);
      }
	  }
	}
	
	private FlowNode getFlowNodeFromScope(String elementId, BaseElement scope) {
	  FlowNode flowNode = null;
	  if (StringUtils.isNotEmpty(elementId)) {
  	  if (scope instanceof Process) {
  	    flowNode = (FlowNode) ((Process) scope).getFlowElement(elementId);
  	  } else if (scope instanceof SubProcess) {
  	    flowNode = (FlowNode) ((SubProcess) scope).getFlowElement(elementId);
  	  }
	  }
	  return flowNode;
	}
	
	public byte[] convertToXML(BpmnModel model) {
	  return convertToXML(model, DEFAULT_ENCODING);
	}
	
	public byte[] convertToXML(BpmnModel model, String encoding) {
    try {

      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      
      XMLOutputFactory xof = XMLOutputFactory.newInstance();
      OutputStreamWriter out = new OutputStreamWriter(outputStream, encoding);

      XMLStreamWriter writer = xof.createXMLStreamWriter(out);
      XMLStreamWriter xtw = new IndentingXMLStreamWriter(writer);

      DefinitionsRootExport.writeRootElement(model, xtw, encoding);
      CollaborationExport.writePools(model, xtw);
      DataStoreExport.writeDataStores(model, xtw);
      SignalAndMessageDefinitionExport.writeSignalsAndMessages(model, xtw);
      
      for (Process process : model.getProcesses()) {
        
        if (process.getFlowElements().isEmpty() && process.getLanes().isEmpty()) {
          // empty process, ignore it 
          continue;
        }
      
        ProcessExport.writeProcess(process, xtw);
        
        for (FlowElement flowElement : process.getFlowElements()) {
          createXML(flowElement, model, xtw);
        }
        
        for (Artifact artifact : process.getArtifacts()) {
          createXML(artifact, model, xtw);
        }
        
        // end process element
        xtw.writeEndElement();
      }

      BPMNDIExport.writeBPMNDI(model, xtw);

      // end definitions root element
      xtw.writeEndElement();
      xtw.writeEndDocument();

      xtw.flush();

      outputStream.close();

      xtw.close();
      
      return outputStream.toByteArray();
      
    } catch (Exception e) {
      LOGGER.error("Error writing BPMN XML", e);
      throw new XMLException("Error writing BPMN XML", e);
    }
  }

  private void createXML(FlowElement flowElement, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    if (flowElement instanceof SubProcess) {
      
      SubProcess subProcess = (SubProcess) flowElement;
      xtw.writeStartElement(ELEMENT_SUBPROCESS);
      xtw.writeAttribute(ATTRIBUTE_ID, subProcess.getId());
      if (StringUtils.isNotEmpty(subProcess.getName())) {
        xtw.writeAttribute(ATTRIBUTE_NAME, subProcess.getName());
      } else {
        xtw.writeAttribute(ATTRIBUTE_NAME, "subProcess");
      }
      
      if (subProcess instanceof EventSubProcess) {
        xtw.writeAttribute(ATTRIBUTE_TRIGGERED_BY, ATTRIBUTE_VALUE_TRUE);
      }
      
      if (StringUtils.isNotEmpty(subProcess.getDocumentation())) {

        xtw.writeStartElement(ELEMENT_DOCUMENTATION);
        xtw.writeCharacters(subProcess.getDocumentation());
        xtw.writeEndElement();
      }
      
      boolean didWriteExtensionStartElement = ActivitiListenerExport.writeListeners(subProcess, false, xtw);
      
      didWriteExtensionStartElement = BpmnXMLUtil.writeExtensionElements(subProcess, didWriteExtensionStartElement, model.getNamespaces(), xtw);
      if (didWriteExtensionStartElement) {
        // closing extensions element
        xtw.writeEndElement();
      }
      
      MultiInstanceExport.writeMultiInstance(subProcess, xtw);
      
      for (FlowElement subElement : subProcess.getFlowElements()) {
        createXML(subElement, model, xtw);
      }
      
      for (Artifact artifact : subProcess.getArtifacts()) {
        createXML(artifact, model, xtw);
      }
      
      xtw.writeEndElement();
      
    } else {
    
      BaseBpmnXMLConverter converter = convertersToXMLMap.get(flowElement.getClass());
      
      if (converter == null) {
        throw new XMLException("No converter for " + flowElement.getClass() + " found");
      }
      
      converter.convertToXML(xtw, flowElement, model);
    }
  }
  
  private void createXML(Artifact artifact, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    BaseBpmnXMLConverter converter = convertersToXMLMap.get(artifact.getClass());
      
    if (converter == null) {
      throw new XMLException("No converter for " + artifact.getClass() + " found");
    }
      
    converter.convertToXML(xtw, artifact, model);
  }
}
!@#$%
20190526_172117,C:\Users\Alice Borner\Desktop\projects\Activiti\git\.merge_file_c13444
/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.bpmn.converter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.XMLConstants;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.stax.StAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import org.activiti.bpmn.constants.BpmnXMLConstants;
import org.activiti.bpmn.converter.alfresco.AlfrescoStartEventXMLConverter;
import org.activiti.bpmn.converter.alfresco.AlfrescoUserTaskXMLConverter;
import org.activiti.bpmn.converter.child.DocumentationParser;
import org.activiti.bpmn.converter.child.IOSpecificationParser;
import org.activiti.bpmn.converter.child.MultiInstanceParser;
import org.activiti.bpmn.converter.export.ActivitiListenerExport;
import org.activiti.bpmn.converter.export.BPMNDIExport;
import org.activiti.bpmn.converter.export.CollaborationExport;
import org.activiti.bpmn.converter.export.DataStoreExport;
import org.activiti.bpmn.converter.export.DefinitionsRootExport;
import org.activiti.bpmn.converter.export.MultiInstanceExport;
import org.activiti.bpmn.converter.export.ProcessExport;
import org.activiti.bpmn.converter.export.SignalAndMessageDefinitionExport;
import org.activiti.bpmn.converter.parser.BpmnEdgeParser;
import org.activiti.bpmn.converter.parser.BpmnShapeParser;
import org.activiti.bpmn.converter.parser.DataStoreParser;
import org.activiti.bpmn.converter.parser.DefinitionsParser;
import org.activiti.bpmn.converter.parser.ExtensionElementsParser;
import org.activiti.bpmn.converter.parser.ImportParser;
import org.activiti.bpmn.converter.parser.InterfaceParser;
import org.activiti.bpmn.converter.parser.ItemDefinitionParser;
import org.activiti.bpmn.converter.parser.LaneParser;
import org.activiti.bpmn.converter.parser.MessageFlowParser;
import org.activiti.bpmn.converter.parser.MessageParser;
import org.activiti.bpmn.converter.parser.ParticipantParser;
import org.activiti.bpmn.converter.parser.PotentialStarterParser;
import org.activiti.bpmn.converter.parser.ProcessParser;
import org.activiti.bpmn.converter.parser.ResourceParser;
import org.activiti.bpmn.converter.parser.SignalParser;
import org.activiti.bpmn.converter.parser.SubProcessParser;
import org.activiti.bpmn.converter.util.BpmnXMLUtil;
import org.activiti.bpmn.converter.util.InputStreamProvider;
import org.activiti.bpmn.exceptions.XMLException;
import org.activiti.bpmn.model.Activity;
import org.activiti.bpmn.model.Artifact;
import org.activiti.bpmn.model.Association;
import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.BooleanDataObject;
import org.activiti.bpmn.model.BoundaryEvent;
import org.activiti.bpmn.model.BpmnModel;
import org.activiti.bpmn.model.DateDataObject;
import org.activiti.bpmn.model.DoubleDataObject;
import org.activiti.bpmn.model.EventSubProcess;
import org.activiti.bpmn.model.FlowElement;
import org.activiti.bpmn.model.FlowNode;
import org.activiti.bpmn.model.IntegerDataObject;
import org.activiti.bpmn.model.LongDataObject;
import org.activiti.bpmn.model.Pool;
import org.activiti.bpmn.model.Process;
import org.activiti.bpmn.model.SequenceFlow;
import org.activiti.bpmn.model.StringDataObject;
import org.activiti.bpmn.model.SubProcess;
import org.activiti.bpmn.model.TextAnnotation;
import org.activiti.bpmn.model.Transaction;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

/**
 * @author Tijs Rademakers
 * @author Joram Barrez
 */
public class BpmnXMLConverter implements BpmnXMLConstants {

  protected static final Logger LOGGER = LoggerFactory.getLogger(BpmnXMLConverter.class);
	
  protected static final String BPMN_XSD = "org/activiti/impl/bpmn/parser/BPMN20.xsd";
  protected static final String DEFAULT_ENCODING = "UTF-8";
  
	protected static Map<String, BaseBpmnXMLConverter> convertersToBpmnMap = new HashMap<String, BaseBpmnXMLConverter>();
	protected static Map<Class<? extends BaseElement>, BaseBpmnXMLConverter> convertersToXMLMap = 
	    new HashMap<Class<? extends BaseElement>, BaseBpmnXMLConverter>();
	
	protected ClassLoader classloader;
	protected List<String> userTaskFormTypes;
	protected List<String> startEventFormTypes;
	
	protected BpmnEdgeParser bpmnEdgeParser = new BpmnEdgeParser();
	protected BpmnShapeParser bpmnShapeParser = new BpmnShapeParser();
	protected DefinitionsParser definitionsParser = new DefinitionsParser();
	protected DocumentationParser documentationParser = new DocumentationParser();
	protected ExtensionElementsParser extensionElementsParser = new ExtensionElementsParser();
	protected ImportParser importParser = new ImportParser();
	protected InterfaceParser interfaceParser = new InterfaceParser();
  protected ItemDefinitionParser itemDefinitionParser = new ItemDefinitionParser();
  protected IOSpecificationParser ioSpecificationParser = new IOSpecificationParser();
  protected DataStoreParser dataStoreParser = new DataStoreParser();
  protected LaneParser laneParser = new LaneParser();
  protected MessageParser messageParser = new MessageParser();
  protected MessageFlowParser messageFlowParser = new MessageFlowParser();
  protected MultiInstanceParser multiInstanceParser = new MultiInstanceParser();
  protected ParticipantParser participantParser = new ParticipantParser();
  protected PotentialStarterParser potentialStarterParser = new PotentialStarterParser();
  protected ProcessParser processParser = new ProcessParser();
  protected ResourceParser resourceParser = new ResourceParser();
  protected SignalParser signalParser = new SignalParser();
  protected SubProcessParser subProcessParser = new SubProcessParser();
	
	static {
		// events
	  addConverter(new EndEventXMLConverter());
	  addConverter(new StartEventXMLConverter());
    
    // tasks
	  addConverter(new BusinessRuleTaskXMLConverter());
    addConverter(new ManualTaskXMLConverter());
    addConverter(new ReceiveTaskXMLConverter());
    addConverter(new ScriptTaskXMLConverter());
    addConverter(new ServiceTaskXMLConverter());
    addConverter(new SendTaskXMLConverter());
    addConverter(new UserTaskXMLConverter());
    addConverter(new TaskXMLConverter());
    addConverter(new CallActivityXMLConverter());
    
    // gateways
    addConverter(new EventGatewayXMLConverter());
    addConverter(new ExclusiveGatewayXMLConverter());
    addConverter(new InclusiveGatewayXMLConverter());
    addConverter(new ParallelGatewayXMLConverter());
    addConverter(new ComplexGatewayXMLConverter());
    
    // connectors
    addConverter(new SequenceFlowXMLConverter());
    
    // catch, throw and boundary event
    addConverter(new CatchEventXMLConverter());
    addConverter(new ThrowEventXMLConverter());
    addConverter(new BoundaryEventXMLConverter());
    
    // artifacts
    addConverter(new TextAnnotationXMLConverter());
    addConverter(new AssociationXMLConverter());
    
    // data store reference
    addConverter(new DataStoreReferenceXMLConverter());
    
    // data objects
    addConverter(new ValuedDataObjectXMLConverter(), StringDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), BooleanDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), IntegerDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), LongDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), DoubleDataObject.class);
    addConverter(new ValuedDataObjectXMLConverter(), DateDataObject.class);
    
    // Alfresco types
    addConverter(new AlfrescoStartEventXMLConverter());
    addConverter(new AlfrescoUserTaskXMLConverter());
  }
  
  public static void addConverter(BaseBpmnXMLConverter converter) {
    addConverter(converter, converter.getBpmnElementType());
  }
  
  public static void addConverter(BaseBpmnXMLConverter converter, Class<? extends BaseElement> elementType) {
    convertersToBpmnMap.put(converter.getXMLElementName(), converter);
    convertersToXMLMap.put(elementType, converter);
  }
  
  public void setClassloader(ClassLoader classloader) {
    this.classloader = classloader;
  }

  public void setUserTaskFormTypes(List<String> userTaskFormTypes) {
    this.userTaskFormTypes = userTaskFormTypes;
  }
  
  public void setStartEventFormTypes(List<String> startEventFormTypes) {
    this.startEventFormTypes = startEventFormTypes;
  }
  
  public void validateModel(InputStreamProvider inputStreamProvider) throws Exception {
    Schema schema = createSchema();
    
    Validator validator = schema.newValidator();
    validator.validate(new StreamSource(inputStreamProvider.getInputStream()));
  }
  
  public void validateModel(XMLStreamReader xmlStreamReader) throws Exception {
    Schema schema = createSchema();
    
    Validator validator = schema.newValidator();
    validator.validate(new StAXSource(xmlStreamReader));
  }

  protected Schema createSchema() throws SAXException {
    SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
    Schema schema = null;
    if (classloader != null) {
      schema = factory.newSchema(classloader.getResource(BPMN_XSD));
    }
    
    if (schema == null) {
      schema = factory.newSchema(BpmnXMLConverter.class.getClassLoader().getResource(BPMN_XSD));
    }
    
    if (schema == null) {
      throw new XMLException("BPMN XSD could not be found");
    }
    return schema;
  }
  
  public BpmnModel convertToBpmnModel(InputStreamProvider inputStreamProvider, boolean validateSchema, boolean enableSafeBpmnXml) {
    return convertToBpmnModel(inputStreamProvider, validateSchema, enableSafeBpmnXml, DEFAULT_ENCODING);
  }
  
  public BpmnModel convertToBpmnModel(InputStreamProvider inputStreamProvider, boolean validateSchema, boolean enableSafeBpmnXml, String encoding) {
    XMLInputFactory xif = XMLInputFactory.newInstance();

    if (xif.isPropertySupported(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES)) {
      xif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);
    }

    if (xif.isPropertySupported(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES)) {
      xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    }

    if (xif.isPropertySupported(XMLInputFactory.SUPPORT_DTD)) {
      xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    }

    InputStreamReader in = null;
    try {
      in = new InputStreamReader(inputStreamProvider.getInputStream(), encoding);
      XMLStreamReader xtr = xif.createXMLStreamReader(in);
  
      try {
        if (validateSchema) {
          
          if (!enableSafeBpmnXml) {
            validateModel(inputStreamProvider);
          } else {
            validateModel(xtr);
          }
  
          // The input stream is closed after schema validation
          in = new InputStreamReader(inputStreamProvider.getInputStream(), encoding);
          xtr = xif.createXMLStreamReader(in);
        }
  
      } catch (Exception e) {
        throw new XMLException(e.getMessage(), e);
      }
  
      // XML conversion
      return convertToBpmnModel(xtr);
    } catch (UnsupportedEncodingException e) {
      throw new XMLException("The bpmn 2.0 xml is not UTF8 encoded", e);
    } catch (XMLStreamException e) {
      throw new XMLException("Error while reading the BPMN 2.0 XML", e);
    } finally {
      if (in != null) {
        try {
          in.close();
        } catch (IOException e) {
          LOGGER.debug("Problem closing BPMN input stream", e);
        }
      }
    }
  }

	public BpmnModel convertToBpmnModel(XMLStreamReader xtr) { 
	  BpmnModel model = new BpmnModel();
	  model.setStartEventFormTypes(startEventFormTypes);
	  model.setUserTaskFormTypes(userTaskFormTypes);
		try {
			Process activeProcess = null;
			List<SubProcess> activeSubProcessList = new ArrayList<SubProcess>();
			while (xtr.hasNext()) {
				try {
					xtr.next();
				} catch(Exception e) {
					LOGGER.debug("Error reading XML document", e);
					throw new XMLException("Error reading XML", e);
				}

				if (xtr.isEndElement()  && ELEMENT_SUBPROCESS.equals(xtr.getLocalName())) {
					activeSubProcessList.remove(activeSubProcessList.size() - 1);
				}
				
				if (xtr.isEndElement()  && ELEMENT_TRANSACTION.equals(xtr.getLocalName())) {
          activeSubProcessList.remove(activeSubProcessList.size() - 1);
        }

				if (xtr.isStartElement() == false) {
					continue;
				}

				if (ELEMENT_DEFINITIONS.equals(xtr.getLocalName())) {
				  definitionsParser.parse(xtr, model);
				  
        } else if (ELEMENT_RESOURCE.equals(xtr.getLocalName())) {
          resourceParser.parse(xtr, model);
          
				} else if (ELEMENT_SIGNAL.equals(xtr.getLocalName())) {
					signalParser.parse(xtr, model);
					
				} else if (ELEMENT_MESSAGE.equals(xtr.getLocalName())) {
          messageParser.parse(xtr, model);
          
				} else if (ELEMENT_ERROR.equals(xtr.getLocalName())) {
          
          if (StringUtils.isNotEmpty(xtr.getAttributeValue(null, ATTRIBUTE_ID))) {
            model.addError(xtr.getAttributeValue(null, ATTRIBUTE_ID),
                xtr.getAttributeValue(null, ATTRIBUTE_ERROR_CODE));
          }
          
				} else if (ELEMENT_IMPORT.equals(xtr.getLocalName())) {
				  importParser.parse(xtr, model);
          
				} else if (ELEMENT_ITEM_DEFINITION.equals(xtr.getLocalName())) {
				  itemDefinitionParser.parse(xtr, model);
          
				} else if (ELEMENT_DATA_STORE.equals(xtr.getLocalName())) {
				  dataStoreParser.parse(xtr, model);
				  
				} else if (ELEMENT_INTERFACE.equals(xtr.getLocalName())) {
				  interfaceParser.parse(xtr, model);
				  
				} else if (ELEMENT_IOSPECIFICATION.equals(xtr.getLocalName())) {
				  ioSpecificationParser.parseChildElement(xtr, activeProcess, model);
					
				} else if (ELEMENT_PARTICIPANT.equals(xtr.getLocalName())) {
				  participantParser.parse(xtr, model);
				  
				} else if (ELEMENT_MESSAGE_FLOW.equals(xtr.getLocalName())) {
          messageFlowParser.parse(xtr, model);

				} else if (ELEMENT_PROCESS.equals(xtr.getLocalName())) {
					
				  Process process = processParser.parse(xtr, model);
				  if (process != null) {
            activeProcess = process;	
				  }
				
				} else if (ELEMENT_POTENTIAL_STARTER.equals(xtr.getLocalName())) {
				  potentialStarterParser.parse(xtr, activeProcess);
				  
				} else if (ELEMENT_LANE.equals(xtr.getLocalName())) {
          laneParser.parse(xtr, activeProcess, model);
					
				} else if (ELEMENT_DOCUMENTATION.equals(xtr.getLocalName())) {
				  
					BaseElement parentElement = null;
					if (!activeSubProcessList.isEmpty()) {
						parentElement = activeSubProcessList.get(activeSubProcessList.size() - 1);
					} else if (activeProcess != null) {
						parentElement = activeProcess;
					}
					documentationParser.parseChildElement(xtr, parentElement, model);
				
				} else if (activeProcess == null && ELEMENT_TEXT_ANNOTATION.equals(xtr.getLocalName())) {
				  String elementId = xtr.getAttributeValue(null, ATTRIBUTE_ID);
          TextAnnotation textAnnotation = (TextAnnotation) new TextAnnotationXMLConverter().convertXMLToElement(xtr, model);
          textAnnotation.setId(elementId);
          model.getGlobalArtifacts().add(textAnnotation);
          
				} else if (activeProcess == null && ELEMENT_ASSOCIATION.equals(xtr.getLocalName())) {
          String elementId = xtr.getAttributeValue(null, ATTRIBUTE_ID);
          Association association = (Association) new AssociationXMLConverter().convertXMLToElement(xtr, model);
          association.setId(elementId);
          model.getGlobalArtifacts().add(association);
				
				} else if (ELEMENT_EXTENSIONS.equals(xtr.getLocalName())) {
				  extensionElementsParser.parse(xtr, activeSubProcessList, activeProcess, model);
				
				} else if (ELEMENT_SUBPROCESS.equals(xtr.getLocalName())) {
          subProcessParser.parse(xtr, activeSubProcessList, activeProcess);
          
				} else if (ELEMENT_TRANSACTION.equals(xtr.getLocalName())) {
          subProcessParser.parse(xtr, activeSubProcessList, activeProcess);
					
				} else if (ELEMENT_DI_SHAPE.equals(xtr.getLocalName())) {
          bpmnShapeParser.parse(xtr, model);
				
				} else if (ELEMENT_DI_EDGE.equals(xtr.getLocalName())) {
				  bpmnEdgeParser.parse(xtr, model);

				} else {

					if (!activeSubProcessList.isEmpty() && ELEMENT_MULTIINSTANCE.equalsIgnoreCase(xtr.getLocalName())) {
						
					  multiInstanceParser.parseChildElement(xtr, activeSubProcessList.get(activeSubProcessList.size() - 1), model);
					  
					} else if (convertersToBpmnMap.containsKey(xtr.getLocalName())) {
					  if (activeProcess != null) {
  					  BaseBpmnXMLConverter converter = convertersToBpmnMap.get(xtr.getLocalName());
  					  converter.convertToBpmnModel(xtr, model, activeProcess, activeSubProcessList);
					  }
					}
				}
			}

			for (Process process : model.getProcesses()) {
			  for (Pool pool : model.getPools()) {
			    if (process.getId().equals(pool.getProcessRef())) {
			      pool.setExecutable(process.isExecutable());
			    }
			  }
			  processFlowElements(process.getFlowElements(), process);
			}
		
		} catch (XMLException e) {
		  throw e;
		  
		} catch (Exception e) {
			LOGGER.error("Error processing BPMN document", e);
			throw new XMLException("Error processing BPMN document", e);
		}
		return model;
	}
	
	private void processFlowElements(Collection<FlowElement> flowElementList, BaseElement parentScope) {
	  for (FlowElement flowElement : flowElementList) {
  	  if (flowElement instanceof SequenceFlow) {
        SequenceFlow sequenceFlow = (SequenceFlow) flowElement;
        FlowNode sourceNode = getFlowNodeFromScope(sequenceFlow.getSourceRef(), parentScope);
        if (sourceNode != null) {
          sourceNode.getOutgoingFlows().add(sequenceFlow);
        }
        FlowNode targetNode = getFlowNodeFromScope(sequenceFlow.getTargetRef(), parentScope);
        if (targetNode != null) {
          targetNode.getIncomingFlows().add(sequenceFlow);
        }
      } else if (flowElement instanceof BoundaryEvent) {
        BoundaryEvent boundaryEvent = (BoundaryEvent) flowElement;
        FlowElement attachedToElement = getFlowNodeFromScope(boundaryEvent.getAttachedToRefId(), parentScope);
        if(attachedToElement != null) {
          boundaryEvent.setAttachedToRef((Activity) attachedToElement);
          ((Activity) attachedToElement).getBoundaryEvents().add(boundaryEvent);
        }
      } else if(flowElement instanceof SubProcess) {
        SubProcess subProcess = (SubProcess) flowElement;
        processFlowElements(subProcess.getFlowElements(), subProcess);
      }
	  }
	}
	
	private FlowNode getFlowNodeFromScope(String elementId, BaseElement scope) {
	  FlowNode flowNode = null;
	  if (StringUtils.isNotEmpty(elementId)) {
  	  if (scope instanceof Process) {
  	    flowNode = (FlowNode) ((Process) scope).getFlowElement(elementId);
  	  } else if (scope instanceof SubProcess) {
  	    flowNode = (FlowNode) ((SubProcess) scope).getFlowElement(elementId);
  	  }
	  }
	  return flowNode;
	}
	
	public byte[] convertToXML(BpmnModel model) {
	  return convertToXML(model, DEFAULT_ENCODING);
	}
	
	public byte[] convertToXML(BpmnModel model, String encoding) {
    try {

      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      
      XMLOutputFactory xof = XMLOutputFactory.newInstance();
      OutputStreamWriter out = new OutputStreamWriter(outputStream, encoding);

      XMLStreamWriter writer = xof.createXMLStreamWriter(out);
      XMLStreamWriter xtw = new IndentingXMLStreamWriter(writer);

      DefinitionsRootExport.writeRootElement(model, xtw, encoding);
      CollaborationExport.writePools(model, xtw);
      DataStoreExport.writeDataStores(model, xtw);
      SignalAndMessageDefinitionExport.writeSignalsAndMessages(model, xtw);
      
      for (Process process : model.getProcesses()) {
        
        if (process.getFlowElements().isEmpty() && process.getLanes().isEmpty()) {
          // empty process, ignore it 
          continue;
        }
      
        ProcessExport.writeProcess(process, xtw);
        
        for (FlowElement flowElement : process.getFlowElements()) {
          createXML(flowElement, model, xtw);
        }
        
        for (Artifact artifact : process.getArtifacts()) {
          createXML(artifact, model, xtw);
        }
        
        // end process element
        xtw.writeEndElement();
      }

      BPMNDIExport.writeBPMNDI(model, xtw);

      // end definitions root element
      xtw.writeEndElement();
      xtw.writeEndDocument();

      xtw.flush();

      outputStream.close();

      xtw.close();
      
      return outputStream.toByteArray();
      
    } catch (Exception e) {
      LOGGER.error("Error writing BPMN XML", e);
      throw new XMLException("Error writing BPMN XML", e);
    }
  }

  private void createXML(FlowElement flowElement, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    if (flowElement instanceof SubProcess) {
      
      SubProcess subProcess = (SubProcess) flowElement;
      if (flowElement instanceof Transaction) {
        xtw.writeStartElement(ELEMENT_TRANSACTION);
      } else {
        xtw.writeStartElement(ELEMENT_SUBPROCESS);
      }
      
      xtw.writeAttribute(ATTRIBUTE_ID, subProcess.getId());
      if (StringUtils.isNotEmpty(subProcess.getName())) {
        xtw.writeAttribute(ATTRIBUTE_NAME, subProcess.getName());
      } else {
        xtw.writeAttribute(ATTRIBUTE_NAME, "subProcess");
      }
      
      if (subProcess instanceof EventSubProcess) {
        xtw.writeAttribute(ATTRIBUTE_TRIGGERED_BY, ATTRIBUTE_VALUE_TRUE);
        
      } else if (subProcess instanceof Transaction == false) {
        if (subProcess.isAsynchronous()) {
          BpmnXMLUtil.writeQualifiedAttribute(ATTRIBUTE_ACTIVITY_ASYNCHRONOUS, ATTRIBUTE_VALUE_TRUE, xtw);
          if (subProcess.isNotExclusive()) {
            BpmnXMLUtil.writeQualifiedAttribute(ATTRIBUTE_ACTIVITY_EXCLUSIVE, ATTRIBUTE_VALUE_FALSE, xtw);
          }
        }
      }
      
      if (StringUtils.isNotEmpty(subProcess.getDocumentation())) {

        xtw.writeStartElement(ELEMENT_DOCUMENTATION);
        xtw.writeCharacters(subProcess.getDocumentation());
        xtw.writeEndElement();
      }
      
      boolean didWriteExtensionStartElement = ActivitiListenerExport.writeListeners(subProcess, false, xtw);
      
      didWriteExtensionStartElement = BpmnXMLUtil.writeExtensionElements(subProcess, didWriteExtensionStartElement, model.getNamespaces(), xtw);
      if (didWriteExtensionStartElement) {
        // closing extensions element
        xtw.writeEndElement();
      }
      
      MultiInstanceExport.writeMultiInstance(subProcess, xtw);
      
      for (FlowElement subElement : subProcess.getFlowElements()) {
        createXML(subElement, model, xtw);
      }
      
      for (Artifact artifact : subProcess.getArtifacts()) {
        createXML(artifact, model, xtw);
      }
      
      xtw.writeEndElement();
      
    } else {
    
      BaseBpmnXMLConverter converter = convertersToXMLMap.get(flowElement.getClass());
      
      if (converter == null) {
        throw new XMLException("No converter for " + flowElement.getClass() + " found");
      }
      
      converter.convertToXML(xtw, flowElement, model);
    }
  }
  
  private void createXML(Artifact artifact, BpmnModel model, XMLStreamWriter xtw) throws Exception {
    
    BaseBpmnXMLConverter converter = convertersToXMLMap.get(artifact.getClass());
      
    if (converter == null) {
      throw new XMLException("No converter for " + artifact.getClass() + " found");
    }
      
    converter.convertToXML(xtw, artifact, model);
  }
}
!@#$%
