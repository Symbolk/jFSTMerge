C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06176
<<<<<<< MINE
  private static final org.apache.thrift.protocol.TField ENDPOINT_DETAILS_FIELD_DESC = new org.apache.thrift.protocol.TField("endpoint_details", org.apache.thrift.protocol.TType.LIST, (short)4);
=======
  private static final org.apache.thrift.protocol.TField RPC_ENDPOINTS_FIELD_DESC = new org.apache.thrift.protocol.TField("rpc_endpoints", org.apache.thrift.protocol.TType.LIST, (short)4);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06176
<<<<<<< MINE
  public List<EndpointDetails> endpoint_details;
=======
  public List<String> rpc_endpoints;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06176
<<<<<<< MINE
    ENDPOINT_DETAILS((short)4, "endpoint_details");
=======
    RPC_ENDPOINTS((short)4, "rpc_endpoints");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06176
<<<<<<< MINE
    tmpMap.put(_Fields.ENDPOINT_DETAILS, new org.apache.thrift.meta_data.FieldMetaData("endpoint_details", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, EndpointDetails.class))));
=======
    tmpMap.put(_Fields.RPC_ENDPOINTS, new org.apache.thrift.meta_data.FieldMetaData("rpc_endpoints", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06176;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06176
<<<<<<< MINE
  public int getEndpoint_detailsSize() {
    return (this.endpoint_details == null) ? 0 : this.endpoint_details.size();
  }

  public java.util.Iterator<EndpointDetails> getEndpoint_detailsIterator() {
    return (this.endpoint_details == null) ? null : this.endpoint_details.iterator();
  }

  public void addToEndpoint_details(EndpointDetails elem) {
    if (this.endpoint_details == null) {
      this.endpoint_details = new ArrayList<EndpointDetails>();
    }
    this.endpoint_details.add(elem);
  }

  public List<EndpointDetails> getEndpoint_details() {
    return this.endpoint_details;
  }

  public TokenRange setEndpoint_details(List<EndpointDetails> endpoint_details) {
    this.endpoint_details = endpoint_details;
    return this;
  }

  public void unsetEndpoint_details() {
    this.endpoint_details = null;
  }

  /** Returns true if field endpoint_details is set (has been assigned a value) and false otherwise */
  public boolean isSetEndpoint_details() {
    return this.endpoint_details != null;
  }

  public void setEndpoint_detailsIsSet(boolean value) {
    if (!value) {
      this.endpoint_details = null;
=======
  public int getRpc_endpointsSize() {
    return (this.rpc_endpoints == null) ? 0 : this.rpc_endpoints.size();
  }

  public java.util.Iterator<String> getRpc_endpointsIterator() {
    return (this.rpc_endpoints == null) ? null : this.rpc_endpoints.iterator();
  }

  public void addToRpc_endpoints(String elem) {
    if (this.rpc_endpoints == null) {
      this.rpc_endpoints = new ArrayList<String>();
    }
    this.rpc_endpoints.add(elem);
  }

  public List<String> getRpc_endpoints() {
    return this.rpc_endpoints;
  }

  public TokenRange setRpc_endpoints(List<String> rpc_endpoints) {
    this.rpc_endpoints = rpc_endpoints;
    return this;
  }

  public void unsetRpc_endpoints() {
    this.rpc_endpoints = null;
  }

  /** Returns true if field rpc_endpoints is set (has been assigned a value) and false otherwise */
  public boolean isSetRpc_endpoints() {
    return this.rpc_endpoints != null;
  }

  public void setRpc_endpointsIsSet(boolean value) {
    if (!value) {
      this.rpc_endpoints = null;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
  private static final org.apache.thrift.protocol.TField ENDPOINT_DETAILS_FIELD_DESC = new org.apache.thrift.protocol.TField("endpoint_details", org.apache.thrift.protocol.TType.LIST, (short)5);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
  public List<EndpointDetails> endpoint_details;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
    RPC_ENDPOINTS((short)4, "rpc_endpoints"),
    ENDPOINT_DETAILS((short)5, "endpoint_details");
=======
    RPC_ENDPOINTS((short)4, "rpc_endpoints");
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
    tmpMap.put(_Fields.ENDPOINT_DETAILS, new org.apache.thrift.meta_data.FieldMetaData("endpoint_details", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, EndpointDetails.class))));
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
  public int getEndpoint_detailsSize() {
    return (this.endpoint_details == null) ? 0 : this.endpoint_details.size();
  }

  public java.util.Iterator<EndpointDetails> getEndpoint_detailsIterator() {
    return (this.endpoint_details == null) ? null : this.endpoint_details.iterator();
  }

  public void addToEndpoint_details(EndpointDetails elem) {
    if (this.endpoint_details == null) {
      this.endpoint_details = new ArrayList<EndpointDetails>();
    }
    this.endpoint_details.add(elem);
  }

  public List<EndpointDetails> getEndpoint_details() {
    return this.endpoint_details;
  }

  public TokenRange setEndpoint_details(List<EndpointDetails> endpoint_details) {
    this.endpoint_details = endpoint_details;
    return this;
  }

  public void unsetEndpoint_details() {
    this.endpoint_details = null;
  }

  /** Returns true if field endpoint_details is set (has been assigned a value) and false otherwise */
  public boolean isSetEndpoint_details() {
    return this.endpoint_details != null;
  }

  public void setEndpoint_detailsIsSet(boolean value) {
    if (!value) {
      this.endpoint_details = null;
    }
  }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetEndpoint_details()).compareTo(typedOther.isSetEndpoint_details());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetEndpoint_details()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.endpoint_details, typedOther.endpoint_details);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
                org.apache.thrift.protocol.TMap _map117 = iprot.readMapBegin();
                this.mutation_map = new HashMap<ByteBuffer,Map<String,List<Mutation>>>(2*_map117.size);
                for (int _i118 = 0; _i118 < _map117.size; ++_i118)
=======
                org.apache.thrift.protocol.TMap _map88 = iprot.readMapBegin();
                this.mutation_map = new HashMap<ByteBuffer,Map<String,List<Mutation>>>(2*_map88.size);
                for (int _i89 = 0; _i89 < _map88.size; ++_i89)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
                  ByteBuffer _key119;
                  Map<String,List<Mutation>> _val120;
                  _key119 = iprot.readBinary();
=======
                  ByteBuffer _key90;
                  Map<String,List<Mutation>> _val91;
                  _key90 = iprot.readBinary();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
                    org.apache.thrift.protocol.TMap _map121 = iprot.readMapBegin();
                    _val120 = new HashMap<String,List<Mutation>>(2*_map121.size);
                    for (int _i122 = 0; _i122 < _map121.size; ++_i122)
=======
                    org.apache.thrift.protocol.TMap _map92 = iprot.readMapBegin();
                    _val91 = new HashMap<String,List<Mutation>>(2*_map92.size);
                    for (int _i93 = 0; _i93 < _map92.size; ++_i93)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
                      String _key123;
                      List<Mutation> _val124;
                      _key123 = iprot.readString();
=======
                      String _key94;
                      List<Mutation> _val95;
                      _key94 = iprot.readString();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
                        org.apache.thrift.protocol.TList _list125 = iprot.readListBegin();
                        _val124 = new ArrayList<Mutation>(_list125.size);
                        for (int _i126 = 0; _i126 < _list125.size; ++_i126)
=======
                        org.apache.thrift.protocol.TList _list96 = iprot.readListBegin();
                        _val95 = new ArrayList<Mutation>(_list96.size);
                        for (int _i97 = 0; _i97 < _list96.size; ++_i97)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09480;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09480
<<<<<<< MINE
                          Mutation _elem127;
                          _elem127 = new Mutation();
                          _elem127.read(iprot);
                          _val124.add(_elem127);
=======
                          Mutation _elem98;
                          _elem98 = new Mutation();
                          _elem98.read(iprot);
                          _val95.add(_elem98);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b02704;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a02704;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c02704
<<<<<<< MINE
    public void trace_next_query(org.apache.thrift.async.AsyncMethodCallback<trace_next_query_call> resultHandler) throws org.apache.thrift.TException {
      checkReady();
      trace_next_query_call method_call = new trace_next_query_call(resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class trace_next_query_call extends org.apache.thrift.async.TAsyncMethodCall {
      public trace_next_query_call(org.apache.thrift.async.AsyncMethodCallback<trace_next_query_call> resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("trace_next_query", org.apache.thrift.protocol.TMessageType.CALL, 0));
        trace_next_query_args args = new trace_next_query_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public ByteBuffer getResult() throws org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_trace_next_query();
      }
    }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00772
<<<<<<< MINE
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
=======
import org.apache.commons.lang.builder.HashCodeBuilder;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00772
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // WHY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.why = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00772
<<<<<<< MINE
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
=======
import org.apache.commons.lang.builder.HashCodeBuilder;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00772
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // CREDENTIALS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map36 = iprot.readMapBegin();
              this.credentials = new HashMap<String,String>(2*_map36.size);
              for (int _i37 = 0; _i37 < _map36.size; ++_i37)
              {
                String _key38; // required
                String _val39; // required
                _key38 = iprot.readString();
                _val39 = iprot.readString();
                this.credentials.put(_key38, _val39);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00772
<<<<<<< MINE
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
=======
import org.apache.commons.lang.builder.HashCodeBuilder;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00772;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00772
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // WHY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.why = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09272
<<<<<<< MINE
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
=======
import org.apache.commons.lang.builder.HashCodeBuilder;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09272
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // WHY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.why = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09272
<<<<<<< MINE
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
=======
import org.apache.commons.lang.builder.HashCodeBuilder;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09272
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // CREDENTIALS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map36 = iprot.readMapBegin();
              this.credentials = new HashMap<String,String>(2*_map36.size);
              for (int _i37 = 0; _i37 < _map36.size; ++_i37)
              {
                String _key38; // required
                String _val39; // required
                _key38 = iprot.readString();
                _val39 = iprot.readString();
                this.credentials.put(_key38, _val39);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09272
<<<<<<< MINE
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
=======
import org.apache.commons.lang.builder.HashCodeBuilder;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09272;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09272
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // WHY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.why = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
  private static final org.apache.thrift.protocol.TField MEMTABLE_FLUSH_PERIOD_IN_MS_FIELD_DESC = new org.apache.thrift.protocol.TField("memtable_flush_period_in_ms", org.apache.thrift.protocol.TType.I32, (short)39);
  private static final org.apache.thrift.protocol.TField DEFAULT_TIME_TO_LIVE_FIELD_DESC = new org.apache.thrift.protocol.TField("default_time_to_live", org.apache.thrift.protocol.TType.I32, (short)40);
  private static final org.apache.thrift.protocol.TField INDEX_INTERVAL_FIELD_DESC = new org.apache.thrift.protocol.TField("index_interval", org.apache.thrift.protocol.TType.I32, (short)41);
  private static final org.apache.thrift.protocol.TField SPECULATIVE_RETRY_FIELD_DESC = new org.apache.thrift.protocol.TField("speculative_retry", org.apache.thrift.protocol.TType.STRING, (short)42);
  private static final org.apache.thrift.protocol.TField TRIGGERS_FIELD_DESC = new org.apache.thrift.protocol.TField("triggers", org.apache.thrift.protocol.TType.LIST, (short)43);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new CfDefStandardSchemeFactory());
    schemes.put(TupleScheme.class, new CfDefTupleSchemeFactory());
  }
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
  private static final int __MEMTABLE_FLUSH_PERIOD_IN_MS_ISSET_ID = 9;
  private static final int __DEFAULT_TIME_TO_LIVE_ISSET_ID = 10;
  private static final int __INDEX_INTERVAL_ISSET_ID = 11;
  private static final int __ROW_CACHE_SIZE_ISSET_ID = 12;
  private static final int __KEY_CACHE_SIZE_ISSET_ID = 13;
  private static final int __ROW_CACHE_SAVE_PERIOD_IN_SECONDS_ISSET_ID = 14;
  private static final int __KEY_CACHE_SAVE_PERIOD_IN_SECONDS_ISSET_ID = 15;
  private static final int __MEMTABLE_FLUSH_AFTER_MINS_ISSET_ID = 16;
  private static final int __MEMTABLE_THROUGHPUT_IN_MB_ISSET_ID = 17;
  private static final int __MEMTABLE_OPERATIONS_IN_MILLIONS_ISSET_ID = 18;
  private static final int __MERGE_SHARDS_CHANCE_ISSET_ID = 19;
  private static final int __ROW_CACHE_KEYS_TO_SAVE_ISSET_ID = 20;
  private int __isset_bitfield = 0;
  private _Fields optionals[] = {_Fields.COLUMN_TYPE,_Fields.COMPARATOR_TYPE,_Fields.SUBCOMPARATOR_TYPE,_Fields.COMMENT,_Fields.READ_REPAIR_CHANCE,_Fields.COLUMN_METADATA,_Fields.GC_GRACE_SECONDS,_Fields.DEFAULT_VALIDATION_CLASS,_Fields.ID,_Fields.MIN_COMPACTION_THRESHOLD,_Fields.MAX_COMPACTION_THRESHOLD,_Fields.REPLICATE_ON_WRITE,_Fields.KEY_VALIDATION_CLASS,_Fields.KEY_ALIAS,_Fields.COMPACTION_STRATEGY,_Fields.COMPACTION_STRATEGY_OPTIONS,_Fields.COMPRESSION_OPTIONS,_Fields.BLOOM_FILTER_FP_CHANCE,_Fields.CACHING,_Fields.DCLOCAL_READ_REPAIR_CHANCE,_Fields.POPULATE_IO_CACHE_ON_FLUSH,_Fields.MEMTABLE_FLUSH_PERIOD_IN_MS,_Fields.DEFAULT_TIME_TO_LIVE,_Fields.INDEX_INTERVAL,_Fields.SPECULATIVE_RETRY,_Fields.TRIGGERS,_Fields.ROW_CACHE_SIZE,_Fields.KEY_CACHE_SIZE,_Fields.ROW_CACHE_SAVE_PERIOD_IN_SECONDS,_Fields.KEY_CACHE_SAVE_PERIOD_IN_SECONDS,_Fields.MEMTABLE_FLUSH_AFTER_MINS,_Fields.MEMTABLE_THROUGHPUT_IN_MB,_Fields.MEMTABLE_OPERATIONS_IN_MILLIONS,_Fields.MERGE_SHARDS_CHANCE,_Fields.ROW_CACHE_PROVIDER,_Fields.ROW_CACHE_KEYS_TO_SAVE};
=======
  private static final int __ROW_CACHE_SIZE_ISSET_ID = 9;
  private static final int __KEY_CACHE_SIZE_ISSET_ID = 10;
  private static final int __ROW_CACHE_SAVE_PERIOD_IN_SECONDS_ISSET_ID = 11;
  private static final int __KEY_CACHE_SAVE_PERIOD_IN_SECONDS_ISSET_ID = 12;
  private static final int __MEMTABLE_FLUSH_AFTER_MINS_ISSET_ID = 13;
  private static final int __MEMTABLE_THROUGHPUT_IN_MB_ISSET_ID = 14;
  private static final int __MEMTABLE_OPERATIONS_IN_MILLIONS_ISSET_ID = 15;
  private static final int __MERGE_SHARDS_CHANCE_ISSET_ID = 16;
  private static final int __ROW_CACHE_KEYS_TO_SAVE_ISSET_ID = 17;
  private BitSet __isset_bit_vector = new BitSet(18);

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    tmpMap.put(_Fields.MEMTABLE_FLUSH_PERIOD_IN_MS, new org.apache.thrift.meta_data.FieldMetaData("memtable_flush_period_in_ms", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.DEFAULT_TIME_TO_LIVE, new org.apache.thrift.meta_data.FieldMetaData("default_time_to_live", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.INDEX_INTERVAL, new org.apache.thrift.meta_data.FieldMetaData("index_interval", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.SPECULATIVE_RETRY, new org.apache.thrift.meta_data.FieldMetaData("speculative_retry", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.TRIGGERS, new org.apache.thrift.meta_data.FieldMetaData("triggers", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, TriggerDef.class))));
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DCLOCAL_READ_REPAIR_CHANCE_ISSET_ID);
  }

  /** Returns true if field dclocal_read_repair_chance is set (has been assigned a value) and false otherwise */
  public boolean isSetDclocal_read_repair_chance() {
    return EncodingUtils.testBit(__isset_bitfield, __DCLOCAL_READ_REPAIR_CHANCE_ISSET_ID);
  }

  public void setDclocal_read_repair_chanceIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DCLOCAL_READ_REPAIR_CHANCE_ISSET_ID, value);
=======
    __isset_bit_vector.clear(__DCLOCAL_READ_REPAIR_CHANCE_ISSET_ID);
  }

  /** Returns true if field dclocal_read_repair_chance is set (has been assigned a value) and false otherwise */
  public boolean isSetDclocal_read_repair_chance() {
    return __isset_bit_vector.get(__DCLOCAL_READ_REPAIR_CHANCE_ISSET_ID);
  }

  public void setDclocal_read_repair_chanceIsSet(boolean value) {
    __isset_bit_vector.set(__DCLOCAL_READ_REPAIR_CHANCE_ISSET_ID, value);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __POPULATE_IO_CACHE_ON_FLUSH_ISSET_ID, value);
  }

  public int getMemtable_flush_period_in_ms() {
    return this.memtable_flush_period_in_ms;
  }

  public CfDef setMemtable_flush_period_in_ms(int memtable_flush_period_in_ms) {
    this.memtable_flush_period_in_ms = memtable_flush_period_in_ms;
    setMemtable_flush_period_in_msIsSet(true);
    return this;
  }

  public void unsetMemtable_flush_period_in_ms() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MEMTABLE_FLUSH_PERIOD_IN_MS_ISSET_ID);
  }

  /** Returns true if field memtable_flush_period_in_ms is set (has been assigned a value) and false otherwise */
  public boolean isSetMemtable_flush_period_in_ms() {
    return EncodingUtils.testBit(__isset_bitfield, __MEMTABLE_FLUSH_PERIOD_IN_MS_ISSET_ID);
  }

  public void setMemtable_flush_period_in_msIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MEMTABLE_FLUSH_PERIOD_IN_MS_ISSET_ID, value);
  }

  public int getDefault_time_to_live() {
    return this.default_time_to_live;
  }

  public CfDef setDefault_time_to_live(int default_time_to_live) {
    this.default_time_to_live = default_time_to_live;
    setDefault_time_to_liveIsSet(true);
    return this;
  }

  public void unsetDefault_time_to_live() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DEFAULT_TIME_TO_LIVE_ISSET_ID);
  }

  /** Returns true if field default_time_to_live is set (has been assigned a value) and false otherwise */
  public boolean isSetDefault_time_to_live() {
    return EncodingUtils.testBit(__isset_bitfield, __DEFAULT_TIME_TO_LIVE_ISSET_ID);
  }

  public void setDefault_time_to_liveIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DEFAULT_TIME_TO_LIVE_ISSET_ID, value);
  }

  public int getIndex_interval() {
    return this.index_interval;
  }

  public CfDef setIndex_interval(int index_interval) {
    this.index_interval = index_interval;
    setIndex_intervalIsSet(true);
    return this;
  }

  public void unsetIndex_interval() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __INDEX_INTERVAL_ISSET_ID);
  }

  /** Returns true if field index_interval is set (has been assigned a value) and false otherwise */
  public boolean isSetIndex_interval() {
    return EncodingUtils.testBit(__isset_bitfield, __INDEX_INTERVAL_ISSET_ID);
  }

  public void setIndex_intervalIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __INDEX_INTERVAL_ISSET_ID, value);
  }

  public String getSpeculative_retry() {
    return this.speculative_retry;
  }

  public CfDef setSpeculative_retry(String speculative_retry) {
    this.speculative_retry = speculative_retry;
    return this;
  }

  public void unsetSpeculative_retry() {
    this.speculative_retry = null;
  }

  /** Returns true if field speculative_retry is set (has been assigned a value) and false otherwise */
  public boolean isSetSpeculative_retry() {
    return this.speculative_retry != null;
  }

  public void setSpeculative_retryIsSet(boolean value) {
    if (!value) {
      this.speculative_retry = null;
    }
  }

  public int getTriggersSize() {
    return (this.triggers == null) ? 0 : this.triggers.size();
  }

  public java.util.Iterator<TriggerDef> getTriggersIterator() {
    return (this.triggers == null) ? null : this.triggers.iterator();
  }

  public void addToTriggers(TriggerDef elem) {
    if (this.triggers == null) {
      this.triggers = new ArrayList<TriggerDef>();
    }
    this.triggers.add(elem);
  }

  public List<TriggerDef> getTriggers() {
    return this.triggers;
  }

  public CfDef setTriggers(List<TriggerDef> triggers) {
    this.triggers = triggers;
    return this;
  }

  public void unsetTriggers() {
    this.triggers = null;
  }

  /** Returns true if field triggers is set (has been assigned a value) and false otherwise */
  public boolean isSetTriggers() {
    return this.triggers != null;
  }

  public void setTriggersIsSet(boolean value) {
    if (!value) {
      this.triggers = null;
    }
=======
    __isset_bit_vector.set(__POPULATE_IO_CACHE_ON_FLUSH_ISSET_ID, value);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      }
      break;

    case MEMTABLE_FLUSH_PERIOD_IN_MS:
      if (value == null) {
        unsetMemtable_flush_period_in_ms();
      } else {
        setMemtable_flush_period_in_ms((Integer)value);
      }
      break;

    case DEFAULT_TIME_TO_LIVE:
      if (value == null) {
        unsetDefault_time_to_live();
      } else {
        setDefault_time_to_live((Integer)value);
      }
      break;

    case INDEX_INTERVAL:
      if (value == null) {
        unsetIndex_interval();
      } else {
        setIndex_interval((Integer)value);
      }
      break;

    case SPECULATIVE_RETRY:
      if (value == null) {
        unsetSpeculative_retry();
      } else {
        setSpeculative_retry((String)value);
      }
      break;

    case TRIGGERS:
      if (value == null) {
        unsetTriggers();
      } else {
        setTriggers((List<TriggerDef>)value);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    }

    boolean this_present_memtable_flush_period_in_ms = true && this.isSetMemtable_flush_period_in_ms();
    boolean that_present_memtable_flush_period_in_ms = true && that.isSetMemtable_flush_period_in_ms();
    if (this_present_memtable_flush_period_in_ms || that_present_memtable_flush_period_in_ms) {
      if (!(this_present_memtable_flush_period_in_ms && that_present_memtable_flush_period_in_ms))
        return false;
      if (this.memtable_flush_period_in_ms != that.memtable_flush_period_in_ms)
        return false;
    }

    boolean this_present_default_time_to_live = true && this.isSetDefault_time_to_live();
    boolean that_present_default_time_to_live = true && that.isSetDefault_time_to_live();
    if (this_present_default_time_to_live || that_present_default_time_to_live) {
      if (!(this_present_default_time_to_live && that_present_default_time_to_live))
        return false;
      if (this.default_time_to_live != that.default_time_to_live)
        return false;
    }

    boolean this_present_index_interval = true && this.isSetIndex_interval();
    boolean that_present_index_interval = true && that.isSetIndex_interval();
    if (this_present_index_interval || that_present_index_interval) {
      if (!(this_present_index_interval && that_present_index_interval))
        return false;
      if (this.index_interval != that.index_interval)
        return false;
    }

    boolean this_present_speculative_retry = true && this.isSetSpeculative_retry();
    boolean that_present_speculative_retry = true && that.isSetSpeculative_retry();
    if (this_present_speculative_retry || that_present_speculative_retry) {
      if (!(this_present_speculative_retry && that_present_speculative_retry))
        return false;
      if (!this.speculative_retry.equals(that.speculative_retry))
        return false;
    }

    boolean this_present_triggers = true && this.isSetTriggers();
    boolean that_present_triggers = true && that.isSetTriggers();
    if (this_present_triggers || that_present_triggers) {
      if (!(this_present_triggers && that_present_triggers))
        return false;
      if (!this.triggers.equals(that.triggers))
        return false;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE

    boolean present_memtable_flush_period_in_ms = true && (isSetMemtable_flush_period_in_ms());
    builder.append(present_memtable_flush_period_in_ms);
    if (present_memtable_flush_period_in_ms)
      builder.append(memtable_flush_period_in_ms);

    boolean present_default_time_to_live = true && (isSetDefault_time_to_live());
    builder.append(present_default_time_to_live);
    if (present_default_time_to_live)
      builder.append(default_time_to_live);

    boolean present_index_interval = true && (isSetIndex_interval());
    builder.append(present_index_interval);
    if (present_index_interval)
      builder.append(index_interval);

    boolean present_speculative_retry = true && (isSetSpeculative_retry());
    builder.append(present_speculative_retry);
    if (present_speculative_retry)
      builder.append(speculative_retry);

    boolean present_triggers = true && (isSetTriggers());
    builder.append(present_triggers);
    if (present_triggers)
      builder.append(triggers);
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // KEYSPACE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.keyspace = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // NAME
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.name = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // COLUMN_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.column_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // COMPARATOR_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.comparator_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 6: // SUBCOMPARATOR_TYPE
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.subcomparator_type = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 8: // COMMENT
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.comment = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 12: // READ_REPAIR_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.read_repair_chance = iprot.readDouble();
            setRead_repair_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 13: // COLUMN_METADATA
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list46 = iprot.readListBegin();
              this.column_metadata = new ArrayList<ColumnDef>(_list46.size);
              for (int _i47 = 0; _i47 < _list46.size; ++_i47)
              {
                ColumnDef _elem48; // required
                _elem48 = new ColumnDef();
                _elem48.read(iprot);
                this.column_metadata.add(_elem48);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 14: // GC_GRACE_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.gc_grace_seconds = iprot.readI32();
            setGc_grace_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 15: // DEFAULT_VALIDATION_CLASS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.default_validation_class = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 16: // ID
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.id = iprot.readI32();
            setIdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 17: // MIN_COMPACTION_THRESHOLD
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.min_compaction_threshold = iprot.readI32();
            setMin_compaction_thresholdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 18: // MAX_COMPACTION_THRESHOLD
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.max_compaction_threshold = iprot.readI32();
            setMax_compaction_thresholdIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 24: // REPLICATE_ON_WRITE
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.replicate_on_write = iprot.readBool();
            setReplicate_on_writeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 26: // KEY_VALIDATION_CLASS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.key_validation_class = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 28: // KEY_ALIAS
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.key_alias = iprot.readBinary();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 29: // COMPACTION_STRATEGY
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.compaction_strategy = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 30: // COMPACTION_STRATEGY_OPTIONS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map49 = iprot.readMapBegin();
              this.compaction_strategy_options = new HashMap<String,String>(2*_map49.size);
              for (int _i50 = 0; _i50 < _map49.size; ++_i50)
              {
                String _key51; // required
                String _val52; // required
                _key51 = iprot.readString();
                _val52 = iprot.readString();
                this.compaction_strategy_options.put(_key51, _val52);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 32: // COMPRESSION_OPTIONS
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map53 = iprot.readMapBegin();
              this.compression_options = new HashMap<String,String>(2*_map53.size);
              for (int _i54 = 0; _i54 < _map53.size; ++_i54)
              {
                String _key55; // required
                String _val56; // required
                _key55 = iprot.readString();
                _val56 = iprot.readString();
                this.compression_options.put(_key55, _val56);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 33: // BLOOM_FILTER_FP_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.bloom_filter_fp_chance = iprot.readDouble();
            setBloom_filter_fp_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 34: // CACHING
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.caching = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 37: // DCLOCAL_READ_REPAIR_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.dclocal_read_repair_chance = iprot.readDouble();
            setDclocal_read_repair_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 38: // POPULATE_IO_CACHE_ON_FLUSH
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.populate_io_cache_on_flush = iprot.readBool();
            setPopulate_io_cache_on_flushIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 9: // ROW_CACHE_SIZE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.row_cache_size = iprot.readDouble();
            setRow_cache_sizeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 11: // KEY_CACHE_SIZE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.key_cache_size = iprot.readDouble();
            setKey_cache_sizeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 19: // ROW_CACHE_SAVE_PERIOD_IN_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_cache_save_period_in_seconds = iprot.readI32();
            setRow_cache_save_period_in_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 20: // KEY_CACHE_SAVE_PERIOD_IN_SECONDS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.key_cache_save_period_in_seconds = iprot.readI32();
            setKey_cache_save_period_in_secondsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 21: // MEMTABLE_FLUSH_AFTER_MINS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.memtable_flush_after_mins = iprot.readI32();
            setMemtable_flush_after_minsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 22: // MEMTABLE_THROUGHPUT_IN_MB
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.memtable_throughput_in_mb = iprot.readI32();
            setMemtable_throughput_in_mbIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 23: // MEMTABLE_OPERATIONS_IN_MILLIONS
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.memtable_operations_in_millions = iprot.readDouble();
            setMemtable_operations_in_millionsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 25: // MERGE_SHARDS_CHANCE
          if (field.type == org.apache.thrift.protocol.TType.DOUBLE) {
            this.merge_shards_chance = iprot.readDouble();
            setMerge_shards_chanceIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 27: // ROW_CACHE_PROVIDER
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.row_cache_provider = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 31: // ROW_CACHE_KEYS_TO_SAVE
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_cache_keys_to_save = iprot.readI32();
            setRow_cache_keys_to_saveIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    }
    if (isSetMemtable_flush_period_in_ms()) {
      if (!first) sb.append(", ");
      sb.append("memtable_flush_period_in_ms:");
      sb.append(this.memtable_flush_period_in_ms);
      first = false;
    }
    if (isSetDefault_time_to_live()) {
      if (!first) sb.append(", ");
      sb.append("default_time_to_live:");
      sb.append(this.default_time_to_live);
      first = false;
    }
    if (isSetIndex_interval()) {
      if (!first) sb.append(", ");
      sb.append("index_interval:");
      sb.append(this.index_interval);
      first = false;
    }
    if (isSetSpeculative_retry()) {
      if (!first) sb.append(", ");
      sb.append("speculative_retry:");
      if (this.speculative_retry == null) {
        sb.append("null");
      } else {
        sb.append(this.speculative_retry);
      }
      first = false;
    }
    if (isSetTriggers()) {
      if (!first) sb.append(", ");
      sb.append("triggers:");
      if (this.triggers == null) {
        sb.append("null");
      } else {
        sb.append(this.triggers);
      }
      first = false;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
     * @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
=======
     * Executes a CQL (Cassandra Query Language) statement and returns a
     * CqlResult containing the results.
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
     * @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
=======
     * Prepare a CQL (Cassandra Query Language) statement by compiling and returning
     * - the type of CQL statement
     * - an id token of the compiled CQL stored on the server side.
     * - a count of the discovered bound markers in the statement
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
     * @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
=======
     * Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
     * to bind and returns a CqlResult containing the results.
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    public void describe_version(org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;
=======
    public void describe_ring(String keyspace, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.describe_ring_call> resultHandler) throws org.apache.thrift.TException;

    public void describe_local_ring(String keyspace, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.describe_local_ring_call> resultHandler) throws org.apache.thrift.TException;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    public void describe_token_map(org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
=======
    public void describe_local_ring(String keyspace, org.apache.thrift.async.AsyncMethodCallback<describe_local_ring_call> resultHandler) throws org.apache.thrift.TException {
      checkReady();
      describe_local_ring_call method_call = new describe_local_ring_call(keyspace, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class describe_local_ring_call extends org.apache.thrift.async.TAsyncMethodCall {
      private String keyspace;
      public describe_local_ring_call(String keyspace, org.apache.thrift.async.AsyncMethodCallback<describe_local_ring_call> resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.keyspace = keyspace;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("describe_local_ring", org.apache.thrift.protocol.TMessageType.CALL, 0));
        describe_local_ring_args args = new describe_local_ring_args();
        args.setKeyspace(keyspace);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TokenRange> getResult() throws InvalidRequestException, org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_describe_local_ring();
      }
    }

    public void describe_token_map(org.apache.thrift.async.AsyncMethodCallback<describe_token_map_call> resultHandler) throws org.apache.thrift.TException {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
    public static class describe_token_map<I extends Iface> extends org.apache.thrift.ProcessFunction<I, describe_token_map_args> {
=======
    private static class describe_local_ring<I extends Iface> extends org.apache.thrift.ProcessFunction<I, describe_local_ring_args> {
      public describe_local_ring() {
        super("describe_local_ring");
      }

      protected describe_local_ring_args getEmptyArgsInstance() {
        return new describe_local_ring_args();
      }

      protected describe_local_ring_result getResult(I iface, describe_local_ring_args args) throws org.apache.thrift.TException {
        describe_local_ring_result result = new describe_local_ring_result();
        try {
          result.success = iface.describe_local_ring(args.keyspace);
        } catch (InvalidRequestException ire) {
          result.ire = ire;
        }
        return result;
      }
    }

    private static class describe_token_map<I extends Iface> extends org.apache.thrift.ProcessFunction<I, describe_token_map_args> {
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // AUTH_REQUEST
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.auth_request = new AuthenticationRequest();
              this.auth_request.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // AUTHNX
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.authnx = new AuthenticationException();
              this.authnx.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // AUTHZX
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.authzx = new AuthorizationException();
              this.authzx.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYSPACE
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PATH
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new ColumnOrSuperColumn();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // NFE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PREDICATE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list95 = iprot.readListBegin();
                this.success = new ArrayList<ColumnOrSuperColumn>(_list95.size);
                for (int _i96 = 0; _i96 < _list95.size; ++_i96)
                {
                  ColumnOrSuperColumn _elem97; // required
                  _elem97 = new ColumnOrSuperColumn();
                  _elem97.read(iprot);
                  this.success.add(_elem97);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PREDICATE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list99 = iprot.readListBegin();
                this.keys = new ArrayList<ByteBuffer>(_list99.size);
                for (int _i100 = 0; _i100 < _list99.size; ++_i100)
                {
                  ByteBuffer _elem101; // required
                  _elem101 = iprot.readBinary();
                  this.keys.add(_elem101);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PREDICATE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map103 = iprot.readMapBegin();
                this.success = new HashMap<ByteBuffer,List<ColumnOrSuperColumn>>(2*_map103.size);
                for (int _i104 = 0; _i104 < _map103.size; ++_i104)
                {
                  ByteBuffer _key105; // required
                  List<ColumnOrSuperColumn> _val106; // required
                  _key105 = iprot.readBinary();
                  {
                    org.apache.thrift.protocol.TList _list107 = iprot.readListBegin();
                    _val106 = new ArrayList<ColumnOrSuperColumn>(_list107.size);
                    for (int _i108 = 0; _i108 < _list107.size; ++_i108)
                    {
                      ColumnOrSuperColumn _elem109; // required
                      _elem109 = new ColumnOrSuperColumn();
                      _elem109.read(iprot);
                      _val106.add(_elem109);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key105, _val106);
                }
                iprot.readMapEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list112 = iprot.readListBegin();
                this.keys = new ArrayList<ByteBuffer>(_list112.size);
                for (int _i113 = 0; _i113 < _list112.size; ++_i113)
                {
                  ByteBuffer _elem114; // required
                  _elem114 = iprot.readBinary();
                  this.keys.add(_elem114);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // PREDICATE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map116 = iprot.readMapBegin();
                this.success = new HashMap<ByteBuffer,Integer>(2*_map116.size);
                for (int _i117 = 0; _i117 < _map116.size; ++_i117)
                {
                  ByteBuffer _key118; // required
                  int _val119; // required
                  _key118 = iprot.readBinary();
                  _val119 = iprot.readI32();
                  this.success.put(_key118, _val119);
                }
                iprot.readMapEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PREDICATE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.predicate = new SlicePredicate();
              this.predicate.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // RANGE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.range = new KeyRange();
              this.range.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list121 = iprot.readListBegin();
                this.success = new ArrayList<KeySlice>(_list121.size);
                for (int _i122 = 0; _i122 < _list121.size; ++_i122)
                {
                  KeySlice _elem123; // required
                  _elem123 = new KeySlice();
                  _elem123.read(iprot);
                  this.success.add(_elem123);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // COLUMN_FAMILY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.column_family = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // RANGE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.range = new KeyRange();
              this.range.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // START_COLUMN
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.start_column = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list125 = iprot.readListBegin();
                this.success = new ArrayList<KeySlice>(_list125.size);
                for (int _i126 = 0; _i126 < _list125.size; ++_i126)
                {
                  KeySlice _elem127; // required
                  _elem127 = new KeySlice();
                  _elem127.read(iprot);
                  this.success.add(_elem127);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // INDEX_CLAUSE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.index_clause = new IndexClause();
              this.index_clause.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN_PREDICATE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_predicate = new SlicePredicate();
              this.column_predicate.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list129 = iprot.readListBegin();
                this.success = new ArrayList<KeySlice>(_list129.size);
                for (int _i130 = 0; _i130 < _list129.size; ++_i130)
                {
                  KeySlice _elem131; // required
                  _elem131 = new KeySlice();
                  _elem131.read(iprot);
                  this.success.add(_elem131);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column = new Column();
              this.column.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PARENT
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_parent = new ColumnParent();
              this.column_parent.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // COLUMN
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column = new CounterColumn();
              this.column.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COLUMN_PATH
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.column_path = new ColumnPath();
              this.column_path.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TIMESTAMP
            if (field.type == org.apache.thrift.protocol.TType.I64) {
              this.timestamp = iprot.readI64();
              setTimestampIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetTimestamp()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
      }
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.key = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // PATH
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.path = new ColumnPath();
              this.path.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATION_MAP
            if (field.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map133 = iprot.readMapBegin();
                this.mutation_map = new HashMap<ByteBuffer,Map<String,List<Mutation>>>(2*_map133.size);
                for (int _i134 = 0; _i134 < _map133.size; ++_i134)
                {
                  ByteBuffer _key135; // required
                  Map<String,List<Mutation>> _val136; // required
                  _key135 = iprot.readBinary();
                  {
                    org.apache.thrift.protocol.TMap _map137 = iprot.readMapBegin();
                    _val136 = new HashMap<String,List<Mutation>>(2*_map137.size);
                    for (int _i138 = 0; _i138 < _map137.size; ++_i138)
                    {
                      String _key139; // required
                      List<Mutation> _val140; // required
                      _key139 = iprot.readString();
                      {
                        org.apache.thrift.protocol.TList _list141 = iprot.readListBegin();
                        _val140 = new ArrayList<Mutation>(_list141.size);
                        for (int _i142 = 0; _i142 < _list141.size; ++_i142)
                        {
                          Mutation _elem143; // required
                          _elem143 = new Mutation();
                          _elem143.read(iprot);
                          _val140.add(_elem143);
                        }
                        iprot.readListEnd();
                      }
                      _val136.put(_key139, _val140);
                    }
                    iprot.readMapEnd();
                  }
                  this.mutation_map.put(_key135, _val136);
                }
                iprot.readMapEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // MUTATION_MAP
            if (field.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map147 = iprot.readMapBegin();
                this.mutation_map = new HashMap<ByteBuffer,Map<String,List<Mutation>>>(2*_map147.size);
                for (int _i148 = 0; _i148 < _map147.size; ++_i148)
                {
                  ByteBuffer _key149; // required
                  Map<String,List<Mutation>> _val150; // required
                  _key149 = iprot.readBinary();
                  {
                    org.apache.thrift.protocol.TMap _map151 = iprot.readMapBegin();
                    _val150 = new HashMap<String,List<Mutation>>(2*_map151.size);
                    for (int _i152 = 0; _i152 < _map151.size; ++_i152)
                    {
                      String _key153; // required
                      List<Mutation> _val154; // required
                      _key153 = iprot.readString();
                      {
                        org.apache.thrift.protocol.TList _list155 = iprot.readListBegin();
                        _val154 = new ArrayList<Mutation>(_list155.size);
                        for (int _i156 = 0; _i156 < _list155.size; ++_i156)
                        {
                          Mutation _elem157; // required
                          _elem157 = new Mutation();
                          _elem157.read(iprot);
                          _val154.add(_elem157);
                        }
                        iprot.readListEnd();
                      }
                      _val150.put(_key153, _val154);
                    }
                    iprot.readMapEnd();
                  }
                  this.mutation_map.put(_key149, _val150);
                }
                iprot.readMapEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // CONSISTENCY_LEVEL
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CFNAME
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.cfname = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map161 = iprot.readMapBegin();
                this.success = new HashMap<String,List<String>>(2*_map161.size);
                for (int _i162 = 0; _i162 < _map161.size; ++_i162)
                {
                  String _key163; // required
                  List<String> _val164; // required
                  _key163 = iprot.readString();
                  {
                    org.apache.thrift.protocol.TList _list165 = iprot.readListBegin();
                    _val164 = new ArrayList<String>(_list165.size);
                    for (int _i166 = 0; _i166 < _list165.size; ++_i166)
                    {
                      String _elem167; // required
                      _elem167 = iprot.readString();
                      _val164.add(_elem167);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key163, _val164);
                }
                iprot.readMapEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list170 = iprot.readListBegin();
                this.success = new ArrayList<KsDef>(_list170.size);
                for (int _i171 = 0; _i171 < _list170.size; ++_i171)
                {
                  KsDef _elem172; // required
                  _elem172 = new KsDef();
                  _elem172.read(iprot);
                  this.success.add(_elem172);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYSPACE
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list174 = iprot.readListBegin();
                this.success = new ArrayList<TokenRange>(_list174.size);
                for (int _i175 = 0; _i175 < _list174.size; ++_i175)
                {
                  TokenRange _elem176; // required
                  _elem176 = new TokenRange();
                  _elem176.read(iprot);
                  this.success.add(_elem176);
                }
                iprot.readListEnd();
              }
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
=======
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, this.success.size()));
          for (Map.Entry<String, String> _iter186 : this.success.entrySet())
          {
            oprot.writeString(_iter186.getKey());
            oprot.writeString(_iter186.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYSPACE
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new KsDef();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // NFE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.nfe = new NotFoundException();
              this.nfe.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CF_NAME
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.cfName = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_TOKEN
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.start_token = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // END_TOKEN
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.end_token = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // KEYS_PER_SPLIT
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.keys_per_split = iprot.readI32();
              setKeys_per_splitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetKeys_per_split()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'keys_per_split' was not found in serialized data! Struct: " + toString());
      }
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
=======
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, this.success.size()));
          for (String _iter190 : this.success)
          {
            oprot.writeString(_iter190);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CF_NAME
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.cfName = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // START_TOKEN
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.start_token = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // END_TOKEN
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.end_token = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // KEYS_PER_SPLIT
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.keys_per_split = iprot.readI32();
              setKeys_per_splitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      if (!isSetKeys_per_split()) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'keys_per_split' was not found in serialized data! Struct: " + toString());
      }
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
=======
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, this.success.size()));
          for (CfSplit _iter194 : this.success)
          {
            _iter194.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetIre()) {
        oprot.writeFieldBegin(IRE_FIELD_DESC);
        this.ire.write(oprot);
        oprot.writeFieldEnd();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CF_DEF
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.cf_def = new CfDef();
              this.cf_def.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // COLUMN_FAMILY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.column_family = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KS_DEF
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ks_def = new KsDef();
              this.ks_def.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KEYSPACE
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.keyspace = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // KS_DEF
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ks_def = new KsDef();
              this.ks_def.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // CF_DEF
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.cf_def = new CfDef();
              this.cf_def.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.success = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // QUERY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.query = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COMPRESSION
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.compression = Compression.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new CqlResult();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // QUERY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.query = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COMPRESSION
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.compression = Compression.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // CONSISTENCY
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.consistency = ConsistencyLevel.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new CqlResult();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // QUERY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.query = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COMPRESSION
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.compression = Compression.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new CqlPreparedResult();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // QUERY
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.query = iprot.readBinary();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // COMPRESSION
            if (field.type == org.apache.thrift.protocol.TType.I32) {
              this.compression = Compression.findByValue(iprot.readI32());
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new CqlPreparedResult();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new CqlResult();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.success = new CqlResult();
              this.success.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // UE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ue = new UnavailableException();
              this.ue.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // TE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.te = new TimedOutException();
              this.te.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SDE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.sde = new SchemaDisagreementException();
              this.sde.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VERSION
            if (field.type == org.apache.thrift.protocol.TType.STRING) {
              this.version = iprot.readString();
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06872;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06872
<<<<<<< MINE
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
=======
      org.apache.thrift.protocol.TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // IRE
            if (field.type == org.apache.thrift.protocol.TType.STRUCT) {
              this.ire = new InvalidRequestException();
              this.ire.read(iprot);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b01356;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a01356;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c01356
<<<<<<< MINE
=======
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.channel.epoll.Epoll;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.epoll.EpollServerSocketChannel;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06332;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06332;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06332
<<<<<<< MINE

=======
            sslEngine.setEnabledProtocols(new String[] {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"});
            
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b10112;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a10112;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c10112
<<<<<<< MINE
            sslEngine.setEnabledProtocols(new String[] {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"});
=======
            sslEngine.setEnabledProtocols(SSLFactory.ACCEPTED_PROTOCOLS);
            
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b01640;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a01640;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c01640
<<<<<<< MINE
=======
import java.util.concurrent.Executors;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b07428;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a07428;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c07428
<<<<<<< MINE
import org.apache.cassandra.gms.Gossiper;
=======
import org.apache.cassandra.metrics.DefaultNameFactory;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
import java.net.ServerSocket;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
import org.junit.*;
=======
import org.junit.AfterClass;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.BeforeClass;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
import com.datastax.driver.core.*;
import com.datastax.driver.core.ResultSet;
=======
import static junit.framework.Assert.assertNotNull;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
import org.apache.cassandra.db.marshal.TupleType;
import org.apache.cassandra.exceptions.CassandraException;
import org.apache.cassandra.exceptions.ConfigurationException;
import org.apache.cassandra.exceptions.SyntaxException;
=======
import org.apache.cassandra.dht.Murmur3Partitioner;
import org.apache.cassandra.exceptions.*;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
    public static final String KEYSPACE_PER_TEST = "cql_test_keyspace_alt";
    protected static final boolean USE_PREPARED_VALUES = Boolean.valueOf(System.getProperty("cassandra.test.use_prepared", "true"));
=======
    private static final boolean USE_PREPARED_VALUES = Boolean.valueOf(System.getProperty("cassandra.test.use_prepared", "true"));
    protected static final long ROW_CACHE_SIZE_IN_MB = Integer.valueOf(System.getProperty("cassandra.test.row_cache_size_in_mb", "0"));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
        for (Session sess : session)
            if (sess != null)
                sess.close();
        for (Cluster cl : cluster)
            if (cl != null)
                cl.close();

        if (server != null)
            server.stop();
    }

    @Before
    public void beforeTest() throws Throwable
    {
        schemaChange(String.format("CREATE KEYSPACE IF NOT EXISTS %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}", KEYSPACE_PER_TEST));
=======
    }

    @Before
    public void beforeTest() throws Throwable
    {
        schemaChange(String.format("CREATE KEYSPACE IF NOT EXISTS %s WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'}", KEYSPACE));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
        return USE_PREPARED_VALUES;
    }

    public static FunctionName parseFunctionName(String qualifiedName)
    {
        int i = qualifiedName.indexOf('.');
        return i == -1
               ? FunctionName.nativeFunction(qualifiedName)
               : new FunctionName(qualifiedName.substring(0, i).trim(), qualifiedName.substring(i+1).trim());
    }

    public static String shortFunctionName(String f)
    {
        return parseFunctionName(f).name;
=======
        try
        {
            String currentTable = currentTable();
            if (currentTable != null)
                Keyspace.open(KEYSPACE).getColumnFamilyStore(currentTable).forceMajorCompaction();
        }
        catch (InterruptedException | ExecutionException e)
        {
            throw new RuntimeException(e);
        }
    }

    public void cleanupCache()
    {
        String currentTable = currentTable();
        if (currentTable != null)
            Keyspace.open(KEYSPACE).getColumnFamilyStore(currentTable).cleanupCache();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
    protected void assertLastSchemaChange(Event.SchemaChange.Change change, Event.SchemaChange.Target target,
                                          String keyspace, String name,
                                          String... argTypes)
    {
        Assert.assertTrue(lastSchemaChangeResult instanceof ResultMessage.SchemaChange);
        ResultMessage.SchemaChange schemaChange = (ResultMessage.SchemaChange) lastSchemaChangeResult;
        Assert.assertSame(change, schemaChange.change.change);
        Assert.assertSame(target, schemaChange.change.target);
        Assert.assertEquals(keyspace, schemaChange.change.keyspace);
        Assert.assertEquals(name, schemaChange.change.name);
        Assert.assertEquals(argTypes != null ? Arrays.asList(argTypes) : null, schemaChange.change.argTypes);
    }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a06116;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c06116
<<<<<<< MINE
        Assert.assertTrue(String.format("Got %s rows than expected. Expected %d but got %d", rows.length>i ? "less" : "more", rows.length, i), i == rows.length);
    }

    protected void assertColumnNames(UntypedResultSet result, String... expectedColumnNames)
    {
        if (result == null)
        {
            Assert.fail("No rows returned by query.");
            return;
        }

        List<ColumnSpecification> metadata = result.metadata();
        Assert.assertEquals("Got less columns than expected.", expectedColumnNames.length, metadata.size());

        for (int i = 0, m = metadata.size(); i < m; i++)
        {
            ColumnSpecification columnSpec = metadata.get(i);
            Assert.assertEquals(expectedColumnNames[i], columnSpec.name.toString());
        }
=======
        Assert.assertTrue(String.format("Got more rows than expected. Expected %d but got %d", rows.length, i), i == rows.length);
    }

    protected void assertRowCount(UntypedResultSet result, int numExpectedRows)
    {
        if (result == null)
        {
            if (numExpectedRows > 0)
                Assert.fail(String.format("No rows returned by query but %d expected", numExpectedRows));
            return;
        }

        List<ColumnSpecification> meta = result.metadata();
        Iterator<UntypedResultSet.Row> iter = result.iterator();
        int i = 0;
        while (iter.hasNext() && i < numExpectedRows)
        {
            UntypedResultSet.Row actual = iter.next();
            assertNotNull(actual);
            i++;
        }

        if (iter.hasNext())
        {
            while (iter.hasNext())
            {
                iter.next();
                i++;
            }
            Assert.fail(String.format("Got less rows than expected. Expected %d but got %d.", numExpectedRows, i));
        }

        Assert.assertTrue(String.format("Got %s rows than expected. Expected %d but got %d", numExpectedRows>i ? "less" : "more", numExpectedRows, i), i == numExpectedRows);
    }

    protected Object[][] getRows(UntypedResultSet result)
    {
        if (result == null)
            return new Object[0][];

        List<Object[]> ret = new ArrayList<>();
        List<ColumnSpecification> meta = result.metadata();

        Iterator<UntypedResultSet.Row> iter = result.iterator();
        while (iter.hasNext())
        {
            UntypedResultSet.Row rowVal = iter.next();
            Object[] row = new Object[meta.size()];
            for (int j = 0; j < meta.size(); j++)
            {
                ColumnSpecification column = meta.get(j);
                ByteBuffer val = rowVal.getBytes(column.name.toString());
                row[j] = val == null ? null : column.type.getSerializer().deserialize(val);
            }

            ret.add(row);
        }

        Object[][] a = new Object[ret.size()][];
        return ret.toArray(a);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b04240;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a04240;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c04240
<<<<<<< MINE

    private final boolean runManaged;
    protected final StartupChecks startupChecks;

    public CassandraDaemon() {
        this(false);
    }

    public CassandraDaemon(boolean runManaged) {
        this.runManaged = runManaged;
        this.startupChecks = new StartupChecks().withDefaultTests();
    }

=======
    private boolean setupCompleted = false;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b13000;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a13000;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c13000
<<<<<<< MINE
    public boolean isGossipOnlyMember(InetAddress endpoint)
=======
    /**
     * A fat client is a node that has not joined the ring, therefore acting as a coordinator only.
     *
     * @param endpoint - the endpoint to check
     * @return true if it is a fat client
     */
    public boolean isFatClient(InetAddress endpoint)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11404;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11404;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11404
<<<<<<< MINE
import com.codahale.metrics.Meter;
import com.codahale.metrics.MetricRegistryListener;
import com.codahale.metrics.SharedMetricRegistries;
=======
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Iterables;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03180;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03180;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03180
<<<<<<< MINE
    /*
     * Add values to the array with a bit set in every position
     */
    public static long[] enrich(long vals[])
    {
        long retval[] = Arrays.copyOf(vals, vals.length + 64);
        for (int ii = 0; ii < 64; ii++)
            retval[vals.length + ii] = 1L << ii;
        return retval;
   }

    @Test
    public void testVInt() throws Exception
    {
        setUp();
        long testValues[] = new long[] {
                0, 1, -1
                ,Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MAX_VALUE, Long.MAX_VALUE - 1
                ,Integer.MIN_VALUE, Integer.MIN_VALUE + 1, Integer.MAX_VALUE, Integer.MAX_VALUE - 1
                ,Short.MIN_VALUE, Short.MIN_VALUE + 1, Short.MAX_VALUE, Short.MAX_VALUE - 1
                ,Byte.MIN_VALUE, Byte.MIN_VALUE + 1, Byte.MAX_VALUE, Byte.MAX_VALUE - 1 };
        testValues = enrich(testValues);

        int expectedSize = 0;
        for (long v : testValues)
        {
            expectedSize += VIntCoding.computeVIntSize(v);
            ndosp.writeVInt(v);
        }

        ndosp.flush();

        @SuppressWarnings("resource")
        ByteBufferDataInput bbdi = new ByteBufferDataInput(ByteBuffer.wrap(generated.toByteArray()), "", 0, 0);

        assertEquals(expectedSize, generated.toByteArray().length);

        for (long v : testValues)
        {
            assertEquals(v, bbdi.readVInt());
        }
    }

    @Test
    public void testUnsignedVInt() throws Exception
    {
        setUp();
        long testValues[] = new long[] { //-1 };
                0, 1
                , UnsignedLong.MAX_VALUE.longValue(), UnsignedLong.MAX_VALUE.longValue() - 1, UnsignedLong.MAX_VALUE.longValue() + 1
                , UnsignedInteger.MAX_VALUE.longValue(), UnsignedInteger.MAX_VALUE.longValue() - 1, UnsignedInteger.MAX_VALUE.longValue() + 1
                , UnsignedBytes.MAX_VALUE, UnsignedBytes.MAX_VALUE - 1, UnsignedBytes.MAX_VALUE + 1
                , 65536, 65536 - 1, 65536 + 1 };
        testValues = enrich(testValues);

        int expectedSize = 0;
        for (long v : testValues)
        {
            expectedSize += VIntCoding.computeUnsignedVIntSize(v);
            ndosp.writeUnsignedVInt(v);
        }

        ndosp.flush();

        @SuppressWarnings("resource")
        ByteBufferDataInput bbdi = new ByteBufferDataInput(ByteBuffer.wrap(generated.toByteArray()), "", 0, 0);

        assertEquals(expectedSize, generated.toByteArray().length);

        for (long v : testValues)
            assertEquals(v, bbdi.readUnsignedVInt());
    }

    @Test
    public void testWriteSlowByteOrder() throws Exception
    {
        try (DataOutputBuffer dob = new DataOutputBuffer(4))
        {
            dob.order(ByteOrder.LITTLE_ENDIAN);
            dob.writeLong(42);
            assertEquals(42, ByteBuffer.wrap(dob.toByteArray()).order(ByteOrder.LITTLE_ENDIAN).getLong());
        }
    }

    @Test
    public void testWriteExcessSlow() throws Exception
    {
        try (DataOutputBuffer dob = new DataOutputBuffer(4))
        {
            dob.strictFlushing = true;
            ByteBuffer buf = ByteBuffer.allocateDirect(8);
            buf.putLong(0, 42);
            dob.write(buf);
            assertEquals(42, ByteBuffer.wrap(dob.toByteArray()).getLong());
        }
    }

    @Test
    public void testApplyToChannel() throws Exception
    {
        setUp();
        Object obj = new Object();
        Object retval = ndosp.applyToChannel( channel -> {
            ByteBuffer buf = ByteBuffer.allocate(8);
            buf.putLong(0, 42);
            try
            {
                channel.write(buf);
            }
            catch (Exception e)
            {
                throw new RuntimeException(e);
            }
            return obj;
        });
        assertEquals(obj, retval);
        assertEquals(42, ByteBuffer.wrap(generated.toByteArray()).getLong());
    }

    @Test(expected = UnsupportedOperationException.class)
    public void testApplyToChannelThrowsForMisaligned() throws Exception
    {
        setUp();
        ndosp.strictFlushing = true;
        ndosp.applyToChannel( channel -> {
            return null;
        });
    }

=======
    @Test
    public void testWriteUTF() throws Exception
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutput dataOut = new DataOutputStream(baos);

        StringBuilder sb = new StringBuilder(65535);
        for (int ii = 0; ii < 1 << 16; ii++)
        {
            String s = sb.toString();
            UnbufferedDataOutputStreamPlus.writeUTF(s, dataOut);
            DataInput dataIn = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));
            assertEquals(s, dataIn.readUTF());
            baos.reset();
            sb.append("a");
        }
    }

    @Test
    public void testWriteUTFBigChar() throws Exception
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutput dataOut = new DataOutputStream(baos);

        StringBuilder sb = new StringBuilder(65535);
        for (int ii = 0; ii < 1 << 15; ii++)
        {
            String s = sb.toString();
            UnbufferedDataOutputStreamPlus.writeUTF(s, dataOut);
            DataInput dataIn = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));
            assertEquals(s, dataIn.readUTF());
            baos.reset();
            if (ii == (1 << 15) - 1)
                sb.append("a");
            else
                sb.append(twoByte);
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03904
<<<<<<< MINE
import java.util.Collections;
import java.util.Map;
import java.util.UUID;
=======
import java.util.List;
import java.util.*;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03904
<<<<<<< MINE
            LocateRegistry.createRegistry(Integer.valueOf(jmxPort), null, serverFactory);
            JMXServiceURL url = new JMXServiceURL(String.format("service:jmx:rmi://localhost/jndi/rmi://localhost:%s/jmxrmi", jmxPort));
            jmxServer = new RMIConnectorServer(url, env, ManagementFactory.getPlatformMBeanServer());
            jmxServer.start();
=======
            logger.warn("JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.");

            jmxPort = System.getProperty("cassandra.jmx.local.port");

            if (jmxPort == null)
            {
                logger.error("cassandra.jmx.local.port missing from cassandra-env.sh, unable to start local JMX service." + jmxPort);
            }
            else
            {
                System.setProperty("java.rmi.server.hostname", InetAddress.getLoopbackAddress().getHostAddress());

                try
                {
                    RMIServerSocketFactory serverFactory = new RMIServerSocketFactoryImpl();
                    LocateRegistry.createRegistry(Integer.valueOf(jmxPort), null, serverFactory);

                    StringBuffer url = new StringBuffer();
                    url.append("service:jmx:");
                    url.append("rmi://localhost/jndi/");
                    url.append("rmi://localhost:").append(jmxPort).append("/jmxrmi");

                    Map env = new HashMap();
                    env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);

                    jmxServer = new RMIConnectorServer(
                            new JMXServiceURL(url.toString()),
                            env,
                            ManagementFactory.getPlatformMBeanServer()
                    );

                    jmxServer.start();
                }
                catch (IOException e)
                {
                    logger.error("Error starting local jmx server: ", e);
                }
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03904
<<<<<<< MINE
        // Delete any failed snapshot deletions on Windows - see CASSANDRA-9658
        if (FBUtilities.isWindows())
            WindowsFailedSnapshotTracker.deleteOldSnapshots();
=======
        try
        {
            logger.info("Hostname: {}", InetAddress.getLocalHost().getHostName());
        }
        catch (UnknownHostException e1)
        {
            logger.info("Could not resolve local host");
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03904
<<<<<<< MINE
            try {
                DatabaseDescriptor.forceStaticInitialization();
            } catch (ExceptionInInitializerError e) {
                throw e.getCause();
            }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03904;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03904
<<<<<<< MINE
    private void exitOrFail(int code, String message) {
        exitOrFail(code, message, null);
    }

    private void exitOrFail(int code, String message, Throwable cause) {
            if(runManaged) {
                RuntimeException t = cause!=null ? new RuntimeException(message, cause) : new RuntimeException(message);
                throw t;
            }
            else {
                logger.error(message, cause);
                System.exit(code);
            }

        }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11160;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11160;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11160
<<<<<<< MINE
=======
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b12980;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a12980;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c12980
<<<<<<< MINE
    /** Maximum difference in generation and version values we are willing to accept about a peer */
    private static final long MAX_GENERATION_DIFFERENCE = 86400 * 365;
    private long fatClientTimeout;
=======
    /** Maximimum difference in generation and version values we are willing to accept about a peer */
    private static final long MAX_GENERATION_DIFFERENCE = 86400 * 365;
    private long FatClientTimeout;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b12980;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a12980;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c12980
<<<<<<< MINE
            int heartbeat = epState.getHeartBeatState().getHeartBeatVersion();
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b07520;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a07520;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c07520
<<<<<<< MINE
=======
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.handler.ssl.SslHandler;
import org.apache.cassandra.utils.FBUtilities;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b07520;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a07520;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c07520
<<<<<<< MINE
            onStatusChange(endpoint, Event.StatusChange.nodeDown(getRpcAddress(endpoint), server.socket.getPort()));
        }

        private void onTopologyChange(InetAddress endpoint, Event.TopologyChange event)
        {
            if (logger.isTraceEnabled())
                logger.trace("Topology changed event : {}, {}", endpoint, event.change);

            LatestEvent prev = latestEvents.get(endpoint);
            if (prev == null || prev.topology != event.change)
            {
                LatestEvent ret = latestEvents.put(endpoint, LatestEvent.forTopologyChange(event.change, prev));
                if (ret == prev)
                    server.connectionTracker.send(event);
            }
        }

        private void onStatusChange(InetAddress endpoint, Event.StatusChange event)
        {
            if (logger.isTraceEnabled())
                logger.trace("Status changed event : {}, {}", endpoint, event.status);

            LatestEvent prev = latestEvents.get(endpoint);
            if (prev == null || prev.status != event.status)
            {
                LatestEvent ret = latestEvents.put(endpoint, LatestEvent.forStatusChange(event.status, prev));
                if (ret == prev)
                    server.connectionTracker.send(event);
            }
=======
            Event.StatusChange.Status prev = lastStatusChange.put(endpoint, Event.StatusChange.Status.DOWN);
            if (prev == null || prev != Event.StatusChange.Status.DOWN)
                send(endpoint, Event.StatusChange.nodeDown(getRpcAddress(endpoint), server.socket.getPort()));
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03052;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03052;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03052
<<<<<<< MINE
=======
import io.netty.buffer.ByteBuf;
import io.netty.channel.epoll.Epoll;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.epoll.EpollServerSocketChannel;
import io.netty.handler.codec.ByteToMessageDecoder;
import io.netty.util.Version;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11600;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11600;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11600
<<<<<<< MINE
=======
import java.util.concurrent.Callable;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b08504;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a08504;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c08504
<<<<<<< MINE
            if (logger.isDebugEnabled())
                logger.debug("Executing: {} with values {}", query, formatAllValues(values));
            rs = QueryProcessor.executeOnceInternal(query, transformValues(values));
=======
            logger.info("Executing: {} with values {}", query, formatAllValues(values));
            if (reusePrepared)
            {
                rs = QueryProcessor.executeInternal(query, transformValues(values));

                // If a test uses a "USE ...", then presumably its statements use relative table. In that case, a USE
                // change the meaning of the current keyspace, so we don't want a following statement to reuse a previously
                // prepared statement at this wouldn't use the right keyspace. To avoid that, we drop the previously
                // prepared statement.
                if (query.startsWith("USE"))
                    QueryProcessor.clearInternalStatementsCache();
            }
            else
            {
                rs = QueryProcessor.executeOnceInternal(query, transformValues(values));
            }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03124;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03124;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03124
<<<<<<< MINE
    /** Maximum difference in generation and version values we are willing to accept about a peer */
    private static final long MAX_GENERATION_DIFFERENCE = 86400 * 365;
    private long fatClientTimeout;
=======
    // Maximimum difference between generation value and local time we are willing to accept about a peer
    static final int MAX_GENERATION_DIFFERENCE = 86400 * 365;
    private long FatClientTimeout;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11696;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11696;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11696
<<<<<<< MINE
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.QueryState;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.transport.Event;
import org.apache.cassandra.transport.Server;
import org.apache.cassandra.transport.messages.ResultMessage;
import org.apache.cassandra.utils.ByteBufferUtil;
=======
import org.apache.cassandra.utils.FBUtilities;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03352;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03352;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03352
<<<<<<< MINE

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b12044;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a12044;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c12044
<<<<<<< MINE
import org.apache.cassandra.batchlog.LegacyBatchlogMigrator;
import org.apache.cassandra.concurrent.ScheduledExecutors;
=======
import com.codahale.metrics.jvm.BufferPoolMetricSet;
import com.codahale.metrics.jvm.FileDescriptorRatioGauge;
import com.codahale.metrics.jvm.GarbageCollectorMetricSet;
import com.codahale.metrics.jvm.MemoryUsageGaugeSet;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.Uninterruptibles;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.concurrent.*;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b09876;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a09876;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c09876
<<<<<<< MINE
    public boolean valuesEqual(InetAddress ep1, InetAddress ep2, ApplicationState as)
    {
        EndpointState state1 = getEndpointStateForEndpoint(ep1);
        EndpointState state2 = getEndpointStateForEndpoint(ep2);

        if (state1 == null || state2 == null)
            return false;

        VersionedValue value1 = state1.getApplicationState(as);
        VersionedValue value2 = state2.getApplicationState(as);

        return !(value1 == null || value2 == null) && value1.value.equals(value2.value);
    }

    // removes ALL endpoint states; should only be called after shadow gossip
    public void resetEndpointStateMap()
    {
        endpointStateMap.clear();
        unreachableEndpoints.clear();
        liveEndpoints.clear();
    }

=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03584
<<<<<<< MINE
    private final Set<InetAddress> seedsInShadowRound = new ConcurrentSkipListSet<>(inetcomparator);
=======
    // endpoint states as gathered during shadow round
    private final Map<InetAddress, EndpointState> endpointShadowStateMap = new ConcurrentHashMap<>();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03584
<<<<<<< MINE
     * @param localHostUUID - the host id to check
     * @param isBootstrapping - whether the node intends to bootstrap when joining
     * @return true if it is safe to start the node, false otherwise
=======
     * @param epStates - endpoint states in the cluster
     * @return true if the endpoint can join the cluster
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03584
<<<<<<< MINE
    public boolean isSafeForStartup(InetAddress endpoint, UUID localHostUUID, boolean isBootstrapping)
=======
    public boolean isSafeForBootstrap(InetAddress endpoint, Map<InetAddress, EndpointState> epStates)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03584
<<<<<<< MINE
        EndpointState epState = endpointStateMap.get(endpoint);
=======
        EndpointState epState = epStates.get(endpoint);

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03584
<<<<<<< MINE
    protected void maybeFinishShadowRound(InetAddress respondent, boolean isInShadowRound)
=======
    protected void finishShadowRound(Map<InetAddress, EndpointState> epStateMap)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a03584;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c03584
<<<<<<< MINE
            if (!isInShadowRound)
            {
                logger.debug("Received a regular ack from {}, can now exit shadow round", respondent);
                // respondent sent back a full ack, so we can exit our shadow round
                inShadowRound = false;
                seedsInShadowRound.clear();
            }
            else
            {
                // respondent indicates it too is in a shadow round, if all seeds
                // are in this state then we can exit our shadow round. Otherwise,
                // we keep retrying the SR until one responds with a full ACK or
                // we learn that all seeds are in SR.
                logger.debug("Received an ack from {} indicating it is also in shadow round", respondent);
                seedsInShadowRound.add(respondent);
                if (seedsInShadowRound.containsAll(seeds))
                {
                    logger.debug("All seeds are in a shadow round, clearing this node to exit its own");
                    inShadowRound = false;
                    seedsInShadowRound.clear();
                }
            }
=======
            endpointShadowStateMap.putAll(epStateMap);
            inShadowRound = false;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11644;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11644;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11644
<<<<<<< MINE
=======
import static junit.framework.Assert.assertNotNull;

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11644;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11644;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11644
<<<<<<< MINE
=======

>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b11644;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a11644;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c11644
<<<<<<< MINE
    public static void assertRows(UntypedResultSet result, Object[]... rows)
=======
    protected void assertRowsNet(ResultSet result, Object[]... rows)
    {
        assertRowsNet(maxProtocolVersion, result, rows);
    }

    protected void assertRows(UntypedResultSet result, Object[]... rows)
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b00204;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a00204;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c00204
<<<<<<< MINE
            if (server.eventExecutorGroup != null)
                pipeline.addLast(server.eventExecutorGroup, "executor", dispatcher);
            else
                pipeline.addLast("executor", dispatcher);
=======
            // The exceptionHandler will take care of handling exceptionCaught(...) events while still running
            // on the same EventLoop as all previous added handlers in the pipeline. This is important as the used
            // eventExecutorGroup may not enforce strict ordering for channel events.
            // As the exceptionHandler runs in the EventLoop as the previous handlers we are sure all exceptions are
            // correctly handled before the handler itself is removed.
            // See https://issues.apache.org/jira/browse/CASSANDRA-13649
            pipeline.addLast("exceptionHandler", exceptionHandler);

            pipeline.addLast(server.eventExecutorGroup, "executor", dispatcher);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b14040;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a14040;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c14040
<<<<<<< MINE
import java.util.Collections;
=======
import java.util.concurrent.TimeUnit;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b14040;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a14040;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c14040
<<<<<<< MINE
import com.google.common.collect.Iterables;

import org.apache.cassandra.cql3.functions.Function;
=======
import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.cassandra.config.CFMetaData;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b14040;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a14040;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c14040
<<<<<<< MINE
import org.apache.cassandra.utils.ByteBufferUtil;
=======
import org.apache.cassandra.utils.NoSpamLogger;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b02884;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a02884;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c02884
<<<<<<< MINE
import java.util.List;
=======
import java.util.concurrent.TimeUnit;
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b02884;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a02884;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c02884
<<<<<<< MINE
    /**
     * If this limit is ever raised, make sure @{@link Integer#MAX_VALUE} is not allowed,
     * as this is used as a flag to represent expired liveness.
     *
     * See {@link org.apache.cassandra.db.LivenessInfo#EXPIRED_LIVENESS_TTL}
     */
    public static final int MAX_TTL = 20 * 365 * 24 * 60 * 60; // 20 years in seconds
=======
    private static final int EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES = Integer.getInteger("cassandra.expiration_overflow_warning_interval_minutes", 5);

    private static final Logger logger = LoggerFactory.getLogger(Attributes.class);

    public enum ExpirationDateOverflowPolicy
    {
        REJECT, CAP
    }

    @VisibleForTesting
    public static ExpirationDateOverflowPolicy policy;

    static {
        String policyAsString = System.getProperty("cassandra.expiration_date_overflow_policy", ExpirationDateOverflowPolicy.REJECT.name());
        try
        {
            policy = ExpirationDateOverflowPolicy.valueOf(policyAsString.toUpperCase());
        }
        catch (RuntimeException e)
        {
            logger.warn("Invalid expiration date overflow policy: {}. Using default: {}", policyAsString, ExpirationDateOverflowPolicy.REJECT.name());
            policy = ExpirationDateOverflowPolicy.REJECT;
        }
    }

    public static final String MAXIMUM_EXPIRATION_DATE_EXCEEDED_WARNING = "Request on table {}.{} with {}ttl of {} seconds exceeds maximum supported expiration " +
                                                                          "date of 2038-01-19T03:14:06+00:00 and will have its expiration capped to that date. " +
                                                                          "In order to avoid this use a lower TTL or upgrade to a version where this limitation " +
                                                                          "is fixed. See CASSANDRA-14092 for more details.";

    public static final String MAXIMUM_EXPIRATION_DATE_EXCEEDED_REJECT_MESSAGE = "Request on table %s.%s with %sttl of %d seconds exceeds maximum supported expiration " +
                                                                                 "date of 2038-01-19T03:14:06+00:00. In order to avoid this use a lower TTL, change " +
                                                                                 "the expiration date overflow policy or upgrade to a version where this limitation " +
                                                                                 "is fixed. See CASSANDRA-14092 for more details.";
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b02884;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a02884;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c02884
<<<<<<< MINE
        if (ttl > MAX_TTL)
            throw new InvalidRequestException(String.format("ttl is too large. requested (%d) maximum (%d)", ttl, MAX_TTL));
=======
        if (ttl > ExpiringCell.MAX_TTL)
            throw new InvalidRequestException(String.format("ttl is too large. requested (%d) maximum (%d)", ttl, ExpiringCell.MAX_TTL));

        maybeApplyExpirationDateOverflowPolicy(metadata, ttl, false);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_b05460;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_a05460;C:\Users\Alice Borner\Desktop\projects\cassandra\git\.merge_file_c05460
<<<<<<< MINE
    }

    private boolean isKeepAliveSupported()
    {
        CassandraVersion peerVersion = Gossiper.instance.getReleaseVersion(peer);
        return STREAM_KEEP_ALIVE.isSupportedBy(peerVersion);
=======
>>>>>>> YOURS
