C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
            }

            @Override
            public void systemStatusChanged() {
                mHandler.refreshTitle();
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
                view = convertView;
            } else {
                if (mTouchView) {
                    view = mInflater.inflate(R.layout.message_list_item_touchable, parent, false);
                    view.setId(R.layout.message_list_item);
                } else {
                    view = mInflater.inflate(R.layout.message_list_item, parent, false);
                    view.setId(R.layout.message_list_item);
                }
=======
            if (position == mAdapter.messages.size()) {
                return getFooterView(position, convertView, parent);
            } else {
                return  getItemView(position, convertView, parent);
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
public View getItemView(int position, View convertView, ViewGroup parent) {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
                view = convertView;
            } else {
                if (mTouchView) {
                    view = mInflater.inflate(R.layout.message_list_item_touchable, parent, false);
                    view.setId(R.layout.message_list_item);
                } else {
                    view = mInflater.inflate(R.layout.message_list_item, parent, false);
                    view.setId(R.layout.message_list_item);
                }
            }

            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null) {
                holder = new MessageViewHolder();
                holder.subject = (TextView) view.findViewById(R.id.subject);
                holder.from = (TextView) view.findViewById(R.id.from);
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.preview = (TextView) view.findViewById(R.id.preview);
                holder.selected = (CheckBox) view.findViewById(R.id.selected_checkbox);
                holder.flagged = (CheckBox) view.findViewById(R.id.flagged);

                holder.flagged.setOnClickListener(flagClickListener);

                if (!mStars) {
                    holder.flagged.setVisibility(View.GONE);
                }

                if (mCheckboxes) {
                    holder.selected.setVisibility(View.VISIBLE);
                }

                if (holder.selected != null) {
                    holder.selected.setOnCheckedChangeListener(holder);
                }
                holder.subject.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSubject());
                holder.date.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListDate());

                if (mTouchView) {
                    holder.preview.setLines(mPreviewLines);
                    holder.preview.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListPreview());

                } else {
                    holder.from.setTextSize(TypedValue.COMPLEX_UNIT_DIP, mFontSizes.getMessageListSender());
                }

                view.setTag(holder);
            }

            if (message != null) {
                bindView(position, view, holder, message);
            } else {
                // This branch code is triggered when the local store
                // hands us an invalid message

                holder.chip.getBackground().setAlpha(0);
                holder.subject.setText(getString(R.string.general_no_subject));
                holder.subject.setTypeface(null, Typeface.NORMAL);
                String noSender = getString(R.string.general_no_sender);
                if (holder.preview != null) {
                    holder.preview.setText(noSender, TextView.BufferType.SPANNABLE);
                    Spannable str = (Spannable) holder.preview.getText();

                    ColorStateList color = holder.subject.getTextColors();
                    ColorStateList linkColor = holder.subject.getLinkTextColors();
                    str.setSpan(new TextAppearanceSpan(null, Typeface.NORMAL, mFontSizes.getMessageListSender(), color, linkColor),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                               );
                } else {
                    holder.from.setText(noSender);
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }

                holder.date.setText(getString(R.string.general_no_date));

                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
                holder.selected.setChecked(false);

                if (!mCheckboxes) {
                    holder.selected.setVisibility(View.GONE);
                }
                holder.flagged.setChecked(false);
            }


            return view;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a10740;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c10740
<<<<<<< MINE
=======
public View getFooterView(int position, View convertView, ViewGroup parent) {
            if (footerView == null) {
                footerView = mInflater.inflate(R.layout.message_list_item_footer, parent, false);
                if (mQueryString != null) {
                    footerView.setVisibility(View.GONE);
                }
                footerView.setId(R.layout.message_list_item_footer);
                FooterViewHolder holder = new FooterViewHolder();
                holder.progress = (ProgressBar)footerView.findViewById(R.id.message_list_progress);
                holder.progress.setIndeterminate(true);
                holder.main = (TextView)footerView.findViewById(R.id.main_text);
                footerView.setTag(holder);
            }

            FooterViewHolder holder = (FooterViewHolder)footerView.getTag();

            if (mCurrentFolder != null && mAccount != null) {
                if (mCurrentFolder.loading) {
                    holder.main.setText(getString(R.string.status_loading_more));
                    holder.progress.setVisibility(ProgressBar.VISIBLE);
                } else {
                    if (!mCurrentFolder.lastCheckFailed) {
                        if (mAccount.getDisplayCount() == 0) {
                            holder.main.setText(getString(R.string.message_list_load_more_messages_action));
                        } else {
                            holder.main.setText(String.format(getString(R.string.load_more_messages_fmt), mAccount.getDisplayCount()));
                        }
                    } else {
                        holder.main.setText(getString(R.string.status_loading_more_failed));
                    }
                    holder.progress.setVisibility(ProgressBar.INVISIBLE);
                }
            } else {
                holder.progress.setVisibility(ProgressBar.INVISIBLE);
            }

            return footerView;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c05900
<<<<<<< MINE
=======
/**
     * Remember the selection to be consistent between menu display and menu item
     * selection
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c05900
<<<<<<< MINE
=======
/**
         * @param messages Never {@code null}.
         */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c05900
<<<<<<< MINE
=======
/* (non-Javadoc)
     *
     * Method overridden for proper typing within this class (the return type is
     * more specific than the super implementation)
     *
     * @see android.app.Activity#onRetainNonConfigurationInstance()
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c05900
<<<<<<< MINE
=======
/*
     * (non-Javadoc)
     *
     * Android happens to invoke this method even if the given dialog is not
     * shown (eg. a dismissed dialog) as part of the automatic activity
     * reloading following a configuration change (orientation, keyboard,
     * locale, etc.).
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a05900;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c05900
<<<<<<< MINE
=======
/**
         * @param holders
         *            Never {@code null}.
         */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c04340
<<<<<<< MINE
=======
private void onToggleRead(final List<MessageInfoHolder> holders) {
        Message message;
        Folder folder;
        Account account;
        String folderName;

        int i = 0;
        for (final Iterator<MessageInfoHolder> iterator = holders.iterator(); iterator.hasNext(); i++) {
            final MessageInfoHolder messageInfo = iterator.next();
            message = messageInfo.message;
            folder = message.getFolder();
            account = folder.getAccount();
            folderName = message.getFolder().getName();

            mController.setFlag(account, folderName, new Message[]{message}, Flag.SEEN, !messageInfo.read);

            messageInfo.read = !messageInfo.read;
            mAdapter.sortMessages();
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a04340;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c04340
<<<<<<< MINE
=======
private void onToggleFlag(final List<MessageInfoHolder> holders) {
        Message message;
        Folder folder;
        Account account;
        String folderName;

        int i = 0;
        for (final Iterator<MessageInfoHolder> iterator = holders.iterator(); iterator.hasNext(); i++) {
            final MessageInfoHolder messageInfo = iterator.next();
            message = messageInfo.message;
            folder = message.getFolder();
            account = folder.getAccount();
            folderName = message.getFolder().getName();

            mController.setFlag(account, folderName, new Message[]{message}, Flag.FLAGGED, !messageInfo.flagged);

            messageInfo.flagged = !messageInfo.flagged;
            mAdapter.sortMessages();
        }
    }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
/**
     * If we're doing a search, this contains the query string.
     */
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
private final ActivityListener mListener = new ActivityListener() {

            @Override
            public void remoteSearchAddMessage(Account account, String folderName, Message message, final int numDone, final int numTotal) {

                if (numTotal > 0 && numDone < numTotal) {
                    mFragmentListener.setMessageListProgress(Window.PROGRESS_END / numTotal * numDone);
                } else {
                    mFragmentListener.setMessageListProgress(Window.PROGRESS_END);
                }

                mHandler.addOrUpdateMessages(account, folderName, Collections.singletonList(message), false);
            }

            @Override
            public void remoteSearchFailed(Account acct, String folder, final String err) {
                //TODO: Better error handling
                mHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(getActivity(), err, Toast.LENGTH_LONG).show();
                    }
                });
            }

            @Override
            public void remoteSearchStarted(Account acct, String folder) {
                mHandler.progress(true);
                mHandler.updateFooter(mContext.getString(R.string.remote_search_sending_query), true);
            }


            @Override
            public void remoteSearchFinished(Account acct, String folder, int numResults, List<Message> extraResults) {
                mHandler.progress(false);
                if (extraResults != null && extraResults.size() > 0) {
                    mExtraSearchResults = extraResults;
                    mHandler.updateFooter(String.format(mContext.getString(R.string.load_more_messages_fmt), acct.getRemoteSearchNumResults()), false);
                } else {
                    mHandler.updateFooter("", false);
                }
                mFragmentListener.setMessageListProgress(Window.PROGRESS_END);

            }

            @Override
            public void remoteSearchServerQueryComplete(Account account, String folderName, int numResults) {
                mHandler.progress(true);
                if (account != null &&  account.getRemoteSearchNumResults() != 0 && numResults > account.getRemoteSearchNumResults()) {
                    mHandler.updateFooter(mContext.getString(R.string.remote_search_downloading_limited, account.getRemoteSearchNumResults(), numResults), true);
                } else {
                    mHandler.updateFooter(mContext.getString(R.string.remote_search_downloading, numResults), true);
                }
                mFragmentListener.setMessageListProgress(Window.PROGRESS_START);
            }

            @Override
            public void informUserOfStatus() {
                mHandler.refreshTitle();
            }

            @Override
            public void synchronizeMailboxStarted(Account account, String folder) {
                if (updateForMe(account, folder)) {
                    mHandler.progress(true);
                    mHandler.folderLoading(folder, true);
                }
                super.synchronizeMailboxStarted(account, folder);
            }

            @Override
            public void synchronizeMailboxFinished(Account account, String folder,
            int totalMessagesInMailbox, int numNewMessages) {

                if (updateForMe(account, folder)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                super.synchronizeMailboxFinished(account, folder, totalMessagesInMailbox, numNewMessages);
            }

            @Override
            public void synchronizeMailboxFailed(Account account, String folder, String message) {

                if (updateForMe(account, folder)) {
                    mHandler.progress(false);
                    mHandler.folderLoading(folder, false);
                    mHandler.sortMessages();
                }
                super.synchronizeMailboxFailed(account, folder, message);
            }

            @Override
            public void synchronizeMailboxAddOrUpdateMessage(Account account, String folder, Message message) {
                mHandler.addOrUpdateMessages(account, folder, Collections.singletonList(message), true);
            }

            @Override
            public void synchronizeMailboxRemovedMessage(Account account, String folder, Message message) {
                mHandler.removeMessage(message.makeMessageReference());
            }

            @Override
            public void listLocalMessagesStarted(Account account, String folder) {
                if ((!mSingleAccountMode && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.progress(true);
                    if (folder != null) {
                        mHandler.folderLoading(folder, true);
                    }
                }
            }

            @Override
            public void listLocalMessagesFailed(Account account, String folder, String message) {
                if ((!mSingleAccountMode && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null) {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesFinished(Account account, String folder) {
                if ((!mSingleAccountMode && folder == null) || (account != null && account.equals(mAccount))) {
                    mHandler.sortMessages();
                    mHandler.progress(false);
                    if (folder != null) {
                        mHandler.folderLoading(folder, false);
                    }
                }
            }

            @Override
            public void listLocalMessagesRemoveMessage(Account account, String folder, Message message) {
                mHandler.removeMessage(message.makeMessageReference());
            }

            @Override
            public void listLocalMessagesAddMessages(Account account, String folder, List<Message> messages) {
                mHandler.addOrUpdateMessages(account, folder, messages, false);
            }

            @Override
            public void listLocalMessagesUpdateMessage(Account account, String folder, Message message) {
                mHandler.addOrUpdateMessages(account, folder, Collections.singletonList(message), false);
            }

            @Override
            public void searchStats(AccountStats stats) {
                mUnreadMessageCount = stats.unreadMessageCount;
                super.searchStats(stats);
            }

            @Override
            public void folderStatusChanged(Account account, String folder, int unreadMessageCount) {
                if (updateForMe(account, folder)) {
                    mUnreadMessageCount = unreadMessageCount;
                }
                super.folderStatusChanged(account, folder, unreadMessageCount);
            }

            @Override
            public void messageUidChanged(Account account, String folder, String oldUid, String newUid) {
                MessageReference ref = new MessageReference();
                ref.accountUuid = account.getUuid();
                ref.folderName = folder;
                ref.uid = oldUid;

                mHandler.changeMessageUid(ref, newUid);
            }
        };
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
private boolean updateForMe(Account account, String folder) {     	
        	// TODO get a contentprovider :D
        	return true;
        	
        	/*
            if ((account.equals(mAccount) && mFolderName != null && folder.equals(mFolderName))) {
                return true;
            } else {
                return false;
            }
            */
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
public void resetUnreadCount() {
            if (!mSingleFolderMode) {
                int unreadCount = 0;

                for (MessageInfoHolder holder : mMessages) {
                    unreadCount += holder.read ? 0 : 1;
                }

                mUnreadMessageCount = unreadCount;
                refreshTitle();
            }
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
public void addOrUpdateMessages(final Account account, final String folderName,
                final List<Message> messages, final boolean verifyAgainstSearch) {

            boolean needsSort = false;
            final List<MessageInfoHolder> messagesToAdd = new ArrayList<MessageInfoHolder>();
            List<MessageInfoHolder> messagesToRemove = new ArrayList<MessageInfoHolder>();
            List<Message> messagesToSearch = new ArrayList<Message>();

            // cache field into local variable for faster access for JVM without JIT
            final MessageHelper messageHelper = mMessageHelper;

            for (Message message : messages) {
                MessageInfoHolder m = getMessage(message);
                if (message.isSet(Flag.DELETED)) {
                    if (m != null) {
                        messagesToRemove.add(m);
                    }
                } else {
                    final Folder messageFolder = message.getFolder();
                    final Account messageAccount = messageFolder.getAccount();
                    if (m == null) {
                        if (updateForMe(account, folderName)) {
                            m = new MessageInfoHolder();
                            FolderInfoHolder folderInfoHolder = new FolderInfoHolder(
                                    mContext, messageFolder, messageAccount);
                            messageHelper.populate(m, message, folderInfoHolder, messageAccount);

                            if (verifyAgainstSearch) {
                                LocalMessage localMessage = (LocalMessage) message;

                                if (mThreadId != -1) {
                                    if (localMessage.getRootId() == mThreadId ||
                                            localMessage.getId() == mThreadId) {
                                        messagesToAdd.add(m);
                                    }
                                } else if (mThreadViewEnabled) {
                                    long threadId = localMessage.getRootId();
                                    if (threadId == -1) {
                                        threadId = localMessage.getId();
                                    }

                                    MessageInfoHolder threadPlaceHolder = getThread(threadId);
                                    if (threadPlaceHolder == null) {
                                        messagesToAdd.add(m);
                                    } else if (m.compareDate.after(threadPlaceHolder.compareDate)) {
                                        messagesToRemove.add(threadPlaceHolder);
                                        messagesToAdd.add(m);
                                    } else {
                                        threadPlaceHolder.threadCount = m.threadCount;
                                    }
                                } else {
                                    messagesToAdd.add(m);
                                }
                            } else {
                                messagesToAdd.add(m);
                            }
                        } /*else {
                            if (mQueryString != null) {
                                if (verifyAgainstSearch) {
                                    messagesToSearch.add(message);
                                } else {
                                    m = new MessageInfoHolder();
                                    FolderInfoHolder folderInfoHolder = new FolderInfoHolder(
                                            mContext, messageFolder, messageAccount);
                                    messageHelper.populate(m, message, folderInfoHolder,
                                            messageAccount);
                                    messagesToAdd.add(m);
                                }
                            }
                        }*/
                    } else {
                        m.dirty = false; // as we reload the message, unset its dirty flag
                        FolderInfoHolder folderInfoHolder = new FolderInfoHolder(mContext,
                                messageFolder, account);
                        messageHelper.populate(m, message, folderInfoHolder, account);
                        needsSort = true;
                    }
                }
            }

            if (!messagesToSearch.isEmpty()) {
            	// building a tree with all possible message id's we want to search in
            	ConditionsTreeNode msgIdTree = new ConditionsTreeNode(
            			new SearchCondition(SEARCHFIELD.UID, ATTRIBUTE.EQUALS, 
            					String.valueOf(messagesToSearch.get(0).getUid())));
            	
            	if (messagesToSearch.size() > 1) {
            		for(int i=1; i<messagesToSearch.size(); ++i) {
            			msgIdTree.or(new SearchCondition(SEARCHFIELD.UID, ATTRIBUTE.EQUALS, 
            					String.valueOf(messagesToSearch.get(i).getUid())));		
            		}
            	}
            	
            	// construct a new search with existing conditions and the message id narrowing
            	LocalSearch tmpSearch = null;
            	try {
            		tmpSearch = new LocalSearch(MessageListFragment.this.mSearch.getName());
					tmpSearch.and(msgIdTree);					
				} catch (Exception e) {
					// impossible, we created it here locally, parent = null
				}
            	
            	// search
                mController.searchLocalMessages(tmpSearch,
                new MessagingListener() {
                    @Override
                    public void listLocalMessagesAddMessages(Account account, String folder,
                            List<Message> messages) {
                        mHandler.addOrUpdateMessages(account, folder, messages, false);
                    }
                });
            }

            if (!messagesToRemove.isEmpty()) {
                removeMessages(messagesToRemove);
            }

            if (!messagesToAdd.isEmpty()) {
                addMessages(messagesToAdd);
            }

            if (needsSort) {
                sortMessages();
                resetUnreadCount();
            }
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
/**
     * Return the currently "open" account if available.
     *
     * @param prefs
     *         A {@link Preferences} instance that might be used to retrieve the current
     *         {@link Account}.
     *
     * @return The {@code Account} all displayed messages belong to.
     */
    /*private Account getCurrentAccount(Preferences prefs) {
        Account account = null;
        if (mQueryString != null && !mIntegrate && mAccountUuids != null &&
                mAccountUuids.length == 1) {
            String uuid = mAccountUuids[0];
            account = prefs.getAccount(uuid);
        } else if (mAccount != null) {
            account = mAccount;
        }

        return account;
    }*/
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a07652;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c07652
<<<<<<< MINE
=======
/**
     * Return the currently "open" account if available.
     *
     * @param prefs
     *         A {@link Preferences} instance that might be used to retrieve the current
     *         {@link Account}.
     *
     * @return The {@code Account} all displayed messages belong to.
     */
    /*private Account getCurrentAccount(Preferences prefs) {
        Account account = null;
        if (mQueryString != null && !mIntegrate && mAccountUuids != null &&
                mAccountUuids.length == 1) {
            String uuid = mAccountUuids[0];
            account = prefs.getAccount(uuid);
        } else if (mAccount != null) {
            account = mAccount;
        }

        return account;
    }*/
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06096
<<<<<<< MINE
/**
     * If we're doing a search, this contains the query string.
     */
=======
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06096
<<<<<<< MINE
=======
@Override
        public View getView(int position, View convertView, ViewGroup parent) {
            MessageInfoHolder message = (MessageInfoHolder) getItem(position);
            View view;

            if ((convertView != null) && (convertView.getId() == R.layout.message_list_item)) {
                view = convertView;
            } else {
                view = mInflater.inflate(R.layout.message_list_item, parent, false);
                view.setId(R.layout.message_list_item);
            }

            MessageViewHolder holder = (MessageViewHolder) view.getTag();

            if (holder == null) {
                holder = new MessageViewHolder();
                holder.date = (TextView) view.findViewById(R.id.date);
                holder.chip = view.findViewById(R.id.chip);
                holder.selected = (CheckBox) view.findViewById(R.id.selected_checkbox);
                holder.preview = (TextView) view.findViewById(R.id.preview);
                if (mCheckboxes) {
                    holder.selected.setVisibility(View.VISIBLE);
                }

                if (holder.selected != null) {
                    holder.selected.setOnCheckedChangeListener(holder);
                }


                if (mSenderAboveSubject) {
                    holder.from = (TextView) view.findViewById(R.id.subject);
                    holder.from.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListSender());
                } else {
                    holder.subject = (TextView) view.findViewById(R.id.subject);
                    holder.subject.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListSubject());
                }

                holder.date.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListDate());

                holder.preview.setLines(mPreviewLines);
                holder.preview.setTextSize(TypedValue.COMPLEX_UNIT_SP, mFontSizes.getMessageListPreview());

                view.setTag(holder);
            }

            if (message != null) {
                bindView(position, view, holder, message);
            } else {
                // This branch code is triggered when the local store
                // hands us an invalid message

                holder.chip.getBackground().setAlpha(0);
                if (holder.subject != null) {
                    holder.subject.setText(getString(R.string.general_no_subject));
                    holder.subject.setTypeface(null, Typeface.NORMAL);
                }

                String noSender = getString(R.string.general_no_sender);

                if (holder.preview != null) {
                    holder.preview.setText(noSender, TextView.BufferType.SPANNABLE);
                    Spannable str = (Spannable) holder.preview.getText();

                    str.setSpan(new StyleSpan(Typeface.NORMAL),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                    str.setSpan(new AbsoluteSizeSpan(mFontSizes.getMessageListSender(), true),
                                0,
                                noSender.length(),
                                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    holder.from.setText(noSender);
                    holder.from.setTypeface(null, Typeface.NORMAL);
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
                }

                holder.date.setText(getString(R.string.general_no_date));

                //WARNING: Order of the next 2 lines matter
                holder.position = -1;
                holder.selected.setChecked(false);

                if (!mCheckboxes) {
                    holder.selected.setVisibility(View.GONE);
                }
            }


            return view;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06096;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06096
<<<<<<< MINE
=======
private void bindView(final int position, final View view, final MessageViewHolder holder,
                              final MessageInfoHolder message) {

            int maybeBoldTypeface = message.read ? Typeface.NORMAL : Typeface.BOLD;

            // So that the mSelectedCount is only incremented/decremented
            // when a user checks the checkbox (vs code)
            holder.position = -1;

            holder.selected.setChecked(message.selected);

            if (!mCheckboxes && message.selected) {

                holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().getCheckmarkChip().drawable());
            }

            else {
                holder.chip.setBackgroundDrawable(message.message.getFolder().getAccount().generateColorChip(message.read,message.message.toMe(), message.message.ccMe(), message.message.fromMe(), message.flagged).drawable());

            }

            if (K9.useBackgroundAsUnreadIndicator()) {
                int res = (message.read) ? R.attr.messageListReadItemBackgroundColor :
                        R.attr.messageListUnreadItemBackgroundColor;

                TypedValue outValue = new TypedValue();
                getActivity().getTheme().resolveAttribute(res, outValue, true);
                view.setBackgroundColor(outValue.data);
            }

            String subject = null;

            if ((message.message.getSubject() == null) || message.message.getSubject().equals("")) {
                subject = (String) getText(R.string.general_no_subject);

            } else {
                subject = message.message.getSubject();
            }

            // We'll get badge support soon --jrv
//            if (holder.badge != null) {
//                String email = message.counterpartyAddress;
//                holder.badge.assignContactFromEmail(email, true);
//                if (email != null) {
//                    mContactsPictureLoader.loadContactPicture(email, holder.badge);
//                }
//            }

            if (holder.preview != null) {
                /*
                 * In the touchable UI, we have previews. Otherwise, we
                 * have just a "from" line.
                 * Because text views can't wrap around each other(?) we
                 * compose a custom view containing the preview and the
                 * from.
                 */

                CharSequence beforePreviewText = null;
                if (mSenderAboveSubject) {
                    beforePreviewText = subject;
                } else {
                    beforePreviewText = message.sender;
                }

                holder.preview.setText(new SpannableStringBuilder(recipientSigil(message))
                                       .append(beforePreviewText).append(" ").append(message.message.getPreview()),
                                       TextView.BufferType.SPANNABLE);
                Spannable str = (Spannable)holder.preview.getText();

                // Create a span section for the sender, and assign the correct font size and weight.
                str.setSpan(new AbsoluteSizeSpan((mSenderAboveSubject ? mFontSizes.getMessageListSubject(): mFontSizes.getMessageListSender()), true),
                            0, beforePreviewText.length() + 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);

                int color = (K9.getK9Theme() == K9.THEME_LIGHT) ?
                        Color.rgb(105, 105, 105) :
                        Color.rgb(160, 160, 160);

                // set span for preview message.
                str.setSpan(new ForegroundColorSpan(color), // How do I can specify the android.R.attr.textColorTertiary
                            beforePreviewText.length() + 1,
                            str.length(),
                            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }


            if (holder.from != null ) {
                holder.from.setTypeface(null, maybeBoldTypeface);
                if (mSenderAboveSubject) {
                    holder.from.setCompoundDrawablesWithIntrinsicBounds(
                            message.answered ? mAnsweredIcon : null, // left
                            null, // top
                            message.message.hasAttachments() ? mAttachmentIcon : null, // right
                            null); // bottom

                    holder.from.setText(message.sender);
                } else {
                    holder.from.setText(new SpannableStringBuilder(recipientSigil(message)).append(message.sender));
                }
            }

            if (holder.subject != null ) {
                if (!mSenderAboveSubject) {
                    holder.subject.setCompoundDrawablesWithIntrinsicBounds(
                            message.answered ? mAnsweredIcon : null, // left
                            null, // top
                            message.message.hasAttachments() ? mAttachmentIcon : null, // right
                            null); // bottom
                }

                holder.subject.setTypeface(null, maybeBoldTypeface);
                holder.subject.setText(subject);
            }

            holder.date.setText(message.getDate(mMessageHelper));
            holder.position = position;
        }
>>>>>>> YOURS
C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_b06516;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_a06516;C:\Users\Alice Borner\Desktop\projects\k-9\git\.merge_file_c06516
<<<<<<< MINE
/**
     * If we're doing a search, this contains the query string.
     */
=======
>>>>>>> YOURS
